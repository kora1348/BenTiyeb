<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Binance Futures — Variation 5m courante — USDT-M PERP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#0f172a; --card:#0b1220; --text:#e5e7eb; --muted:#94a3b8;
           --ok:#16a34a; --bad:#ef4444; --border:#1f2937; --chip:#111827; }
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:16px 20px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    h1{font-size:18px;margin:0}
    .sub{color:var(--muted);font-size:12px}
    main{padding:16px;max-width:100%;overflow:auto}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:#2563eb;color:#fff;border:0;border-radius:10px;padding:8px 12px;cursor:pointer}
    button:disabled{opacity:.6;cursor:not-allowed}
    .badge{background:var(--chip);border:1px solid var(--border);color:var(--muted);padding:4px 8px;border-radius:999px;font-size:12px}
    table{border-collapse:separate;border-spacing:0;width:100%;max-width:900px;background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden}
    th,td{padding:10px 12px;border-bottom:1px solid var(--border);white-space:nowrap;text-align:left;font-variant-numeric:tabular-nums}
    tr:last-child td{border-bottom:0}
    th:nth-child(2), td:nth-child(2){text-align:right}
    .pos{color:var(--ok);font-weight:600}
    .neg{color:var(--bad);font-weight:600}
    .zero{color:var(--muted)}
    .spin{width:16px;height:16px;border:3px solid #1f2b43;border-top-color:#6b8afd;border-radius:50%;display:inline-block;animation:spin .8s linear infinite;vertical-align:middle}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Variation % — tranche 5 minutes en cours (Europe/Brussels)</h1>
      <div class="sub">Calcul: (Closeₜ − Closeₜ₋₁) / Closeₜ₋₁ × 100 — Intervalle: 5m (bougie courante vs précédente).</div>
    </div>
    <div class="controls">
      <button id="refreshBtn">Actualiser</button>
      <span class="badge" id="status">Prêt</span>
    </div>
  </header>

  <main>
    <table id="tbl">
      <thead>
        <tr>
          <th>Symbole</th>
          <th>5m maintenant</th>
        </tr>
      </thead>
      <tbody id="tbody">
        <!-- lignes ajoutées dynamiquement -->
      </tbody>
    </table>
  </main>

  <script>
    const API = {
      base: 'https://fapi.binance.com',
      exchangeInfo: '/fapi/v1/exchangeInfo',
      klines: '/fapi/v1/klines'
    };

    const statusEl = document.getElementById('status');
    const tbody = document.getElementById('tbody');
    const refreshBtn = document.getElementById('refreshBtn');

    function setStatus(txt){ statusEl.textContent = txt; }
    function fmtPct(x){
      if (x == null || Number.isNaN(x)) return '<span class="zero">—</span>';
      const s = (x >= 0 ? '+' : '') + x.toFixed(2) + '%';
      const cls = x > 0 ? 'pos' : (x < 0 ? 'neg' : 'zero');
      return `<span class="${cls}">${s}</span>`;
    }

    async function fetchJSON(url){
      const r = await fetch(url);
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return r.json();
    }

    // Liste des symboles USDT-M PERP actifs
    async function getTradablePerpUSDT(){
      const data = await fetchJSON(API.base + API.exchangeInfo);
      return data.symbols
        .filter(s => s.status === 'TRADING' && s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT')
        .map(s => s.symbol)
        .sort();
    }

    // Récupère les 2 dernières bougies 5m (courante & précédente)
    async function getLast2Klines5m(symbol){
      const url = `${API.base}${API.klines}?symbol=${symbol}&interval=5m&limit=2`;
      const arr = await fetchJSON(url);
      // arr: [ [openTime, open, high, low, close, ...], ...]
      // S'il n'y a pas 2 bougies, on renvoie null
      if (!Array.isArray(arr) || arr.length < 2) return null;
      const prev = parseFloat(arr[arr.length-2][4]);
      const cur  = parseFloat(arr[arr.length-1][4]);
      if (!Number.isFinite(prev) || !Number.isFinite(cur)) return null;
      return { prevClose: prev, curClose: cur };
    }

    function computeChangePct(last2){
      if (!last2 || last2.prevClose === 0) return null;
      return (last2.curClose - last2.prevClose) / last2.prevClose * 100;
    }

    async function parallelLimit(items, limit, worker){
      const results = new Array(items.length);
      let i = 0;
      async function next(){
        const idx = i++;
        if (idx >= items.length) return;
        try { results[idx] = await worker(items[idx], idx); }
        catch(e){ results[idx] = { error: e.message }; }
        return next();
      }
      const runners = Array(Math.min(limit, items.length)).fill(0).map(next);
      await Promise.all(runners);
      return results;
    }

    async function refresh(){
      refreshBtn.disabled = true;
      setStatus('Chargement des symboles…');
      tbody.innerHTML = '';

      try{
        const symbols = await getTradablePerpUSDT();
        setStatus(`Symboles actifs: ${symbols.length} — récupération des variations 5m…`);

        // Pré-crée les lignes pour une sensation de vitesse
        const rowMap = new Map();
        for (const sym of symbols){
          const tr = document.createElement('tr');
          const tdSym = document.createElement('td'); tdSym.textContent = sym;
          const tdVal = document.createElement('td'); tdVal.innerHTML = '<span class="zero">—</span>';
          tr.appendChild(tdSym); tr.appendChild(tdVal);
          tbody.appendChild(tr);
          rowMap.set(sym, tdVal);
        }

        let done = 0;
        await parallelLimit(symbols, 8, async (sym) => {
          const last2 = await getLast2Klines5m(sym);
          const pct = computeChangePct(last2);
          rowMap.get(sym).innerHTML = fmtPct(pct);
          done++;
          if (done % 10 === 0) setStatus(`MAJ ${done}/${symbols.length}`);
        });

        setStatus('Terminé ✅');
      }catch(err){
        console.error(err);
        setStatus('Erreur: ' + err.message);
      }finally{
        refreshBtn.disabled = false;
      }
    }

    refreshBtn.addEventListener('click', refresh);

    // Chargement initial
    refresh();
  </script>
</body>
</html>
