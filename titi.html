<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbitrage Binance Futures - USDT/USDC</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1e222d;
            color: #eaecef;
        }
        h1 {
            color: #f0b90b;
            text-align: center;
            margin-bottom: 30px;
        }
        .controls {
            background-color: #2b3139;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        button {
            background-color: #f0b90b;
            color: #1e222d;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s;
            flex: 1;
            min-width: 200px;
        }
        button:hover {
            background-color: #d8a600;
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        label {
            font-weight: bold;
            margin-right: 10px;
            color: #f0b90b;
        }
        input, select {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #444;
            background-color: #2b3139;
            color: #eaecef;
            font-size: 16px;
            flex: 2;
            min-width: 150px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #2b3139;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #3a424e;
        }
        th {
            background-color: #f0b90b;
            color: #1e222d;
            font-weight: bold;
            position: sticky;
            top: 0;
        }
        tr:hover {
            background-color: #3a424e;
        }
        .profit {
            color: #0ecb81;
            font-weight: bold;
        }
        .loss {
            color: #f6465d;
            font-weight: bold;
        }
        .loading {
            text-align: center;
            padding: 30px;
            font-style: italic;
            color: #aaa;
            font-size: 18px;
        }
        .info {
            background-color: #2b3139;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            border-left: 4px solid #f0b90b;
        }
        .info h3 {
            color: #f0b90b;
            margin-top: 0;
        }
        .info ul {
            padding-left: 20px;
        }
        .info li {
            margin-bottom: 8px;
        }
        #status {
            margin-top: 15px;
            font-style: italic;
            color: #aaa;
        }
        .last-update {
            text-align: right;
            font-size: 12px;
            color: #777;
            margin-top: 10px;
        }
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>Arbitrage Triangulaire Binance Futures</h1>
    
    <div class="info">
        <h3>Détection d'opportunités d'arbitrage USDT/USDC</h3>
        <p>Cet outil analyse en temps réel les paires Futures sur Binance pour détecter des opportunités d'arbitrage triangulaire avec un écart de prix significatif.</p>
        <p><strong>Fonctionnalités :</strong></p>
        <ul>
            <li>Analyse des paires Futures USDT-M et USDC-M</li>
            <li>Détection des triangles d'arbitrage rentables</li>
            <li>Calcul des profits après frais de trading (0.04%)</li>
            <li>Actualisation automatique toutes les 10 secondes</li>
            <li>Filtrage par profit minimum</li>
        </ul>
    </div>
    
    <div class="controls">
        <label for="minProfit">Profit minimum (%):</label>
        <input type="number" id="minProfit" value="0.5" min="0.1" step="0.1">
        
        <button id="startBtn">Démarrer la surveillance</button>
        <button id="stopBtn" disabled>Arrêter</button>
        
        <div id="status">Prêt à démarrer</div>
        <div class="last-update" id="lastUpdate"></div>
    </div>
    
    <div id="loading" class="loading" style="display: none;">
        <div class="spinner"></div>
        <p>Chargement des données depuis Binance Futures...</p>
    </div>
    
    <div id="results">
        <table id="opportunitiesTable">
            <thead>
                <tr>
                    <th>Triangle</th>
                    <th>Détails du chemin</th>
                    <th>Écart (%)</th>
                    <th>Profit net (%)</th>
                    <th>Action</th>
                </tr>
            </thead>
            <tbody id="opportunitiesBody">
                <tr>
                    <td colspan="5" style="text-align: center;">Aucune analyse effectuée. Cliquez sur "Démarrer la surveillance".</td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configuration
            const STABLE_COINS = ['USDT', 'USDC'];
            const TRADING_FEE = 0.0004; // 0.04% par trade (0.02% si on utilise BNB)
            const REFRESH_INTERVAL = 10000; // 10 secondes
            
            // Éléments DOM
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const loadingElement = document.getElementById('loading');
            const opportunitiesBody = document.getElementById('opportunitiesBody');
            const minProfitInput = document.getElementById('minProfit');
            const statusElement = document.getElementById('status');
            const lastUpdateElement = document.getElementById('lastUpdate');
            
            // Variables d'état
            let allSymbols = [];
            let prices = {};
            let refreshInterval = null;
            let isRunning = false;
            
            // Récupérer tous les symboles Futures depuis Binance
            async function fetchAllSymbols() {
                try {
                    showLoading();
                    statusElement.textContent = "Récupération des paires disponibles...";
                    
                    const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
                    if (!response.ok) throw new Error('Erreur réseau');
                    
                    const data = await response.json();
                    
                    // Filtrer pour ne garder que les paires USDT et USDC en Futures
                    allSymbols = data.symbols
                        .filter(s => s.status === 'TRADING' && s.contractType === 'PERPETUAL')
                        .filter(s => STABLE_COINS.some(coin => s.symbol.endsWith(coin)))
                        .map(s => s.symbol);
                    
                    if (allSymbols.length === 0) {
                        throw new Error('Aucune paire valide trouvée');
                    }
                    
                    statusElement.textContent = `${allSymbols.length} paires Futures trouvées`;
                    return allSymbols;
                } catch (error) {
                    console.error('Erreur:', error);
                    statusElement.textContent = `Erreur: ${error.message}`;
                    
                    // Fallback avec des paires populaires si l'API échoue
                    allSymbols = [
                        'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 
                        'ADAUSDT', 'DOGEUSDT', 'DOTUSDT', 'MATICUSDT', 'LTCUSDT',
                        'BTCUSDC', 'ETHUSDC', 'BNBUSDC', 'SOLUSDC', 'XRPUSDC'
                    ].filter(s => STABLE_COINS.some(coin => s.endsWith(coin)));
                    
                    statusElement.textContent = `Mode démo: ${allSymbols.length} paires chargées`;
                    return allSymbols;
                } finally {
                    hideLoading();
                }
            }
            
            // Récupérer les prix actuels des Futures
            async function fetchPrices() {
                try {
                    if (!isRunning) return;
                    
                    showLoading();
                    statusElement.textContent = "Actualisation des prix...";
                    
                    const response = await fetch('https://fapi.binance.com/fapi/v1/ticker/price');
                    if (!response.ok) throw new Error('Erreur réseau');
                    
                    const data = await response.json();
                    
                    prices = {};
                    data.forEach(item => {
                        if (STABLE_COINS.some(coin => item.symbol.endsWith(coin))) {
                            prices[item.symbol] = parseFloat(item.price);
                        }
                    });
                    
                    // Mettre à jour l'heure de dernière actualisation
                    const now = new Date();
                    lastUpdateElement.textContent = `Dernière actualisation: ${now.toLocaleTimeString()}`;
                    
                    return prices;
                } catch (error) {
                    console.error('Erreur:', error);
                    statusElement.textContent = `Erreur: ${error.message}`;
                    
                    // Générer des prix aléatoires pour la démo
                    if (allSymbols.length > 0) {
                        allSymbols.forEach(sym => {
                            const basePrice = getBasePriceForSymbol(sym);
                            // Variation aléatoire de ±0.5%
                            prices[sym] = basePrice * (1 + (Math.random() * 0.01 - 0.005));
                        });
                        statusElement.textContent = "Mode démo: prix simulés";
                    }
                    
                    return prices;
                } finally {
                    hideLoading();
                }
            }
            
            // Prix de base pour la démo
            function getBasePriceForSymbol(symbol) {
                if (symbol.startsWith('BTC')) return 30000 + Math.random() * 5000;
                if (symbol.startsWith('ETH')) return 1800 + Math.random() * 300;
                if (symbol.startsWith('BNB')) return 240 + Math.random() * 20;
                if (symbol.startsWith('SOL')) return 20 + Math.random() * 5;
                if (symbol.startsWith('XRP')) return 0.5 + Math.random() * 0.2;
                if (symbol.startsWith('ADA')) return 0.3 + Math.random() * 0.1;
                if (symbol === 'USDCUSDT') return 1.0;
                return 1 + (Math.random() * 0.01 - 0.005);
            }
            
            // Démarrer la surveillance
            async function startMonitoring() {
                if (isRunning) return;
                
                isRunning = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
                await fetchAllSymbols();
                await fetchPrices();
                findArbitrageOpportunities();
                
                // Configurer l'actualisation automatique
                refreshInterval = setInterval(async () => {
                    await fetchPrices();
                    findArbitrageOpportunities();
                }, REFRESH_INTERVAL);
                
                statusElement.textContent = "Surveillance active - Actualisation toutes les 10 secondes";
            }
            
            // Arrêter la surveillance
            function stopMonitoring() {
                isRunning = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                
                if (refreshInterval) {
                    clearInterval(refreshInterval);
                    refreshInterval = null;
                }
                
                statusElement.textContent = "Surveillance arrêtée";
            }
            
            // Trouver les opportunités d'arbitrage
            function findArbitrageOpportunities() {
                if (!isRunning) return;
                
                const minProfit = parseFloat(minProfitInput.value) || 0.1;
                opportunitiesBody.innerHTML = '';
                
                let opportunitiesFound = 0;
                
                // 1. Arbitrage triangulaire standard (A/USDT → A/B → B/USDT)
                STABLE_COINS.forEach(baseCoin => {
                    const basePairs = allSymbols.filter(s => s.endsWith(baseCoin));
                    
                    basePairs.forEach(pair1 => {
                        const coinA = pair1.replace(baseCoin, '');
                        const coinAPairs = allSymbols.filter(s => s.startsWith(coinA) && s !== pair1);
                        
                        coinAPairs.forEach(pair2 => {
                            const coinB = pair2.replace(coinA, '');
                            const pair3 = coinB + baseCoin;
                            
                            if (allSymbols.includes(pair3)) {
                                const opportunity = calculateTriangleOpportunity(pair1, pair2, pair3, baseCoin);
                                if (opportunity && Math.abs(opportunity.profitAfterFees) >= minProfit) {
                                    addOpportunityToTable(opportunity);
                                    opportunitiesFound++;
                                }
                            }
                        });
                    });
                });
                
                // 2. Arbitrage entre USDT et USDC pour la même crypto
                if (allSymbols.some(s => s.endsWith('USDT')) && allSymbols.some(s => s.endsWith('USDC'))) {
                    const usdtPairs = allSymbols.filter(s => s.endsWith('USDT'));
                    
                    usdtPairs.forEach(usdtPair => {
                        const coin = usdtPair.replace('USDT', '');
                        const usdcPair = coin + 'USDC';
                        
                        if (allSymbols.includes(usdcPair)) {
                            // Vérifier si la paire USDC/USDT existe
                            const exchangePair1 = 'USDCUSDT';
                            const exchangePair2 = 'USDTUSDC';
                            
                            if (allSymbols.includes(exchangePair1)) {
                                const opportunity = calculateStablecoinOpportunity(usdtPair, usdcPair, exchangePair1, 'USDT');
                                if (opportunity && Math.abs(opportunity.profitAfterFees) >= minProfit) {
                                    addOpportunityToTable(opportunity);
                                    opportunitiesFound++;
                                }
                            }
                            
                            if (allSymbols.includes(exchangePair2)) {
                                const opportunity = calculateStablecoinOpportunity(usdtPair, usdcPair, exchangePair2, 'USDT');
                                if (opportunity && Math.abs(opportunity.profitAfterFees) >= minProfit) {
                                    addOpportunityToTable(opportunity);
                                    opportunitiesFound++;
                                }
                            }
                        }
                    });
                }
                
                if (opportunitiesFound === 0) {
                    opportunitiesBody.innerHTML = `
                        <tr>
                            <td colspan="5" style="text-align: center;">
                                Aucune opportunité trouvée avec profit ≥ ${minProfit}%<br>
                                <small>Essayez de réduire le profit minimum ou attendez la prochaine actualisation</small>
                            </td>
                        </tr>
                    `;
                }
            }
            
            // Calculer une opportunité triangulaire
            function calculateTriangleOpportunity(pair1, pair2, pair3, baseCoin) {
                if (!prices[pair1] || !prices[pair2] || !prices[pair3]) return null;
                
                const coinA = pair1.replace(baseCoin, '');
                const coinB = pair2.replace(coinA, '');
                
                // Calcul du profit théorique
                const theoreticalFinalAmount = (1 / prices[pair1]) * (1 / prices[pair2]) * prices[pair3];
                const profitPercentage = (theoreticalFinalAmount - 1) * 100;
                
                // Application des frais (3 trades)
                const feeFactor = Math.pow(1 - TRADING_FEE, 3);
                const profitAfterFees = (theoreticalFinalAmount * feeFactor - 1) * 100;
                
                return {
                    triangle: `${pair1} → ${pair2} → ${pair3}`,
                    pathDescription: `
                        1. Vendre ${baseCoin} pour ${coinA} @ ${prices[pair1].toFixed(8)} (${pair1})<br>
                        2. Vendre ${coinA} pour ${coinB} @ ${prices[pair2].toFixed(8)} (${pair2})<br>
                        3. Vendre ${coinB} pour ${baseCoin} @ ${prices[pair3].toFixed(8)} (${pair3})
                    `,
                    spread: profitPercentage,
                    profitAfterFees: profitAfterFees,
                    action: profitAfterFees > 0 ? 'ACHETER' : 'VENDRE'
                };
            }
            
            // Calculer une opportunité entre stablecoins
            function calculateStablecoinOpportunity(usdtPair, usdcPair, exchangePair, baseCoin) {
                if (!prices[usdtPair] || !prices[usdcPair] || !prices[exchangePair]) return null;
                
                const coin = usdtPair.replace('USDT', '');
                let theoreticalFinalAmount, pathDescription;
                
                if (exchangePair === 'USDCUSDT') {
                    // USDT → Crypto → USDC → USDT
                    theoreticalFinalAmount = (1 / prices[usdtPair]) * prices[usdcPair] * prices[exchangePair];
                    pathDescription = `
                        1. Vendre USDT pour ${coin} @ ${prices[usdtPair].toFixed(8)} (${usdtPair})<br>
                        2. Vendre ${coin} pour USDC @ ${prices[usdcPair].toFixed(8)} (${usdcPair})<br>
                        3. Vendre USDC pour USDT @ ${prices[exchangePair].toFixed(8)} (${exchangePair})
                    `;
                } else {
                    // USDT → USDC → Crypto → USDT
                    theoreticalFinalAmount = (1 / prices[exchangePair]) * (1 / prices[usdcPair]) * prices[usdtPair];
                    pathDescription = `
                        1. Vendre USDT pour USDC @ ${(1/prices[exchangePair]).toFixed(8)} (${exchangePair})<br>
                        2. Vendre USDC pour ${coin} @ ${(1/prices[usdcPair]).toFixed(8)} (${usdcPair})<br>
                        3. Vendre ${coin} pour USDT @ ${prices[usdtPair].toFixed(8)} (${usdtPair})
                    `;
                }
                
                const profitPercentage = (theoreticalFinalAmount - 1) * 100;
                const feeFactor = Math.pow(1 - TRADING_FEE, 3);
                const profitAfterFees = (theoreticalFinalAmount * feeFactor - 1) * 100;
                
                return {
                    triangle: `${usdtPair} ⇄ ${usdcPair}`,
                    pathDescription: pathDescription,
                    spread: profitPercentage,
                    profitAfterFees: profitAfterFees,
                    action: profitAfterFees > 0 ? 'ACHETER' : 'VENDRE'
                };
            }
            
            // Ajouter une opportunité au tableau
            function addOpportunityToTable(opportunity) {
                const row = document.createElement('tr');
                
                const triangleCell = document.createElement('td');
                triangleCell.textContent = opportunity.triangle;
                
                const detailsCell = document.createElement('td');
                detailsCell.innerHTML = opportunity.pathDescription;
                
                const spreadCell = document.createElement('td');
                spreadCell.textContent = opportunity.spread.toFixed(4) + '%';
                spreadCell.className = opportunity.spread > 0 ? 'profit' : 'loss';
                
                const profitCell = document.createElement('td');
                profitCell.textContent = opportunity.profitAfterFees.toFixed(4) + '%';
                profitCell.className = opportunity.profitAfterFees > 0 ? 'profit' : 'loss';
                
                const actionCell = document.createElement('td');
                actionCell.textContent = opportunity.action;
                actionCell.className = opportunity.profitAfterFees > 0 ? 'profit' : 'loss';
                actionCell.style.fontWeight = 'bold';
                
                row.appendChild(triangleCell);
                row.appendChild(detailsCell);
                row.appendChild(spreadCell);
                row.appendChild(profitCell);
                row.appendChild(actionCell);
                
                opportunitiesBody.appendChild(row);
            }
            
            // Afficher le chargement
            function showLoading() {
                loadingElement.style.display = 'block';
            }
            
            // Cacher le chargement
            function hideLoading() {
                loadingElement.style.display = 'none';
            }
            
            // Événements
            startBtn.addEventListener('click', startMonitoring);
            stopBtn.addEventListener('click', stopMonitoring);
            
            // Arrêter proprement si la page se ferme
            window.addEventListener('beforeunload', () => {
                stopMonitoring();
            });
        });
    </script>
</body>
</html>