<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liquidations Binance - Alerte Ultra-Pr√©cise</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #0e1621;
  color: #e3eaf2;
  margin: 0;
  padding: 20px;
}
.container {
  max-width: 1200px;
  margin: 0 auto;
  background: #17212b;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}
h1 {
  color: #64b5f6;
  text-align: center;
  margin-bottom: 20px;
}
.alert-banner {
  background: #1f2d3b;
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 15px;
  font-weight: bold;
  border-left: 4px solid #64b5f6;
  line-height: 1.5em;
  white-space: pre-line;
}
.alert-short {
  border-left-color: #ff5252;
}
.alert-long {
  border-left-color: #4caf50;
}
select, input {
  width: 100%;
  padding: 12px;
  background: #2b3a4a;
  color: white;
  border: 1px solid #3d4f62;
  border-radius: 6px;
  font-size: 16px;
  margin-bottom: 20px;
}
.chart-container {
  background: #1f2d3b;
  padding: 15px;
  border-radius: 10px;
  margin-bottom: 20px;
  border-left: 4px solid #64b5f6;
  height: 500px;
}
canvas {
  width: 100% !important;
  height: 100% !important;
}
.price-info {
  background: #252b3b;
  padding: 15px;
  border-radius: 8px;
  margin-top: 15px;
}
.red { color: #ff5252; font-weight: bold; }
.green { color: #4caf50; font-weight: bold; }
.highlight {
  background: #3a4466;
  padding: 2px 6px;
  border-radius: 4px;
}
.loading {
  color: #64b5f6;
  text-align: center;
  padding: 20px;
  font-style: italic;
}
.accuracy-indicator {
  font-size: 12px;
  color: #aaa;
  margin-top: 5px;
}
.real-liquidations {
  margin-top: 10px;
  font-size: 14px;
  color: #888;
}
</style>
</head>
<body>
<div class="container">
  <h1>üî• Liquidations Binance - Version Ultra-Pr√©cise</h1>
  <div id="shortAlert" class="alert-banner alert-short" style="display: none;"></div>
  <div id="longAlert" class="alert-banner alert-long" style="display: none;"></div>
  <select id="cryptoSelect">
    <option value="">Chargement des cryptos...</option>
  </select>
  <input type="text" id="dateTimeInput" placeholder="Entrez une date et heure (format: JJ/MM/AAAA HH:MM)">
  <div class="chart-container">
    <canvas id="priceChart"></canvas>
  </div>
  <div class="price-info" id="priceInfo">
    S√©lectionnez une cryptomonnaie pour voir les donn√©es d√©taill√©es.
  </div>
</div>
<script>
let priceChart = null;
let allSymbols = [];
let shortAlerts = [];
let longAlerts = [];
let realLiquidations = {};
const SETTINGS = {
  MAX_DISTANCE: 1,
  MIN_CONFIDENCE: 0,
  SHORT_BUFFER: 0.98,
  LONG_BUFFER: 1.02,
  VOLATILITY_WINDOW: 14,
  USE_SMOOTHING: true
};
document.addEventListener('DOMContentLoaded', () => {
  loadAllSymbols();
  setupEventListeners();
  setInterval(() => checkAllLiquidations(), 10 * 60 * 1000);
});
function setupEventListeners() {
  document.getElementById('cryptoSelect').addEventListener('change', loadChart);
  document.getElementById('dateTimeInput').addEventListener('change', loadChart);
}
async function loadAllSymbols() {
  try {
    const [exchangeInfo, liquidations] = await Promise.all([
      axios.get('https://fapi.binance.com/fapi/v1/exchangeInfo'),
      fetchRealLiquidations()
    ]);
    allSymbols = exchangeInfo.data.symbols
      .filter(s => s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT')
      .map(s => s.symbol)
      .sort();
    realLiquidations = processRealLiquidations(liquidations);
    updateSelect();
    await checkAllLiquidations();
    if (allSymbols.length > 0) {
      document.getElementById('cryptoSelect').value = allSymbols[0];
      loadChart();
    }
  } catch (e) {
    console.error("Erreur de chargement:", e);
  }
}
async function fetchRealLiquidations() {
  try {
    const response = await axios.get('https://fapi.binance.com/fapi/v1/allForceOrders?limit=1000');
    return response.data;
  } catch (e) {
    console.warn("Impossible de r√©cup√©rer les liquidations r√©elles, utilisation des estimations");
    return [];
  }
}
function processRealLiquidations(liquidations) {
  const result = {};
  liquidations.forEach(liq => {
    if (!result[liq.symbol]) {
      result[liq.symbol] = { shorts: [], longs: [] };
    }
    if (liq.side === 'SELL') {
      result[liq.symbol].shorts.push({
        price: parseFloat(liq.price),
        time: new Date(liq.time),
        quantity: parseFloat(liq.executedQty)
      });
    } else {
      result[liq.symbol].longs.push({
        price: parseFloat(liq.price),
        time: new Date(liq.time),
        quantity: parseFloat(liq.executedQty)
      });
    }
  });
  return result;
}
async function checkAllLiquidations(endTime = null) {
  shortAlerts = [];
  longAlerts = [];
  const toCheck = allSymbols.slice(0, 100);
  const tasks = toCheck.map(async (symbol) => {
    try {
      const [priceData, liqData] = await Promise.all([
        fetchPriceData(symbol, endTime),
        fetchLiquidationData(symbol)
      ]);
      const lastPrice = priceData[priceData.length - 1].close;
      const zones = calculateLiquidationZones(symbol, priceData, liqData);
      const confidence = calculateConfidenceScore(priceData, liqData);
      const distanceShort = Math.abs(((zones.short - lastPrice) / lastPrice) * 100);
      const distanceLong = Math.abs(((lastPrice - zones.long) / lastPrice) * 100);
      if (distanceShort >= 0 && distanceShort < SETTINGS.MAX_DISTANCE) {
        shortAlerts.push(createAlertData(symbol, lastPrice, zones.short, distanceShort, confidence.short, 'short'));
      }
      if (distanceLong >= 0 && distanceLong < SETTINGS.MAX_DISTANCE) {
        longAlerts.push(createAlertData(symbol, lastPrice, zones.long, distanceLong, confidence.long, 'long'));
      }
    } catch (e) {
      console.warn(`Erreur avec ${symbol}:`, e.message);
    }
  });
  await Promise.all(tasks);
  updateAlertDisplays();
}
function createAlertData(symbol, price, liqPrice, distance, confidence, type) {
  return {
    symbol,
    price: price.toFixed(4),
    liq: liqPrice.toFixed(4),
    dist: distance.toFixed(2),
    confidence,
    type,
    realLiq: realLiquidations[symbol]?.[type === 'short' ? 'shorts' : 'longs'] || []
  };
}
function updateAlertDisplays() {
  const shortBox = document.getElementById('shortAlert');
  const longBox = document.getElementById('longAlert');
  shortAlerts.sort((a, b) => a.dist - b.dist);
  longAlerts.sort((a, b) => a.dist - b.dist);
  if (shortAlerts.length > 0) {
    shortBox.innerHTML = shortAlerts.map(s =>
      `üìâ ${s.symbol} ‚Äî Prix: ${s.price}, Liq: ${s.liq} (Distance: +${s.dist}%)`
    ).join('\n');
    shortBox.style.display = 'block';
  } else {
    shortBox.style.display = 'none';
  }
  if (longAlerts.length > 0) {
    longBox.innerHTML = longAlerts.map(s =>
      `üìà ${s.symbol} ‚Äî Prix: ${s.price}, Liq: ${s.liq} (Distance: -${s.dist}%)`
    ).join('\n');
    longBox.style.display = 'block';
  } else {
    longBox.style.display = 'none';
  }
}
async function fetchPriceData(symbol, endTime) {
  let url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=1h&limit=720`;
  if (endTime) {
    url += `&endTime=${endTime}`;
  }
  const res = await axios.get(url);
  return res.data.map(d => ({
    time: new Date(d[0]),
    open: +d[1], high: +d[2], low: +d[3], close: +d[4],
    volume: +d[5]
  }));
}
async function fetchLiquidationData(symbol) {
  return realLiquidations[symbol] || { shorts: [], longs: [] };
}
function calculateLiquidationZones(symbol, priceData, liqData) {
  if (liqData.shorts.length > 0 || liqData.longs.length > 0) {
    const realShort = liqData.shorts.length > 0 ?
      weightedAverage(liqData.shorts.map(liq => liq.price)) : null;
    const realLong = liqData.longs.length > 0 ?
      weightedAverage(liqData.longs.map(liq => liq.price)) : null;
    const estimated = calculateEstimatedZones(priceData);
    return {
      short: realShort || estimated.short,
      long: realLong || estimated.long,
      isReal: !!realShort || !!realLong
    };
  }
  return calculateEstimatedZones(priceData);
}
function calculateEstimatedZones(priceData) {
  const highs = priceData.map(d => d.high);
  const lows = priceData.map(d => d.low);
  const closes = priceData.map(d => d.close);
  const volatility = calculateVolatility(closes);
  const filteredHighs = filterOutliers(highs);
  const filteredLows = filterOutliers(lows);
  const shortBuffer = SETTINGS.SHORT_BUFFER - (volatility * 0.3);
  const longBuffer = SETTINGS.LONG_BUFFER + (volatility * 0.3);
  return {
    short: weightedAverage(filteredHighs) * shortBuffer,
    long: weightedAverage(filteredLows) * longBuffer
  };
}
function calculateConfidenceScore(priceData, liqData) {
  if (liqData.shorts.length > 0 || liqData.longs.length > 0) {
    const recency = calculateRecencyScore(liqData);
    const quantityScore = Math.min(1, liqData.shorts.concat(liqData.longs).reduce((sum, liq) => sum + liq.quantity, 0) / 1000);
    return {
      short: liqData.shorts.length > 0 ? 0.8 + (0.2 * recency) + (0.1 * quantityScore) : 0.5,
      long: liqData.longs.length > 0 ? 0.8 + (0.2 * recency) + (0.1 * quantityScore) : 0.5
    };
  }
  const volatility = calculateVolatility(priceData.map(d => d.close));
  const volumeScore = Math.min(1, priceData.reduce((sum, d) => sum + d.volume, 0) / 100000);
  return {
    short: Math.min(1, 0.7 - (volatility * 2) + (volumeScore * 0.3)),
    long: Math.min(1, 0.7 - (volatility * 2) + (volumeScore * 0.3))
  };
}
function calculateRecencyScore(liqData) {
  const now = Date.now();
  const lastShort = liqData.shorts.length > 0 ? Math.max(...liqData.shorts.map(liq => liq.time.getTime())) : 0;
  const lastLong = liqData.longs.length > 0 ? Math.max(...liqData.longs.map(liq => liq.time.getTime())) : 0;
  const shortRecency = lastShort > 0 ? Math.max(0, 1 - (now - lastShort) / (24 * 60 * 60 * 1000)) : 0;
  const longRecency = lastLong > 0 ? Math.max(0, 1 - (now - lastLong) / (24 * 60 * 60 * 1000)) : 0;
  return Math.max(shortRecency, longRecency);
}
function calculateVolatility(prices) {
  if (prices.length < 2) return 0;
  const returns = [];
  for (let i = 1; i < prices.length; i++) {
    returns.push(Math.log(prices[i] / prices[i-1]));
  }
  const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
  const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
  return Math.sqrt(variance) * Math.sqrt(365);
}
function filterOutliers(values) {
  if (values.length < 3) return values;
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const stdDev = Math.sqrt(values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length);
  return values.filter(v => Math.abs(v - mean) <= stdDev * 1.5);
}
function weightedAverage(values, weights) {
  if (!weights) {
    weights = [];
    const totalWeights = values.length * (values.length + 1) / 2;
    for (let i = 0; i < values.length; i++) {
      weights.push((i + 1) / totalWeights);
    }
  }
  return values.reduce((a, v, i) => a + v * weights[i], 0);
}
function updateSelect() {
  const select = document.getElementById('cryptoSelect');
  select.innerHTML = allSymbols.map(s => `<option value="${s}">${s}</option>`).join('');
}
async function loadChart() {
  const symbol = document.getElementById('cryptoSelect').value;
  const dateTimeInput = document.getElementById('dateTimeInput').value;
  let endTime = null;
  if (dateTimeInput) {
    const [datePart, timePart] = dateTimeInput.split(' ');
    const [day, month, year] = datePart.split('/').map(Number);
    const [hours, minutes] = timePart.split(':').map(Number);
    const date = new Date(year, month - 1, day, hours, minutes);
    endTime = date.getTime();
  }
  if (!symbol) return;
  document.getElementById('priceInfo').innerHTML = `<div class="loading">Chargement des donn√©es pour ${symbol}...</div>`;
  try {
    const [priceData, liqData] = await Promise.all([
      fetchPriceData(symbol, endTime),
      fetchLiquidationData(symbol)
    ]);
    const zones = calculateLiquidationZones(symbol, priceData, liqData);
    updateChart(symbol, priceData, zones);
    updateInfo(symbol, priceData, zones);
    await checkAllLiquidations(endTime);
  } catch (e) {
    document.getElementById('priceInfo').innerHTML = `<span class="red">Erreur : ${e.message}</span>`;
  }
}
function updateChart(symbol, data, zones) {
  const ctx = document.getElementById('priceChart').getContext('2d');
  if (priceChart) priceChart.destroy();
  const annotations = {
    shortLine: {
      type: 'line',
      yMin: zones.short,
      yMax: zones.short,
      borderColor: '#ff5252',
      borderWidth: 2,
      borderDash: [5, 5],
      label: {
        content: `Short ~${zones.short.toFixed(2)}`,
        display: true,
        backgroundColor: 'rgba(255,82,82,0.7)'
      }
    },
    longLine: {
      type: 'line',
      yMin: zones.long,
      yMax: zones.long,
      borderColor: '#4caf50',
      borderWidth: 2,
      borderDash: [5, 5],
      label: {
        content: `Long ~${zones.long.toFixed(2)}`,
        display: true,
        backgroundColor: 'rgba(76,175,80,0.7)'
      }
    }
  };
  priceChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.map(d => d.time.toLocaleString('fr-BE')),
      datasets: [{
        label: `${symbol} Prix`,
        data: data.map(d => d.close),
        borderColor: '#64b5f6',
        tension: 0.1,
        pointRadius: 0,
        borderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        annotation: { annotations }
      },
      scales: {
        x: {
          grid: { color: '#2b3a4a' },
          ticks: {
            autoSkip: false,
            maxRotation: 90,
            minRotation: 90
          }
        },
        y: { grid: { color: '#2b3a4a' } }
      }
    }
  });
}
function updateInfo(symbol, data, zones) {
  const last = data[data.length - 1].close;
  const distShort = Math.abs(((zones.short - last) / last * 100)).toFixed(2);
  const distLong = Math.abs(((last - zones.long) / last * 100)).toFixed(2);
  const confidence = calculateConfidenceScore(data, realLiquidations[symbol] || { shorts: [], longs: [] });
  document.getElementById('priceInfo').innerHTML = `
    <strong>${symbol}</strong> ‚Äî Dernier prix: <span class="highlight">${last.toFixed(4)}</span>
    <br>
    <span class="red">üìâ Liquidation Short: ${zones.short.toFixed(4)}</span><br>
    Distance: <span class="red">+${distShort}%</span><br><br>
    <span class="green">üìà Liquidation Long: ${zones.long.toFixed(4)}</span><br>
    Distance: <span class="green">-${distLong}%</span>
  `;
}
</script>
</body>
</html>
