<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Historique Binance - Variation sur 2 dernières années</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 20px; }
th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
th { background-color: #eee; }
#progressContainer {
width: 100%;
background-color: #ddd;
border-radius: 8px;
overflow: hidden;
margin-bottom: 10px;
}
#progressBar {
height: 20px;
width: 0%;
background-color: #4caf50;
text-align: center;
color: white;
font-size: 12px;
line-height: 20px;
transition: width 0.3s ease;
}
.cardsContainer {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
gap: 15px;
margin-top: 20px;
}
.card {
border: 1px solid #ccc;
padding: 10px;
border-radius: 8px;
background: #fafafa;
min-height: 60px;
display: flex;
flex-direction: column;
}
.card h3 {
margin-bottom: 8px;
border-bottom: 1px solid #ddd;
padding-bottom: 6px;
font-size: 14px;
}
.card.green div.item { color: green; margin-bottom: 4px; word-wrap: break-word; }
.card.red div.item { color: red; margin-bottom: 4px; word-wrap: break-word; }
.card .count {
margin-top: auto;
margin-top: 10px;
font-size: 13px;
color: blue;
font-weight: bold;
}
/* Card spéciale en bleu */
.card.blue {
border-color: #007bff;
background: #e6f0ff;
color: #004a99;
}
.card.blue h3 {
border-color: #004a99;
}
.card.blue div.item {
color: #004a99;
margin-bottom: 4px;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
</style>
</head>
<body>

<h2>Variation sur les 2 dernières années disponibles</h2>

<div id="progressContainer">
<div id="progressBar">0%</div>
</div>

<div class="cardsContainer" id="cardsContainer">
<!-- Card spéciale en haut sera insérée ici -->
</div>

<table>
<thead>
<tr>
<th>Crypto</th>
<th>Années comparées</th>
<th>Taux de variation (%)</th>
<th>Clôture décembre</th>
</tr>
</thead>
<tbody id="cryptoTableBody"></tbody>
</table>

<script>
// Génère automatiquement les ranges pour -10/-18 à -490/-498 verts et 10/18 à 490/498 rouges
const variationRanges = [];

// Fonction pour ajouter tranches en pas de 10, largeur 8, ex: -10/-18, -20/-28, ...
function addRanges(minStart, maxStart, step, count, color, negative = false) {
for(let i=0; i<count; i++) {
const min = negative ? -(minStart + i*step) : (minStart + i*step);
const max = negative ? -(maxStart + i*step) : (maxStart + i*step);
variationRanges.push({ min, max, color });
}
}

// Ajouter les verts négatifs -10/-18 à -490/-498
addRanges(10, 18, 10, 49, "green", true);

// Ajouter les rouges positifs 10/18 à 490/498
addRanges(10, 18, 10, 49, "red", false);

// Condition spéciale exacte 10000% en rouge
variationRanges.push({ exact: 10000, color: "red" });

let alerts = {};

function capitalize(str) {
return str.charAt(0).toUpperCase() + str.slice(1);
}

// Crée toutes les cartes sauf la spéciale
function createCards() {
const container = document.getElementById("cardsContainer");
variationRanges.forEach(range => {
const key = range.exact != null
? `exact_${range.exact}`
: `range_${range.min}_${range.max}`;
alerts[key] = [];
const title = range.exact != null
? `Variations = ${range.exact}% (${capitalize(range.color)})`
: `Variations entre ${range.min}% et ${range.max}% (${capitalize(range.color)})`;
const card = document.createElement("div");
card.className = `card ${range.color}`;
card.id = `card_${key}`;
card.innerHTML = `<h3>${title}</h3>`;
container.appendChild(card);
});
}

// Crée la carte spéciale bleue en haut avec tranches ayant exactement 4 cryptos
function createSpecialCard(rangesWith4Cryptos) {
const container = document.getElementById("cardsContainer");
const card = document.createElement("div");
card.className = "card blue";
card.id = "card_special";

let content = '<h3>Tranches avec exactement 4 cryptos</h3>';
if (rangesWith4Cryptos.length === 0) {
content += '<div class="item">Aucune tranche avec exactement 4 cryptos.</div>';
} else {
rangesWith4Cryptos.forEach(range => {
const title = range.exact != null
? `Variations = ${range.exact}% (${capitalize(range.color)})`
: `Variations entre ${range.min}% et ${range.max}% (${capitalize(range.color)})`;
content += `<div class="item">${title}</div>`;
});
}

card.innerHTML = content;
container.prepend(card); // Ajout en premier dans container
}

async function fetchUsdtSymbols() {
const resp = await fetch('https://api.binance.com/api/v3/exchangeInfo');
const data = await resp.json();
return data.symbols
.filter(s => s.status === 'TRADING' && s.symbol.endsWith('USDT') && s.isSpotTradingAllowed)
.map(s => s.symbol);
}

async function fetchMonthlyKlines(symbol) {
const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1M&limit=1000`;
const resp = await fetch(url);
return resp.json();
}

function updateProgress(current, total) {
const progressBar = document.getElementById('progressBar');
const percent = Math.round((current / total) * 100);
progressBar.style.width = percent + '%';
progressBar.textContent = percent + '%';
}

function fmtPrice(p) {
if (p == null || !isFinite(p)) return '-';
return parseFloat(p.toFixed(8)).toString();
}

function matchRange(variation) {
for (const range of variationRanges) {
if (range.exact != null) {
if (variation >= range.exact) return range;
} else {
if (range.color === "green") {
if (variation <= range.min && variation >= range.max) return range;
} else {
if (variation >= range.min && variation <= range.max) return range;
}
}
}
return null;
}

async function main() {
createCards();
const tbody = document.getElementById('cryptoTableBody');
let symbols = await fetchUsdtSymbols();
symbols.sort();
const total = symbols.length;
let processed = 0;

for (const symbol of symbols) {
try {
const klines = await fetchMonthlyKlines(symbol);
const closeDecByYear = {};
for (const k of klines) {
const [openTime, , , , close] = k;
const date = new Date(openTime);
if (date.getMonth() === 11) {
closeDecByYear[date.getFullYear()] = parseFloat(close);
}
}
const years = Object.keys(closeDecByYear).map(Number).sort((a,b)=>a-b);
if (years.length < 2) {
processed++;
updateProgress(processed, total);
continue;
}

const yearPrev = years[years.length - 2];
const yearCurrent = years[years.length - 1];
const closePrev = closeDecByYear[yearPrev];
const closeCurrent = closeDecByYear[yearCurrent];

if (!closePrev || !closeCurrent) {
processed++;
updateProgress(processed, total);
continue;
}

const variation = ((closeCurrent - closePrev) / closePrev) * 100;
const variationFixed = variation.toFixed(2);
const range = matchRange(variation);
let color = 'inherit';
if (range) {
color = range.color;
const key = range.exact != null
? `exact_${range.exact}`
: `range_${range.min}_${range.max}`;
alerts[key].push({ symbol, from: yearPrev, to: yearCurrent, variation });
}

tbody.insertAdjacentHTML('beforeend', `
<tr>
<td>${symbol}</td>
<td>${yearPrev} → ${yearCurrent}</td>
<td style="color:${color}">${variationFixed}%</td>
<td>${fmtPrice(closeCurrent)}</td>
</tr>
`);
} catch (e) {
tbody.insertAdjacentHTML('beforeend', `<tr><td>${symbol}</td><td colspan="3" style="color:red;">Erreur: ${e.message}</td></tr>`);
}
processed++;
updateProgress(processed, total);
}

// Création de la carte spéciale avant les autres
// On filtre les tranches avec exactement 4 cryptos
const rangesWith4Cryptos = [];
for (const key in alerts) {
if (alerts[key].length === 4) {
// Trouver l'objet range correspondant
let r = null;
if (key.startsWith('exact_')) {
const val = Number(key.split('_')[1]);
r = variationRanges.find(v => v.exact === val);
} else {
const parts = key.split('_');
const min = Number(parts[1]);
const max = Number(parts[2]);
r = variationRanges.find(v => v.min === min && v.max === max);
}
if (r) {
rangesWith4Cryptos.push(r);
}
}
}
createSpecialCard(rangesWith4Cryptos);

// Remplissage des cartes + compteur en bas
for (const key in alerts) {
const card = document.getElementById(`card_${key}`);
if (alerts[key].length === 0) {
card.insertAdjacentHTML('beforeend', '<div>Aucune correspondance.</div>');
} else {
alerts[key].sort((a,b)=>a.variation - b.variation)
.forEach(a => {
card.insertAdjacentHTML('beforeend', `<div class="item">${a.symbol} : ${a.variation.toFixed(2)}% (${a.from} → ${a.to})</div>`);
});
card.insertAdjacentHTML('beforeend', `<div class="count">Il y a ${alerts[key].length} cryptos.</div>`);
}
}
}

main();
</script>

</body>
</html>