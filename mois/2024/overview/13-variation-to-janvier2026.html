<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Multi-dates — 1M (Janvier 2025 & 2026)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#94a3b8;
      --up:#16a34a; --down:#dc2626; --zero:#64748b; --border:#1f2937; --header:#0b1220; --accent:#2563eb;
      --total:#facc15;
    }
    *{box-sizing:border-box}
    body{margin:0;background:#0b1020;color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;padding:24px}
    header{max-width:1200px;margin:0 auto 16px;display:flex;gap:12px;align-items:baseline;flex-wrap:wrap}
    header h1{margin:0;font-size:20px;font-weight:700}
    .meta{color:var(--muted);font-size:14px}
    .controls{margin-left:auto;display:flex;gap:12px}
    .controls button{background:var(--accent);border:0;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer;font-family:inherit;font-size:14px}
    .controls button a{color:#fff;text-decoration:none}

    .summary-cards{max-width:1200px;margin:0 auto 16px;display:flex;flex-direction:column;gap:12px}
    .summary-card{
      padding:12px 16px;border-radius:12px;font-size:14px;
      border:1px solid var(--border);
    }

    #variation_negative{
      background:linear-gradient(180deg,rgba(220,38,38,.1),rgba(220,38,38,.04)), var(--card);
      border-color:rgba(220,38,38,.35);
      color:#fecaca;
    }
    #spike_max{
      background:linear-gradient(180deg,rgba(34,197,94,.1),rgba(34,197,94,.04)), var(--card);
      border-color:rgba(34,197,94,.35);
      color:#dcfce7;
    }
    #spike_min{
      background:linear-gradient(180deg,rgba(59,130,246,.1),rgba(59,130,246,.04)), var(--card);
      border-color:rgba(59,130,246,.35);
      color:#dbeafe;
    }

    .summary-card .title{font-weight:700;margin-bottom:8px}
    #variation_negative .title{color:#fca5a5}
    #spike_max .title{color:#86efac}
    #spike_min .title{color:#93c5fd}

    .total-badges{display:flex;gap:10px;flex-wrap:wrap}
    .total-badges .badge{
      background:#1f2937;border:1px solid var(--border);border-radius:999px;
      padding:4px 10px;color:#fff;font-weight:700
    }
    .total-badges .badge.positive{color:#22c55e}
    .total-badges .badge.negative{color:#ef4444}
    .total-badges .badge.zero{color:#94a3b8}

    /* ✅ RÈGLES UNIQUEMENT SUR TOTALS (pas sur les cellules des tableaux) */
    .total-badges .badge.rule-up{
      border-color:rgba(34,197,94,.45);
      box-shadow:0 0 0 2px rgba(34,197,94,.20) inset;
    }
    .total-badges .badge.rule-down{
      border-color:rgba(220,38,38,.45);
      box-shadow:0 0 0 2px rgba(220,38,38,.20) inset;
    }
    .total-badges .badge.rule-neutral{
      border-color:rgba(148,163,184,.45);
      box-shadow:0 0 0 2px rgba(148,163,184,.15) inset;
    }

    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(520px,1fr));gap:16px;max-width:1200px;margin:0 auto}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),transparent),var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden}
    .card header{background:var(--header);border-bottom:1px solid var(--border);padding:10px 12px;display:flex;gap:10px;align-items:center}
    .symbol{font-weight:700;letter-spacing:.3px}
    .status{margin-left:auto;font-size:12px;color:var(--muted)}
    .table-wrap{max-height:70vh;overflow:auto}
    table{width:100%;border-collapse:separate;border-spacing:0;font-variant-numeric:tabular-nums}
    thead th{position:sticky;top:0;background:var(--header);border-bottom:1px solid var(--border);padding:6px 8px;font-size:12px;color:var(--muted);text-align:left}
    thead th.num, tbody td.pct{text-align:right}
    tbody td, tbody th{border-bottom:1px solid rgba(255,255,255,.06);padding:6px 8px;font-size:12px}
    tbody td.time{color:var(--muted)}
    .pct{font-weight:600}
    .up{color:var(--up)} .down{color:var(--down)} .zero{color:var(--zero)}
    .loading,.error{padding:10px 12px;border-top:1px solid var(--border);font-size:13px;color:var(--muted)}
    .error{color:#fca5a5}
    .chip{font-size:11px;font-weight:700;padding:2px 6px;border-radius:6px;border:1px solid var(--border);color:#94a3b8;margin-left:8px}
    .info-banner{max-width:1200px;margin:0 auto 16px;padding:12px;background:rgba(59,130,246,0.1);border:1px solid rgba(59,130,246,0.3);border-radius:8px;color:#93c5fd;font-size:14px;}
  </style>
</head>
<body>
  <header>
    <h1>Variation 1M — Janvier 2025 & 2026 <span class="chip">Filtre basé sur janvier 2025</span></h1>
    <div class="meta" id="metaLine"></div>
    <div class="controls"><button id="reload"><a href="/index.html">Accueil</a></button></div>
  </header>

  <div class="info-banner">
    ⚠️ Seules les cryptos dont la variation mensuelle de <strong>janvier 2025</strong> est ≥ +50% ou ≤ −50% sont affichées.
    Les valeurs de <strong>janvier 2026</strong> sont montrées uniquement pour ces mêmes cryptos.
  </div>

  <div class="summary-cards">
    <div id="spike_max" class="summary-card">
      <span class="title">TOTAL Spike max (mèche ↑) :</span>
      <div id="total_spike_max" class="total-badges"></div>
    </div>

    <div id="spike_min" class="summary-card">
      <span class="title">TOTAL Spike min (mèche ↓) :</span>
      <div id="total_spike_min" class="total-badges"></div>
    </div>

    <div id="variation_negative" class="summary-card">
      <span class="title">TOTAL (somme des variations, cryptos filtrées sur janvier&nbsp;2025 ≥ +50% ou ≤ −50%) :</span>
      <div id="total_variation" class="total-badges"></div>
    </div>
  </div>

  <div id="grid" class="grid"></div>

<script>
(async () => {
  // --- Utils ---
  function fmtPct(p){ return (p >= 0 ? '+' : '') + p.toFixed(3) + '%'; }
  function clsPct(p){ return 'pct ' + (p > 0 ? 'up' : (p < 0 ? 'down' : 'zero')); }
  function pad(n){ return String(n).padStart(2,'0'); }

  function pctChange(open, close) {
    const o = Number(open), c = Number(close);
    if (!isFinite(o) || o === 0 || !isFinite(c)) return null;
    return ((c - o) / o) * 100;
  }

  function spikeMaxPct(open, high) {
    const o = Number(open), h = Number(high);
    if (!isFinite(o) || o === 0 || !isFinite(h)) return null;
    return ((h - o) / o) * 100;
  }

  function spikeMinPct(open, low) {
    const o = Number(open), l = Number(low);
    if (!isFinite(o) || o === 0 || !isFinite(l)) return null;
    return ((l - o) / o) * 100;
  }

  // --- Paramètres globaux ---
  const allowedSymbols = [
    "ACXUSDT","AEROUSDT","AIXBTUSDT","AVAUSDT","CGPTUSDT","DEGOUSDT","DEXEUSDT","DFUSDT",
    "FARTCOINUSDT","HIVEUSDT","KAIAUSDT","KMNOUSDT","KOMAUSDT","LUMIAUSDT","MEUSDT","MOCAUSDT",
    "MOVEUSDT","ORCAUSDT","PENGUUSDT","PHAUSDT","RAYSOLUSDT","SPXUSDT","USUALUSDT","VANAUSDT",
    "VELODROMEUSDT","VIRTUALUSDT"
  ];
  const symbols = allowedSymbols.slice();

  const periods = [
    {
      key: "2025-01",
      label: "Janvier 2025",
      startUtc: Date.UTC(2025, 0, 1, 0, 0, 0, 0),
      endUtc:   Date.UTC(2025, 1, 1, 0, 0, 0, 0) - 1
    },
    {
      key: "2026-01",
      label: "Janvier 2026",
      startUtc: Date.UTC(2026, 0, 1, 0, 0, 0, 0),
      endUtc:   Date.UTC(2026, 1, 1, 0, 0, 0, 0) - 1
    }
  ];

  const VAR_THRESHOLD = 50;
  const FILTER_KEY = "2025-01";

  function totalRuleClass(kind, sum, count){
    if (!count) return 'rule-neutral';
    if (kind === 'var') {
      if (sum >= VAR_THRESHOLD) return 'rule-up';
      if (sum <= -VAR_THRESHOLD) return 'rule-down';
      return 'rule-neutral';
    }
    if (kind === 'su') return (sum >= VAR_THRESHOLD) ? 'rule-up' : 'rule-neutral';
    if (kind === 'sd') return (sum <= -VAR_THRESHOLD) ? 'rule-down' : 'rule-neutral';
    return 'rule-neutral';
  }

  // --- Header dynamique ---
  (function renderHeaderMeta(){
    const meta = document.getElementById('metaLine');
    const start = new Date(periods[0].startUtc);
    const end   = new Date(periods[periods.length-1].endUtc);

    const fmtDate = (d) => `${pad(d.getUTCDate())}/${pad(d.getUTCMonth()+1)}/${d.getUTCFullYear()}`;
    const startLabel = fmtDate(start);
    const endLabel   = fmtDate(end);

    const list = periods.map(p => `<strong>${p.label}</strong>`).join(', ');

    meta.innerHTML =
      `Période globale : <strong>${startLabel}</strong> → <strong>${endLabel}</strong> • ` +
      `Périodes suivies : ${list} • ` +
      `Timeframe Binance : <strong>1M (bougies mensuelles)</strong> • ` +
      `Filtre appliqué uniquement sur <strong>janvier 2025</strong> (Δ ≥ +50% ou Δ ≤ −50%)`;
  })();

  // --- DOM ---
  const grid = document.getElementById('grid');
  const totalsBar = document.getElementById('total_variation');
  const totalsSpikeMaxBar = document.getElementById('total_spike_max');
  const totalsSpikeMinBar = document.getElementById('total_spike_min');

  function buildCard(symbol) {
    const card = document.createElement('div');
    card.className = 'card';

    const head = document.createElement('header');
    const symEl = document.createElement('div');
    symEl.className = 'symbol';
    symEl.textContent = symbol;

    const status = document.createElement('div');
    status.className = 'status';
    status.textContent = 'Chargement…';

    head.appendChild(symEl);
    head.appendChild(status);

    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    thead.innerHTML = `
      <tr>
        <th>Période</th>
        <th class="num">Variation (1M)</th>
        <th class="num">Spike max (mèche ↑)</th>
        <th class="num">Spike min (mèche ↓)</th>
      </tr>`;
    const tbody = document.createElement('tbody');

    for (const p of periods) {
      const tr = document.createElement('tr');

      const tdPeriod = document.createElement('td');
      tdPeriod.className = 'time';
      tdPeriod.textContent = p.label;

      const tdVar = document.createElement('td');
      tdVar.className = 'pct zero';
      tdVar.textContent = '—';
      tdVar.dataset.target = `${p.key}:var`;

      const tdSpikeUp = document.createElement('td');
      tdSpikeUp.className = 'pct zero';
      tdSpikeUp.textContent = '—';
      tdSpikeUp.dataset.target = `${p.key}:su`;

      const tdSpikeDn = document.createElement('td');
      tdSpikeDn.className = 'pct zero';
      tdSpikeDn.textContent = '—';
      tdSpikeDn.dataset.target = `${p.key}:sd`;

      tr.appendChild(tdPeriod);
      tr.appendChild(tdVar);
      tr.appendChild(tdSpikeUp);
      tr.appendChild(tdSpikeDn);
      tbody.appendChild(tr);
    }

    table.appendChild(thead);
    table.appendChild(tbody);
    wrap.appendChild(table);

    const loading = document.createElement('div');
    loading.className = 'loading';
    loading.textContent = 'Requêtes klines 1M (mensuelles)…';

    card.appendChild(head);
    card.appendChild(wrap);
    card.appendChild(loading);
    grid.appendChild(card);

    return { card, statusEl: status, loadingEl: loading, tbody };
  }

  async function fetchKline1M(symbol, startUtc, endUtc) {
    // ⚠️ IMPORTANT : pour avoir *la* bougie mensuelle, on ne se fie PAS à limit=1 sur une plage,
    // on fetch jusqu'à 3 bougies et on prend celle dont openTime est DANS le mois visé.
    async function fetchUrl(base){
      const u = new URL(base);
      u.searchParams.set('symbol', symbol);
      u.searchParams.set('interval', '1M');
      u.searchParams.set('startTime', String(startUtc));
      u.searchParams.set('endTime', String(endUtc));
      u.searchParams.set('limit', '3');
      const r = await fetch(u.toString());
      if (!r.ok) throw new Error(`${base.includes('fapi') ? 'Futures' : 'Spot'} API returned ${r.status}`);
      const j = await r.json();
      if (!Array.isArray(j)) throw new Error('Réponse inattendue.');
      return j;
    }

    let data = null;
    try {
      data = await fetchUrl('https://fapi.binance.com/fapi/v1/klines');
    } catch {
      data = await fetchUrl('https://api.binance.com/api/v3/klines');
    }

    // Trouver la bougie qui commence exactement sur startUtc (openTime === startUtc)
    // Sinon, fallback: première bougie dont openTime est dans [startUtc, endUtc]
    let candle = data.find(k => Number(k[0]) === startUtc);
    if (!candle) candle = data.find(k => Number(k[0]) >= startUtc && Number(k[0]) <= endUtc);
    return candle || null;
  }

  const cards = symbols.map(s => {
    const built = buildCard(s);
    const rowCells = {};
    for (const p of periods) {
      rowCells[`${p.key}:var`] = built.tbody.querySelector(`td[data-target="${p.key}:var"]`);
      rowCells[`${p.key}:su`]  = built.tbody.querySelector(`td[data-target="${p.key}:su"]`);
      rowCells[`${p.key}:sd`]  = built.tbody.querySelector(`td[data-target="${p.key}:sd"]`);
    }
    return { symbol: s, ...built, rowCells };
  });

  const totalsVar = new Map();
  const totalsSpikeMax = new Map();
  const totalsSpikeMin = new Map();
  for (const p of periods) {
    totalsVar.set(p.key, {sum:0, count:0});
    totalsSpikeMax.set(p.key, {sum:0, count:0});
    totalsSpikeMin.set(p.key, {sum:0, count:0});
  }

  await Promise.allSettled(cards.map(async (c) => {
    c.statusEl.textContent = 'Chargement…';
    c.loadingEl.textContent = 'Requêtes klines 1M (mensuelles)…';

    const perPeriodResults = {};

    try {
      for (const p of periods) {
        const candle = await fetchKline1M(c.symbol, p.startUtc, p.endUtc);

        let pVar = null, pSu = null, pSd = null;

        if (candle) {
          const open  = candle[1];
          const high  = candle[2];
          const low   = candle[3];
          const close = candle[4];

          pVar = pctChange(open, close);
          pSu  = spikeMaxPct(open, high);
          pSd  = spikeMinPct(open, low);
        }

        perPeriodResults[p.key] = { pVar, pSu, pSd };
      }

      const base = perPeriodResults[FILTER_KEY];
      const baseVar = base ? base.pVar : null;
      const passesFilter = baseVar !== null && (baseVar >= VAR_THRESHOLD || baseVar <= -VAR_THRESHOLD);

      if (!passesFilter) {
        c.card.style.display = 'none';
        c.statusEl.textContent = 'Filtré (janvier 2025 entre -50% et +50%)';
        c.loadingEl.textContent = 'Aucune variation ≥ +50% ou ≤ −50% en janvier 2025.';
        return;
      }

      // ✅ IMPORTANT : on veut le total spike max/min calculé sur TOUS les filtrés (pas seulement pump/dump)
      // Sinon tu obtiens facilement n/a si tous les filtrés sont en dump (comme tes exemples).
      for (const p of periods) {
        const { pVar, pSu, pSd } = perPeriodResults[p.key];

        const cVar = c.rowCells[`${p.key}:var`];
        const cSu  = c.rowCells[`${p.key}:su`];
        const cSd  = c.rowCells[`${p.key}:sd`];

        if (pVar === null) {
          cVar.textContent = 'n/a';
          cVar.className = 'pct zero';
        } else {
          cVar.textContent = fmtPct(pVar);
          cVar.className = clsPct(pVar);
          const tv = totalsVar.get(p.key);
          tv.sum += pVar; tv.count += 1;
        }

        if (pSu === null) {
          cSu.textContent = 'n/a';
          cSu.className = 'pct zero';
        } else {
          cSu.textContent = fmtPct(pSu);
          cSu.className = clsPct(pSu);
          const tsu = totalsSpikeMax.get(p.key);
          tsu.sum += pSu; tsu.count += 1;
        }

        if (pSd === null) {
          cSd.textContent = 'n/a';
          cSd.className = 'pct zero';
        } else {
          cSd.textContent = fmtPct(pSd);
          cSd.className = clsPct(pSd);
          const tsd = totalsSpikeMin.get(p.key);
          tsd.sum += pSd; tsd.count += 1;
        }
      }

      c.statusEl.textContent = 'OK (filtre basé sur janvier 2025)';
      c.loadingEl.textContent = 'Terminé.';
    } catch (e) {
      c.statusEl.textContent = 'Erreur';
      c.loadingEl.className = 'error';
      c.loadingEl.textContent = 'Échec: ' + (e?.message || e);
    }
  }));

  function renderTotals(kind, totalsMap, container) {
    container.innerHTML = '';
    for (const p of periods) {
      const { key, label } = p;
      const { sum, count } = totalsMap.get(key);

      const badge = document.createElement('span');
      const signClass = (count === 0) ? 'zero' : (sum >= 0 ? 'positive' : 'negative');
      const ruleClass = totalRuleClass(kind, sum, count);

      badge.className = `badge ${signClass} ${ruleClass}`;

      const txt = (count === 0)
        ? 'n/a'
        : ((sum>=0?'+':'') + sum.toFixed(3) + '%');

      badge.textContent = `${label} → ${txt}`;
      container.appendChild(badge);
    }
  }

  renderTotals('su',  totalsSpikeMax, totalsSpikeMaxBar);
  renderTotals('sd',  totalsSpikeMin, totalsSpikeMinBar);
  renderTotals('var', totalsVar,      totalsBar);

  document.getElementById('reload').addEventListener('click', (e) => {
    e.preventDefault();
    location.reload();
  });
})();
</script>
</body>
</html>
