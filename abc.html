<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Binance Futures — Variations quotidiennes (clôture) — Octobre</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#0f172a; --card:#0b1220; --text:#e5e7eb; --muted:#94a3b8;
           --ok:#16a34a; --bad:#ef4444; --border:#1f2937; --chip:#111827; }
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:16px 20px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    h1{font-size:18px;margin:0}
    .sub{color:var(--muted);font-size:12px}
    main{padding:16px;max-width:100%;overflow:auto}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:#2563eb;color:#fff;border:0;border-radius:10px;padding:8px 12px;cursor:pointer}
    button:disabled{opacity:.6;cursor:not-allowed}
    .badge{background:var(--chip);border:1px solid var(--border);color:var(--muted);padding:4px 8px;border-radius:999px;font-size:12px}
    table{border-collapse:separate;border-spacing:0;width:max-content;min-width:900px;background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:hidden}
    th,td{padding:8px 10px;border-bottom:1px solid var(--border);border-right:1px solid var(--border);white-space:nowrap;text-align:center;font-variant-numeric:tabular-nums}
    th{position:sticky;top:0;background:#0e182c;z-index:1}
    th:first-child, td:first-child{position:sticky;left:0;background:#0e182c}
    td:first-child{background:var(--card);font-weight:600;text-align:left}
    tr:last-child td{border-bottom:0}
    th:last-child, td:last-child{border-right:0}
    .pos{color:var(--ok);font-weight:600}
    .neg{color:var(--bad);font-weight:600}
    .zero{color:var(--muted)}
    .spin{width:16px;height:16px;border:3px solid #1f2b43;border-top-color:#6b8afd;border-radius:50%;display:inline-block;animation:spin .8s linear infinite;vertical-align:middle}
    @keyframes spin{to{transform:rotate(360deg)}}
    .hint{color:var(--muted);font-size:12px;margin-top:8px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Variations % de clôture — Binance Futures USDT-M (PERP) — Octobre</h1>
      <div class="sub">Calcul: (Clôture⟂J − Clôture⟂J-1) / Clôture⟂J-1 × 100. Fuseau: UTC (bougies 1d).</div>
    </div>
    <div class="controls">
      <button id="startBtn">Démarrer</button>
      <span class="badge" id="status">Prêt</span>
    </div>
  </header>

  <main>
    <div id="wrap"></div>
    <div class="hint">Astuce: fais défiler horizontalement pour voir tous les jours (1 → 31). Première colonne = symbole.</div>
  </main>

  <script>
    const API = {
      base: 'https://fapi.binance.com',
      exchangeInfo: '/fapi/v1/exchangeInfo',
      klines: '/fapi/v1/klines'
    };

    // Mois ciblé: OCTOBRE de l'année courante (modifie ici si besoin)
    const TARGET_YEAR = new Date().getUTCFullYear();   // ex: 2025
    const TARGET_MONTH = 9; // 0=janvier ... 9=octobre
    const startUTC = Date.UTC(TARGET_YEAR, TARGET_MONTH, 1, 0, 0, 0);
    const endUTC   = Date.UTC(TARGET_YEAR, TARGET_MONTH + 1, 0, 23, 59, 59); // dernier jour d'octobre
    const daysInMonth = new Date(Date.UTC(TARGET_YEAR, TARGET_MONTH + 1, 0)).getUTCDate();

    const qs = (sel, el=document) => el.querySelector(sel);
    const statusEl = qs('#status');
    const wrap = qs('#wrap');
    const startBtn = qs('#startBtn');

    function setStatus(txt) { statusEl.textContent = txt; }
    function fmtPct(x){
      if (x === null || Number.isNaN(x)) return '<span class="zero">—</span>';
      const s = (x >= 0 ? '+' : '') + x.toFixed(2) + '%';
      const cls = x > 0 ? 'pos' : (x < 0 ? 'neg' : 'zero');
      return `<span class="${cls}">${s}</span>`;
    }

    function buildTableHeader() {
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const tr = document.createElement('tr');

      const thSym = document.createElement('th');
      thSym.textContent = 'Symbole';
      tr.appendChild(thSym);

      for (let d = 1; d <= daysInMonth; d++) {
        const th = document.createElement('th');
        th.textContent = d.toString().padStart(2,'0');
        tr.appendChild(th);
      }
      thead.appendChild(tr);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      table.appendChild(tbody);
      return { table, tbody };
    }

    async function fetchJSON(url){
      const r = await fetch(url);
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return r.json();
    }

    async function getTradablePerpUSDT() {
      const data = await fetchJSON(API.base + API.exchangeInfo);
      // Garder: USDT-M, PERPETUAL, TRADING, quote USDT
      return data.symbols
        .filter(s =>
          s.status === 'TRADING' &&
          s.contractType === 'PERPETUAL' &&
          s.quoteAsset === 'USDT'
        )
        .map(s => s.symbol)
        .sort();
    }

    // Récupère les bougies 1d de (sept 30) à fin oct pour calcul de J1 vs J-1
    async function getDailyCloses(symbol){
      const startWithPrev = startUTC - 24*60*60*1000; // inclure J-1
      const url = `${API.base}${API.klines}?symbol=${symbol}&interval=1d&startTime=${startWithPrev}&endTime=${endUTC}`;
      const raw = await fetchJSON(url);
      // Kline format: [ openTime, open, high, low, close, ... ]
      // On garde close et openTime
      return raw.map(k => ({ t: k[0], c: parseFloat(k[4]) }));
    }

    function computeMonthCloseToClose(closes){
      // closes contient J-1 puis J1..J31 (selon dispo)
      // On produit un array taille daysInMonth rempli de null par défaut
      const out = Array(daysInMonth).fill(null);
      // Indexer par jour du mois (UTC)
      const byDay = new Map();
      closes.forEach(o => {
        const d = new Date(o.t);
        if (d.getUTCMonth() === TARGET_MONTH) {
          const day = d.getUTCDate(); // 1..31
          byDay.set(day, o.c);
        }
      });
      // Récupérer le close de la veille (30 septembre)
      const prevCloseEntry = closes.find(o => {
        const d = new Date(o.t);
        return d.getUTCFullYear() === TARGET_YEAR &&
               d.getUTCMonth() === TARGET_MONTH - 1 &&
               d.getUTCDate() === new Date(Date.UTC(TARGET_YEAR, TARGET_MONTH, 0)).getUTCDate();
      });
      let prevClose = prevCloseEntry ? prevCloseEntry.c : null;

      for (let day = 1; day <= daysInMonth; day++) {
        const c = byDay.get(day) ?? null;
        if (c != null && prevClose != null) {
          const pct = (c - prevClose) / prevClose * 100;
          out[day-1] = pct;
        } else {
          out[day-1] = null;
        }
        if (c != null) prevClose = c; // avancer la référence
      }
      return out;
    }

    // Petite file d'attente avec parallélisme limité pour éviter les limites API
    async function parallelLimit(items, limit, worker){
      const results = new Array(items.length);
      let i = 0;
      async function next(){
        const idx = i++;
        if (idx >= items.length) return;
        try{
          results[idx] = await worker(items[idx], idx);
        }catch(e){
          results[idx] = { error: e.message };
        }
        return next();
      }
      const runners = Array(Math.min(limit, items.length)).fill(0).map(next);
      await Promise.all(runners);
      return results;
    }

    async function run(){
      startBtn.disabled = true;
      setStatus('Chargement des symboles…');
      wrap.innerHTML = '';

      try{
        const symbols = await getTradablePerpUSDT();
        setStatus(`Symboles PERP USDT actifs: ${symbols.length}`);

        const { table, tbody } = buildTableHeader();
        wrap.appendChild(table);

        // Insère les lignes vides d'abord
        const rowMap = new Map();
        for (const sym of symbols) {
          const tr = document.createElement('tr');
          const tdSym = document.createElement('td');
          tdSym.textContent = sym;
          tr.appendChild(tdSym);
          for (let d=0; d<daysInMonth; d++){
            const td = document.createElement('td');
            td.textContent = '…';
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
          rowMap.set(sym, tr);
        }

        // Récupère en parallèle (par paquets)
        let done = 0;
        const total = symbols.length;
        await parallelLimit(symbols, 8, async (sym) => {
          const closes = await getDailyCloses(sym);
          const pctArr = computeMonthCloseToClose(closes);

          const tr = rowMap.get(sym);
          // Remplit les cellules
          for (let i=0; i<pctArr.length; i++){
            const td = tr.children[i+1];
            const v = pctArr[i];
            td.innerHTML = fmtPct(v);
          }
          done++;
          if (done % 5 === 0) setStatus(`Téléchargé ${done}/${total}`);
        });

        setStatus('Terminé ✅');
      }catch(err){
        console.error(err);
        setStatus('Erreur: ' + err.message);
        // Message d’aide
        const p = document.createElement('p');
        p.textContent = 'Une erreur est survenue. Vérifie ta connexion Internet et réessaie.';
        wrap.appendChild(p);
      }finally{
        startBtn.disabled = false;
      }
    }

    // UI
    startBtn.addEventListener('click', run);
  </script>
</body>
</html>
