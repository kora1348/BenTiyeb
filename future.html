<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Bitcoin Extreme Oscillators - Feux de Trading avec Alertes</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      padding: 8px;
      border: 1px solid #ccc;
      text-align: center;
    }
    th {
      background-color: #f5f5f5;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .green {
      color: green;
      font-weight: bold;
    }
    .red {
      color: red;
      font-weight: bold;
    }
    .neutral {
      color: gray;
    }
    .signal-box {
      margin-top: 30px;
      padding: 15px;
      border: 2px solid #333;
      border-radius: 6px;
      background: #fafafa;
    }
    .signal-box ul {
      margin-top: 10px;
      padding-left: 20px;
    }
    .signal-box li {
      font-weight: bold;
    }
    #alertBox {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #d32f2f;
      color: white;
      padding: 15px 30px;
      border-radius: 5px;
      font-weight: bold;
      display: none;
      z-index: 1000;
      box-shadow: 0 0 10px #d32f2f;
    }
  </style>
</head>
<body>
  <h1>📊 Bitcoin Cycle Extreme Oscillators avec Alertes</h1>
  <p>Sélectionne une date (UTC) pour voir les recommandations de trading :</p>
  <input type="date" id="customDate" />
  <button onclick="loadCryptoData()">Rechercher</button>
  <div id="loading">En attente de chargement...</div>

  <table id="cryptoTable">
    <thead>
      <tr>
        <th>#</th>
        <th>Crypto</th>
        <th>Variation Daily</th>
        <th>Funding Daily</th>
        <th>Score</th>
        <th>Feu</th>
        <th>Entrée OK ? (Daily)</th>
        <th>Sortie Recommandée (Daily)</th>
        <th>Confirmation Intraday (5m)</th>
        <th>Sortie Intraday (5m)</th>
      </tr>
    </thead>
    <tbody id="cryptoTableBody"></tbody>
  </table>

  <div id="recommendations" class="signal-box"></div>
  <div id="alertBox"></div>

  <script>
    const cryptoScores = [];
    let total = 0, loaded = 0;
    let lastConfirmations = {}; // Pour tracker la confirmation intraday précédente

    // Fonction pour jouer un bip sonore
    function playBeep() {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioCtx.createOscillator();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
      oscillator.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 1);
    }

    // Affiche une alerte visuelle
    function showAlert(message) {
      const alertBox = document.getElementById('alertBox');
      alertBox.textContent = message;
      alertBox.style.display = 'block';
      setTimeout(() => {
        alertBox.style.display = 'none';
      }, 10000);
    }

    // Fonction d'alerte quand confirmation intraday passe de OUI à NON
    function checkAlerts() {
      cryptoScores.forEach(c => {
        const symbol = c.symbol;
        const currentConfirm = c.confirmIntraday; // "OUI" ou "NON"

        if (lastConfirmations[symbol] === "OUI" && currentConfirm === "NON") {
          playBeep();
          showAlert(`⚠️ Sortie recommandée sur ${symbol} (confirmation intraday passée à NON)`);
        }

        lastConfirmations[symbol] = currentConfirm;
      });
    }

    async function loadCryptoData() {
      const date = document.getElementById("customDate").value;
      if (!date) return alert("Sélectionne une date.");

      const target = new Date(date);
      target.setUTCHours(2, 0, 0, 0);
      const end = new Date(target);
      end.setUTCDate(end.getUTCDate() + 1);
      end.setUTCHours(1, 59, 59, 999);

      document.getElementById("loading").textContent = "Chargement...";
      document.getElementById("cryptoTableBody").innerHTML = '';
      document.getElementById("recommendations").innerHTML = '';
      cryptoScores.length = 0;
      lastConfirmations = {};

      const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
      const data = await res.json();

      const symbols = data.symbols
        .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
        .map(s => s.baseAsset)
        .filter((v, i, a) => a.indexOf(v) === i);

      total = symbols.length;
      loaded = 0;

      for (const sym of symbols) {
        await fetchCrypto(sym, target, end);
      }

      document.getElementById("loading").textContent = "Chargement terminé.";
      showRecommendations();
      checkAlerts();
    }

    // Fonction pour récupérer les données 5 minutes (intraday) et calculer confirmation intraday
    async function fetchIntradayConfirmation(symbol) {
      try {
        // Récupère les 12 dernières bougies 5m (~1h)
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}USDT&interval=5m&limit=12`);
        if (!res.ok) throw new Error("Erreur intraday");

        const data = await res.json();
        // Dernière clôture
        const lastClose = parseFloat(data[data.length - 1][4]);
        // Moyenne des closes des 11 bougies précédentes
        const closes = data.slice(0, data.length - 1).map(c => parseFloat(c[4]));
        const avgClose = closes.reduce((a, b) => a + b, 0) / closes.length;

        // Confirmation intraday OUI si lastClose > moyenne, sinon NON
        return lastClose > avgClose ? "OUI" : "NON";
      } catch (e) {
        console.warn(`Erreur intraday ${symbol}:`, e);
        return "NON"; // En cas d'erreur, on ne confirme pas
      }
    }

    async function fetchCrypto(symbol, start, end) {
      try {
        // Données daily
        const [kRes, fRes] = await Promise.all([
          fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}USDT&interval=1d&limit=1000`),
          fetch(`https://fapi.binance.com/fapi/v1/fundingRate?symbol=${symbol}USDT&limit=1000`)
        ]);

        if (!kRes.ok || !fRes.ok) throw new Error("Données indisponibles");

        const kData = await kRes.json();
        const fData = await fRes.json();

        const kline = kData.find(k => {
          const d = new Date(k[0]);
          return d.toISOString().slice(0, 10) === start.toISOString().slice(0, 10);
        });

        if (!kline) return increment();

        const open = parseFloat(kline[1]);
        const close = parseFloat(kline[4]);
        const variation = ((close - open) / open) * 100;

        let funding = 0;
        let count = 0;
        for (const f of fData) {
          const t = new Date(f.fundingTime);
          if (t >= start && t <= end) {
            funding += parseFloat(f.fundingRate) * 100;
            count++;
          }
        }

        // Calcul score daily
        let score = 0;
        if (variation >= 3) score++;
        else if (variation <= -3) score--;
        if (funding <= -0.05) score++;
        else if (funding >= 0.05) score--;

        // Entrée OK ? (daily)
        const entreeOK = (variation >= 3 && funding <= -0.05) ? "OUI" : "NON";
        // Sortie recommandée (daily) : signal inverse fort
        const sortieDaily = (variation <= -3 && funding >= 0.05) ? "OUI" : "NON";

        // Confirmation intraday 5m
        const confirmIntraday = await fetchIntradayConfirmation(symbol);

        // Sortie intraday : si la confirmation intraday passe à NON, on recommande la sortie
        // Ici on simule une sortie intraday basée sur la confirmation intraday (peut être améliorée)
        const sortieIntraday = (confirmIntraday === "NON") ? "OUI" : "NON";

        // Feu couleur
        let feu = '⚪';
        let feuClass = 'neutral';
        let decision = null;
        if (score === 2) {
          feu = '🟢';
          feuClass = 'green';
          decision = 'LONG';
        } else if (score === -2) {
          feu = '🔴';
          feuClass = 'red';
          decision = 'SHORT';
        }

        if (decision)
          cryptoScores.push({ symbol, score, decision, confirmIntraday, sortieIntraday });

        // Ajout ligne tableau
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${loaded + 1}</td>
          <td>${symbol}</td>
          <td class="${variation > 0 ? 'green' : variation < 0 ? 'red' : 'neutral'}">${variation.toFixed(2)}%</td>
          <td class="${funding > 0 ? 'red' : funding < 0 ? 'green' : 'neutral'}">${funding.toFixed(5)}%</td>
          <td>${score}</td>
          <td class="${feuClass}">${feu}</td>
          <td>${entreeOK}</td>
          <td>${sortieDaily}</td>
          <td>${confirmIntraday}</td>
          <td>${sortieIntraday === "OUI" ? '<span class="red">OUI</span>' : sortieIntraday}</td>
        `;
        document.getElementById("cryptoTableBody").appendChild(row);

      } catch (e) {
        console.warn("Erreur:", symbol, e);
      } finally {
        increment();
      }
    }

    function increment() {
      loaded++;
      if (loaded === total) {
        // Fin du chargement initial
        document.getElementById("loading").textContent = "Chargement terminé.";
        showRecommendations();
        checkAlerts();

        // Planifie refresh toutes les 5 minutes
        setTimeout(() => {
          // Recharge avec même date
          const date = document.getElementById("customDate").value;
          if (date) loadCryptoDataAuto(date);
        }, 300000);
      }
    }

    async function loadCryptoDataAuto(date) {
      const target = new Date(date);
      target.setUTCHours(2, 0, 0, 0);
      const end = new Date(target);
      end.setUTCDate(end.getUTCDate() + 1);
      end.setUTCHours(1, 59, 59, 999);

      document.getElementById("loading").textContent = "Rafraîchissement auto...";
      document.getElementById("cryptoTableBody").innerHTML = '';
      document.getElementById("recommendations").innerHTML = '';
      cryptoScores.length = 0;
      lastConfirmations = {};

      const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
      const data = await res.json();

      const symbols = data.symbols
        .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
        .map(s => s.baseAsset)
        .filter((v, i, a) => a.indexOf(v) === i);

      total = symbols.length;
      loaded = 0;

      for (const sym of symbols) {
        await fetchCrypto(sym, target, end);
      }

      document.getElementById("loading").textContent = "Rafraîchissement terminé.";
      showRecommendations();
      checkAlerts();

      // Re-planifier rafraîchissement
      setTimeout(() => {
        const date = document.getElementById("customDate").value;
        if (date) loadCryptoDataAuto(date);
      }, 300000);
    }

    function showRecommendations() {
  const box = document.getElementById("recommendations");

  // Filtre sur critères d'entrée et confirmation intraday
  const filtered = cryptoScores.filter(c => 
    c.entreeOK === "OUI" && 
    c.confirmIntraday === "OUI" && 
    c.sortieIntraday === "NON"
  );

  if (filtered.length === 0) {
    box.innerHTML = `<strong>Aucune crypto ne présente de score extrême et de confirmation intraday favorable aujourd’hui.</strong>`;
    return;
  }

  box.innerHTML = `<strong>🔥 Cryptos recommandées aujourd’hui :</strong><ul>` +
    filtered.map(c => {
      const color = c.decision === 'LONG' ? 'green' : 'red';
      return `<li class="${color}">${c.symbol} → ${c.decision} (Score ${c.score})</li>`;
    }).join('') + `</ul>`;
}

  </script>
</body>
</html>
