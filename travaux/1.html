<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Binance Futures — Variations bougie 22h00 (7 dates)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }
    h1{ margin:0 0 6px }
    p{ margin:0 0 14px; color:#444 }

    .card{
      margin: 12px 0 14px;
      padding: 14px;
      border-radius: 8px;
      background: white;
      box-shadow: 0 2px 5px rgba(0,0,0,.10);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .muted{ color:#666; font-size: 13px; }
    .progressWrap{
      width: 420px;
      max-width: 100%;
    }
    .bar{
      height: 12px;
      background:#e9e9e9;
      border-radius: 999px;
      overflow:hidden;
      border:1px solid #ddd;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: #4CAF50;
      transition: width .15s ease;
    }
    .pct{
      font-weight:700;
      min-width: 64px;
      text-align:right;
    }

    table{
      border-collapse: collapse;
      width: 100%;
      background: white;
      box-shadow: 0 2px 5px rgba(0,0,0,.10);
    }
    th, td{
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      white-space: nowrap;
    }
    th{
      background-color: #4CAF50;
      color: white;
      position: sticky;
      top: 0;
      z-index: 2;
    }
    tr:hover{ background-color: #f1f1f1; }
    .positive{ color: green; font-weight: 700; }
    .negative{ color: red; font-weight: 700; }
    .na{ color:#999; }
    .small{ font-size: 12px; }

    .pill{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background:#f0f0f0;
      border:1px solid #e3e3e3;
      font-size: 12px;
      color:#333;
    }

    .warn{
      background:#fff3cd;
      border:1px solid #ffe69c;
      color:#664d03;
      padding:10px 12px;
      border-radius:8px;
      font-size: 13px;
      margin-top:10px;
    }
  </style>
</head>
<body>
  <h1>Variations Futures — bougie 22h00 (Europe/Brussels)</h1>
  <p>Tableau auto: toutes les cryptos <b>USDT-M PERP</b> (Binance Futures) + variation (%) de la bougie 1h qui ouvre à 22h00.</p>

  <div class="card">
    <div class="row">
      <div>
        <div><b>Chargement automatique…</b></div>
        <div class="muted" id="statusLine">Initialisation</div>
        <div class="muted small" id="subLine"></div>
      </div>

      <div class="progressWrap">
        <div class="row" style="justify-content:space-between; margin-bottom:6px;">
          <span class="pill" id="countsPill">0 / 0</span>
          <span class="pct" id="pct">0%</span>
        </div>
        <div class="bar"><div id="barFill"></div></div>
      </div>
    </div>

    <div class="warn">
      ⚠️ Binance limite les requêtes. Le script gère un <b>concurrency</b> et des <b>retries</b>, mais ça peut rester un peu long selon le nombre de symboles.
    </div>
  </div>

  <table id="cryptoTable">
    <thead>
      <tr id="headerRow">
        <th>Crypto</th>
        <!-- dates ajoutées dynamiquement -->
      </tr>
    </thead>
    <tbody id="tableBody"></tbody>
  </table>

<script>
/**
 * Ici on veut EXACTEMENT la bougie qui ouvre à 22h00 (Europe/Brussels).
 * Mais Bruxelles change d'offset (DST):
 * - Octobre 2025 (07/10, 09/10, 10/10): CEST = UTC+2
 * - Décembre 2025 (09/12, 15/12, 18/12, 19/12): CET = UTC+1
 *
 * Du coup chaque date a son offsetHours.
 */
const TARGETS = [
  // Octobre 2025 (UTC+2)
  { key:"2025-10-07 22:00", label:"07/10/2025 — 22:00", y:2025, m:10, d:7,  hh:22, mm:0, offsetHours:2 },
  { key:"2025-10-09 22:00", label:"09/10/2025 — 22:00", y:2025, m:10, d:9,  hh:22, mm:0, offsetHours:2 },
  { key:"2025-10-10 22:00", label:"10/10/2025 — 22:00", y:2025, m:10, d:10, hh:22, mm:0, offsetHours:2 },

  // Décembre 2025 (UTC+1)
  { key:"2025-12-09 22:00", label:"09/12/2025 — 22:00", y:2025, m:12, d:9,  hh:22, mm:0, offsetHours:1 },
  { key:"2025-12-15 22:00", label:"15/12/2025 — 22:00", y:2025, m:12, d:15, hh:22, mm:0, offsetHours:1 },
  { key:"2025-12-18 22:00", label:"18/12/2025 — 22:00", y:2025, m:12, d:18, hh:22, mm:0, offsetHours:1 },
  { key:"2025-12-19 22:00", label:"19/12/2025 — 22:00", y:2025, m:12, d:19, hh:22, mm:0, offsetHours:1 },
];

// futures exchangeInfo + klines endpoints
const EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo";
const KLINES_URL = "https://fapi.binance.com/fapi/v1/klines";

// réglages anti rate-limit
const CONCURRENCY = 10;       // augmente si tu veux (mais risque 429)
const RETRIES = 6;            // nb de retries par requête
const BASE_BACKOFF_MS = 450;  // backoff initial

// UI refs
const statusLine = document.getElementById("statusLine");
const subLine = document.getElementById("subLine");
const pctEl = document.getElementById("pct");
const barFill = document.getElementById("barFill");
const countsPill = document.getElementById("countsPill");
const tbody = document.getElementById("tableBody");
const headerRow = document.getElementById("headerRow");

// progress tracking
let totalSymbols = 0;
let doneSymbols = 0;
let totalRequests = 0;
let doneRequests = 0;

function setStatus(main, sub=""){
  statusLine.textContent = main;
  subLine.textContent = sub;
}

function setProgress(){
  const pct = totalRequests ? Math.min(100, Math.round((doneRequests / totalRequests) * 100)) : 0;
  pctEl.textContent = pct + "%";
  barFill.style.width = pct + "%";
  countsPill.textContent = `${doneSymbols} / ${totalSymbols}`;
}

const sleep = (ms) => new Promise(r => setTimeout(r, ms));

async function fetchJsonWithRetry(url, tries = RETRIES){
  let attempt = 0;
  while(true){
    try{
      const res = await fetch(url, { cache: "no-store" });

      if(!res.ok){
        const status = res.status;
        if((status === 418 || status === 429 || status >= 500) && attempt < tries){
          const backoff = BASE_BACKOFF_MS * Math.pow(2, attempt) + Math.floor(Math.random()*250);
          attempt++;
          await sleep(backoff);
          continue;
        }
        throw new Error(`HTTP ${status} sur ${url}`);
      }

      return await res.json();
    }catch(err){
      if(attempt < tries){
        const backoff = BASE_BACKOFF_MS * Math.pow(2, attempt) + Math.floor(Math.random()*250);
        attempt++;
        await sleep(backoff);
        continue;
      }
      throw err;
    }
  }
}

// convertit "22:00 Brussels" en timestamp UTC (ms) pour startTime Binance
function toUtcMsForBinance(t){
  // Date.UTC: mois 0..11
  return Date.UTC(t.y, t.m - 1, t.d, t.hh - t.offsetHours, t.mm, 0, 0);
}

function formatPct(x){
  if(x === null || Number.isNaN(x)) return "-";
  const v = Number(x);
  return (v >= 0 ? "+" : "") + v.toFixed(2) + "%";
}

function tdWithValue(value){
  const td = document.createElement("td");
  if(value === null || Number.isNaN(value)){
    td.textContent = "-";
    td.className = "na";
    return td;
  }
  td.textContent = formatPct(value);
  td.className = value >= 0 ? "positive" : "negative";
  return td;
}

async function fetchAllUsdtPerpSymbols(){
  setStatus("Récupération des symboles Futures…");
  const info = await fetchJsonWithRetry(EXCHANGE_INFO_URL);

  return (info.symbols || [])
    .filter(s =>
      s.status === "TRADING" &&
      s.contractType === "PERPETUAL" &&
      s.quoteAsset === "USDT" &&
      s.symbol && s.symbol.endsWith("USDT")
    )
    .map(s => s.symbol)
    .sort((a,b) => a.localeCompare(b));
}

async function fetchOneHourCandle(symbol, startTimeMs){
  const url = `${KLINES_URL}?symbol=${encodeURIComponent(symbol)}&interval=1h&startTime=${startTimeMs}&limit=1`;
  const data = await fetchJsonWithRetry(url);

  doneRequests++;
  setProgress();

  if(!Array.isArray(data) || !data.length) return null;
  const c = data[0];

  const open = parseFloat(c[1]);
  const close = parseFloat(c[4]);
  if(!open || Number.isNaN(open) || Number.isNaN(close)) return null;

  return ((close - open) / open) * 100;
}

async function runPool(items, worker, concurrency){
  let i = 0;
  const workers = new Array(concurrency).fill(0).map(async () => {
    while(i < items.length){
      const idx = i++;
      await worker(items[idx], idx);
    }
  });
  await Promise.all(workers);
}

function createRowPlaceholder(symbol, cols){
  const tr = document.createElement("tr");
  tr.dataset.symbol = symbol;

  const tdName = document.createElement("td");
  tdName.textContent = symbol;
  tr.appendChild(tdName);

  for(let k=0;k<cols;k++){
    const td = document.createElement("td");
    td.textContent = "…";
    td.className = "na";
    tr.appendChild(td);
  }

  tbody.appendChild(tr);
  return tr;
}

function updateRow(tr, values){
  for(let k=0;k<values.length;k++){
    tr.children[k+1].replaceWith(tdWithValue(values[k]));
  }
}

function buildHeaders(){
  // ajoute dynamiquement les headers (7 dates)
  TARGETS.forEach(t => {
    const th = document.createElement("th");
    th.textContent = t.label;
    headerRow.appendChild(th);
  });
}

async function buildTable(){
  try{
    setStatus("Initialisation…");
    buildHeaders();

    const symbols = await fetchAllUsdtPerpSymbols();
    totalSymbols = symbols.length;

    totalRequests = totalSymbols * TARGETS.length;
    doneSymbols = 0;
    doneRequests = 0;

    setStatus("Préparation du tableau…", `${totalSymbols} symboles détectés (USDT-M PERP)`);
    setProgress();

    const rowMap = new Map();
    for(const s of symbols){
      rowMap.set(s, createRowPlaceholder(s, TARGETS.length));
    }

    setStatus("Chargement des bougies 1h…", "Variation = (close-open) / open * 100 — bougie qui ouvre à 22h00 Brussels");

    const startTimes = TARGETS.map(t => toUtcMsForBinance(t));

    await runPool(symbols, async (symbol) => {
      const vals = new Array(TARGETS.length).fill(null);

      for(let k=0;k<TARGETS.length;k++){
        try{
          vals[k] = await fetchOneHourCandle(symbol, startTimes[k]);
        }catch(e){
          vals[k] = null;
        }
      }

      updateRow(rowMap.get(symbol), vals);

      doneSymbols++;
      setProgress();
    }, CONCURRENCY);

    setStatus("Terminé ✅", `Bougies traitées: ${doneRequests}/${totalRequests}`);
    setProgress();
  }catch(err){
    console.error(err);
    setStatus("Erreur lors du chargement ❌", String(err.message || err));
  }
}

buildTable();
</script>
</body>
</html>
