<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Variation — Futures & Spot (01:00 → 00:59)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#94a3b8;
      --up:#16a34a; --down:#dc2626; --zero:#64748b; --border:#1f2937; --header:#0b1220; --accent:#2563eb;
      --total:#facc15;
    }
    *{box-sizing:border-box}
    body{margin:0;background:#0b1020;color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;padding:24px}
    header{max-width:1200px;margin:0 auto 16px;display:flex;gap:12px;align-items:baseline;flex-wrap:wrap}
    header h1{margin:0;font-size:20px;font-weight:700}
    .meta{color:var(--muted);font-size:14px}
    .controls{margin-left:auto;display:flex;gap:12px}
    .controls button{background:var(--accent);border:0;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer;font-family:inherit;font-size:14px}
    .controls button a{color:#fff;text-decoration:none}

    .summary-cards{max-width:1200px;margin:0 auto 16px;display:flex;flex-direction:column;gap:12px}
    .summary-card{padding:12px 16px;border-radius:12px;font-size:14px;border:1px solid var(--border);}
    #variation_negative{
      background:linear-gradient(180deg,rgba(220,38,38,.1),rgba(220,38,38,.04)), var(--card);
      border-color:rgba(220,38,38,.35); color:#fecaca;
    }
    #spike_max{
      background:linear-gradient(180deg,rgba(34,197,94,.1),rgba(34,197,94,.04)), var(--card);
      border-color:rgba(34,197,94,.35); color:#dcfce7;
    }
    #spike_min{
      background:linear-gradient(180deg,rgba(59,130,246,.1),rgba(59,130,246,.04)), var(--card);
      border-color:rgba(59,130,246,.35); color:#dbeafe;
    }
    .summary-card .title{font-weight:700;margin-bottom:8px}
    #variation_negative .title{color:#fca5a5}
    #spike_max .title{color:#86efac}
    #spike_min .title{color:#93c5fd}
    .total-badges{display:flex;gap:10px;flex-wrap:wrap}
    .total-badges .badge{
      background:#1f2937;border:1px solid var(--border);border-radius:999px;
      padding:4px 10px;color:#fff;font-weight:700
    }
    .total-badges .badge.positive{color:#22c55e}
    .total-badges .badge.negative{color:#ef4444}
    .total-badges .badge.zero{color:#94a3b8}

    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(520px,1fr));gap:16px;max-width:1200px;margin:0 auto}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),transparent),var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden}
    .card header{background:var(--header);border-bottom:1px solid var(--border);padding:10px 12px;display:flex;gap:10px;align-items:center}
    .symbol{font-weight:700;letter-spacing:.3px}
    .status{margin-left:auto;font-size:12px;color:var(--muted)}
    .table-wrap{max-height:70vh;overflow:auto}
    table{width:100%;border-collapse:separate;border-spacing:0;font-variant-numeric:tabular-nums}
    thead th{position:sticky;top:0;background:var(--header);border-bottom:1px solid var(--border);padding:6px 8px;font-size:12px;color:var(--muted);text-align:left}
    thead th.num, tbody td.pct{text-align:right}
    tbody td, tbody th{border-bottom:1px solid rgba(255,255,255,.06);padding:6px 8px;font-size:12px;vertical-align:top}
    tbody td.time{color:var(--muted)}
    .pct{font-weight:600}
    .up{color:var(--up)} .down{color:var(--down)} .zero{color:var(--zero)}
    .loading,.error{padding:10px 12px;border-top:1px solid var(--border);font-size:13px;color:var(--muted)}
    .error{color:#fca5a5}
    .chip{font-size:11px;font-weight:700;padding:2px 6px;border-radius:6px;border:1px solid var(--border);color:#94a3b8;margin-left:8px}
    .info-banner{max-width:1200px;margin:0 auto 16px;padding:12px;background:rgba(59,130,246,0.1);border:1px solid rgba(59,130,246,0.3);border-radius:8px;color:#93c5fd;font-size:14px;}

    /* Sous-table (heures) */
    .hours-wrap{
      padding:10px 10px 12px;
      background:rgba(255,255,255,.02);
      border:1px dashed rgba(255,255,255,.12);
      border-radius:12px;
      margin:6px 0 2px;
    }
    .hours-title{
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      margin:0 0 8px;font-size:12px;color:var(--muted)
    }
    .hours-title strong{color:#e5e7eb}
    .hours-table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      font-variant-numeric:tabular-nums;
      overflow:hidden;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.08);
    }
    .hours-table thead th{
      position:sticky; top:0;
      background:rgba(11,18,32,.9);
      padding:6px 8px;
      font-size:11px;
      color:var(--muted);
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .hours-table tbody td{
      padding:6px 8px;
      font-size:11px;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .hours-table td.num{text-align:right}
    .hours-table td.time{color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <h1>Variation — Multi-symboles <span class="chip">Fenêtre : 01:00 → 00:59</span> <span class="chip" id="chipInterval"></span></h1>
    <div class="meta" id="metaLine"></div>
    <div class="controls"><button id="reload"><a href="/index.html">Accueil</a></button></div>
  </header>

  <div class="info-banner">
    ⚠️ "n/a" = pas assez de bougies sur la fenêtre ou symbole indisponible.<br/>
    ⚠️ API utilisée : <strong>Binance Futures (prioritaire) + Spot (fallback)</strong>
  </div>

  <div class="summary-cards">
    <div id="spike_max" class="summary-card">
      <span class="title">TOTAL Spike max (mèche ↑) — fenêtre :</span>
      <div id="total_spike_max" class="total-badges"></div>
    </div>

    <div id="spike_min" class="summary-card">
      <span class="title">TOTAL Spike min (mèche ↓) — fenêtre :</span>
      <div id="total_spike_min" class="total-badges"></div>
    </div>

    <div id="variation_negative" class="summary-card">
      <span class="title">TOTAL (somme des variations de tous les symboles) — fenêtre :</span>
      <div id="total_variation" class="total-badges"></div>
    </div>
  </div>

  <div id="grid" class="grid"></div>

<script>
(async () => {
  function fmtPct(p){ return (p >= 0 ? '+' : '') + p.toFixed(3) + '%'; }
  function clsPct(p){ return 'pct ' + (p > 0 ? 'up' : (p < 0 ? 'down' : 'zero')); }
  function pad(n){ return String(n).padStart(2,'0'); }

  const timeZone = "Europe/Brussels";

  // 24h (01:00 -> 00:59) en 1m = 1440 bougies > 1000 limit => on garde 5m (288 bougies)
  const INTERVAL = "5m";
  document.getElementById('chipInterval').textContent = `Timeframe interne : ${INTERVAL}`;

  const symbols = [
    "AEVOUSDT","ARPAUSDT","AXLUSDT","DIAUSDT","EGLDUSDT","IDUSDT","RONINUSDT","WLDUSDT",
    "1000SATSUSDT","1000LUNCUSDT","ANKRUSDT","DENTUSDT","ENJUSDT",
  ];

  // ✅ uniquement tes 2 fenêtres demandées
  const DATE_STRINGS = [
    "09/12/2025",
    "15/12/2025",
  ];

  function tzOffsetMsAt(date, tz) {
    const dtf = new Intl.DateTimeFormat('en-GB', {
      timeZone: tz,
      year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit',
      hour12:false
    });
    const parts = dtf.formatToParts(date);
    const map = {};
    for (const p of parts) map[p.type] = p.value;

    const asUTC = Date.UTC(
      Number(map.year),
      Number(map.month) - 1,
      Number(map.day),
      Number(map.hour),
      Number(map.minute),
      Number(map.second)
    );
    return asUTC - date.getTime();
  }

  function localToUtcMs(y, m, d, hh, mm, ss, ms, tz) {
    const approxUtc = Date.UTC(y, m-1, d, hh, mm, ss, ms);
    const offset = tzOffsetMsAt(new Date(approxUtc), tz);
    return approxUtc - offset;
  }

  function parseDMY(dmy){
    const [dd, mm, yyyy] = dmy.split('/').map(Number);
    return { d:dd, m:mm, y:yyyy };
  }

  function addDays(y,m,d, add){
    const dt = new Date(Date.UTC(y, m-1, d, 12, 0, 0)); // midi UTC pour éviter DST
    dt.setUTCDate(dt.getUTCDate() + add);
    return { y: dt.getUTCFullYear(), m: dt.getUTCMonth()+1, d: dt.getUTCDate() };
  }

  // ✅ Fenêtres: jour J 01:00 -> jour J+1 00:59
  const windows = DATE_STRINGS.map((ds, idx) => {
    const s0 = parseDMY(ds);
    const e0 = addDays(s0.y, s0.m, s0.d, 1);

    const startUtc = localToUtcMs(s0.y, s0.m, s0.d, 1, 0, 0, 0, timeZone);
    const endUtc   = localToUtcMs(e0.y, e0.m, e0.d, 0, 59, 0, 0, timeZone) + 60*1000 - 1;

    const label = `${pad(s0.d)}/${pad(s0.m)}/${s0.y} 01:00 → ${pad(e0.d)}/${pad(e0.m)}/${e0.y} 00:59`;
    const key = `${s0.y}-${pad(s0.m)}-${pad(s0.d)}`;

    return { key, label, startUtc, endUtc, start:s0, end:e0 };
  });

  // Construire les 24 segments horaires attendus (Brussels) pour une fenêtre
  function buildHourlySegments(w){
    const segs = [];
    // Jour 0 : 01..23
    for (let hh = 1; hh <= 23; hh++){
      const sUtc = localToUtcMs(w.start.y, w.start.m, w.start.d, hh, 0, 0, 0, timeZone);
      const eUtc = sUtc + 60*60*1000 - 1;
      segs.push({
        label: `${pad(w.start.d)}/${pad(w.start.m)}/${w.start.y} ${pad(hh)}:00 → ${pad(hh)}:59`,
        startUtc: sUtc,
        endUtc: eUtc
      });
    }
    // Jour 1 : 00:00..00:59
    {
      const sUtc = localToUtcMs(w.end.y, w.end.m, w.end.d, 0, 0, 0, 0, timeZone);
      const eUtc = sUtc + 60*60*1000 - 1;
      segs.push({
        label: `${pad(w.end.d)}/${pad(w.end.m)}/${w.end.y} 00:00 → 00:59`,
        startUtc: sUtc,
        endUtc: eUtc
      });
    }
    return segs; // 24 segments
  }

  (function renderHeaderMeta(){
    const meta = document.getElementById('metaLine');
    meta.innerHTML = `
      ${windows.length} fenêtres analysées • <strong>${windows[0].label}</strong> et <strong>${windows[1].label}</strong>
      • Timeframe interne : <strong>${INTERVAL}</strong> • API : <strong>Futures + Spot</strong>
      • Fuseau : <strong>${timeZone}</strong>
    `;
  })();

  const grid = document.getElementById('grid');
  const totalsBar         = document.getElementById('total_variation');
  const totalsSpikeMaxBar = document.getElementById('total_spike_max');
  const totalsSpikeMinBar = document.getElementById('total_spike_min');

  function pctChange(open, close) {
    const o = Number(open), c = Number(close);
    if (!isFinite(o) || o === 0 || !isFinite(c)) return null;
    return ((c - o) / o) * 100;
  }

  async function fetchKlines(symbol, startUtc, endUtc) {
    try {
      const futuresUrl = new URL('https://fapi.binance.com/fapi/v1/klines');
      futuresUrl.searchParams.set('symbol', symbol);
      futuresUrl.searchParams.set('interval', INTERVAL);
      futuresUrl.searchParams.set('startTime', String(startUtc));
      futuresUrl.searchParams.set('endTime', String(endUtc));
      futuresUrl.searchParams.set('limit', '1000');

      const res = await fetch(futuresUrl.toString());
      if (!res.ok) throw new Error(`Futures API returned ${res.status}`);
      const data = await res.json();
      if (!Array.isArray(data)) throw new Error('Réponse inattendue Futures.');
      return data;
    } catch (e) {
      try {
        const spotUrl = new URL('https://api.binance.com/api/v3/klines');
        spotUrl.searchParams.set('symbol', symbol);
        spotUrl.searchParams.set('interval', INTERVAL);
        spotUrl.searchParams.set('startTime', String(startUtc));
        spotUrl.searchParams.set('endTime', String(endUtc));
        spotUrl.searchParams.set('limit', '1000');

        const res = await fetch(spotUrl.toString());
        if (!res.ok) throw new Error(`Spot API returned ${res.status}`);
        const data = await res.json();
        if (!Array.isArray(data)) throw new Error('Réponse inattendue Spot.');
        return data;
      } catch (e2) {
        return [];
      }
    }
  }

  function buildCard(symbol) {
    const card = document.createElement('div');
    card.className = 'card';

    const head = document.createElement('header');
    const symEl = document.createElement('div');
    symEl.className = 'symbol';
    symEl.textContent = symbol;

    const status = document.createElement('div');
    status.className = 'status';
    status.textContent = 'Chargement…';

    head.appendChild(symEl);
    head.appendChild(status);

    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    thead.innerHTML = `
      <tr>
        <th>Fenêtre (Brussels)</th>
        <th class="num">Variation</th>
        <th class="num">Spike max (mèche ↑)</th>
        <th class="num">Spike min (mèche ↓)</th>
      </tr>`;
    const tbody = document.createElement('tbody');

    for (const w of windows) {
      // Ligne principale fenêtre
      const tr = document.createElement('tr');

      const tdTime = document.createElement('td');
      tdTime.className = 'time';
      tdTime.textContent = w.label;

      const tdVar = document.createElement('td');
      tdVar.className = 'pct zero';
      tdVar.textContent = '—';
      tdVar.dataset.target = `${w.key}:var`;

      const tdSpikeUp = document.createElement('td');
      tdSpikeUp.className = 'pct zero';
      tdSpikeUp.textContent = '—';
      tdSpikeUp.dataset.target = `${w.key}:su`;

      const tdSpikeDn = document.createElement('td');
      tdSpikeDn.className = 'pct zero';
      tdSpikeDn.textContent = '—';
      tdSpikeDn.dataset.target = `${w.key}:sd`;

      tr.appendChild(tdTime);
      tr.appendChild(tdVar);
      tr.appendChild(tdSpikeUp);
      tr.appendChild(tdSpikeDn);
      tbody.appendChild(tr);

      // ✅ Ligne “en dessous” : détails horaires
      const trHours = document.createElement('tr');
      const tdHours = document.createElement('td');
      tdHours.colSpan = 4;
      tdHours.innerHTML = `
        <div class="hours-wrap">
          <div class="hours-title">
            <strong>Détails par heure</strong>
            <span>• Var(heure) = open→close de l’heure</span>
            <span>• Var cumulée = open(01:00) → close de l’heure</span>
          </div>
          <div data-target="${w.key}:hours">Chargement des bougies horaires…</div>
        </div>
      `;
      trHours.appendChild(tdHours);
      tbody.appendChild(trHours);
    }

    table.appendChild(thead);
    table.appendChild(tbody);
    wrap.appendChild(table);

    const loading = document.createElement('div');
    loading.className = 'loading';
    loading.textContent = `Requêtes klines ${INTERVAL}…`;

    card.appendChild(head);
    card.appendChild(wrap);
    card.appendChild(loading);
    grid.appendChild(card);

    return { card, statusEl: status, loadingEl: loading, tbody };
  }

  function computeSpikeMaxPct(open, highs){
    const o = Number(open);
    if (!isFinite(o) || o === 0 || !highs.length) return null;
    let maxH = -Infinity;
    for (const h of highs){ const v = Number(h); if (isFinite(v) && v > maxH) maxH = v; }
    if (!isFinite(maxH)) return null;
    return ((maxH - o) / o) * 100;
  }

  function computeSpikeMinPct(open, lows){
    const o = Number(open);
    if (!isFinite(o) || o === 0 || !lows.length) return null;
    let minL = Infinity;
    for (const l of lows){ const v = Number(l); if (isFinite(v) && v < minL) minL = v; }
    if (!isFinite(minL)) return null;
    return ((minL - o) / o) * 100;
  }

  function renderHourlyTable(w, windowOpen, klines){
    const segs = buildHourlySegments(w);

    // indexer rapidement les klines par openTime
    // (on filtrera par range, c’est suffisant avec 288 bougies)
    const rows = [];

    for (const seg of segs) {
      const segK = klines.filter(k => {
        const t = Number(k[0]); // open time
        return isFinite(t) && t >= seg.startUtc && t <= seg.endUtc;
      });

      if (segK.length === 0) {
        rows.push({
          time: seg.label,
          varH: null,
          varCum: null,
          su: null,
          sd: null,
          note: 'n/a'
        });
        continue;
      }

      const first = segK[0];
      const last  = segK[segK.length - 1];

      const openH  = Number(first[1]);
      const closeH = Number(last[4]);

      const highs = segK.map(k => k[2]);
      const lows  = segK.map(k => k[3]);

      const varH   = pctChange(openH, closeH);
      const varCum = pctChange(windowOpen, closeH);

      const su = computeSpikeMaxPct(openH, highs);
      const sd = computeSpikeMinPct(openH, lows);

      rows.push({ time: seg.label, varH, varCum, su, sd, note: null });
    }

    const html = `
      <table class="hours-table">
        <thead>
          <tr>
            <th>Heure (Brussels)</th>
            <th class="num">Var (heure)</th>
            <th class="num">Var cumulée</th>
            <th class="num">Spike ↑ (heure)</th>
            <th class="num">Spike ↓ (heure)</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => {
            const vH  = r.varH   === null ? `<span class="zero">n/a</span>` : `<span class="${clsPct(r.varH)}">${fmtPct(r.varH)}</span>`;
            const vC  = r.varCum === null ? `<span class="zero">n/a</span>` : `<span class="${clsPct(r.varCum)}">${fmtPct(r.varCum)}</span>`;
            const sU  = r.su     === null ? `<span class="zero">n/a</span>` : `<span class="${clsPct(r.su)}">${fmtPct(r.su)}</span>`;
            const sD  = r.sd     === null ? `<span class="zero">n/a</span>` : `<span class="${clsPct(r.sd)}">${fmtPct(r.sd)}</span>`;
            return `
              <tr>
                <td class="time">${r.time}</td>
                <td class="num">${vH}</td>
                <td class="num">${vC}</td>
                <td class="num">${sU}</td>
                <td class="num">${sD}</td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
    `;
    return html;
  }

  const cards = symbols.map(s => {
    const built = buildCard(s);
    const rowCells = {};
    for (const w of windows) {
      rowCells[`${w.key}:var`]   = built.tbody.querySelector(`td[data-target="${w.key}:var"]`);
      rowCells[`${w.key}:su`]    = built.tbody.querySelector(`td[data-target="${w.key}:su"]`);
      rowCells[`${w.key}:sd`]    = built.tbody.querySelector(`td[data-target="${w.key}:sd"]`);
      rowCells[`${w.key}:hours`] = built.tbody.querySelector(`[data-target="${w.key}:hours"]`);
    }
    return { symbol: s, ...built, rowCells };
  });

  const totalsVar      = new Map();
  const totalsSpikeMax = new Map();
  const totalsSpikeMin = new Map();

  for (const w of windows) {
    totalsVar.set(w.key,      { sum:0, count:0 });
    totalsSpikeMax.set(w.key, { sum:0, count:0 });
    totalsSpikeMin.set(w.key, { sum:0, count:0 });
  }

  await Promise.allSettled(cards.map(async (c) => {
    c.statusEl.textContent = 'Chargement…';
    c.loadingEl.textContent = `Requêtes klines ${INTERVAL}…`;

    try {
      for (const w of windows) {
        const kl = await fetchKlines(c.symbol, w.startUtc, w.endUtc);

        let pVar = null, pSu = null, pSd = null;
        let windowOpen = null;

        if (kl.length >= 2) {
          const first = kl[0];
          const last  = kl[kl.length - 1];

          const open0  = Number(first[1]);
          const closeL = Number(last[4]);
          windowOpen = open0;

          if (isFinite(open0) && open0 !== 0 && isFinite(closeL)) {
            pVar = pctChange(open0, closeL);

            let maxH = -Infinity;
            let minL =  Infinity;
            for (const k of kl) {
              const h = Number(k[2]);
              const l = Number(k[3]);
              if (isFinite(h) && h > maxH) maxH = h;
              if (isFinite(l) && l < minL) minL = l;
            }
            pSu = isFinite(maxH) ? ((maxH - open0) / open0) * 100 : null;
            pSd = isFinite(minL) ? ((minL - open0) / open0) * 100 : null;
          }
        }

        const cVar   = c.rowCells[`${w.key}:var`];
        const cSu    = c.rowCells[`${w.key}:su`];
        const cSd    = c.rowCells[`${w.key}:sd`];
        const cHours = c.rowCells[`${w.key}:hours`];

        if (pVar === null) {
          cVar.textContent = 'n/a';
          cVar.className = 'pct zero';
          cVar.title = `Pas assez de bougies sur ${w.label}`;
        } else {
          cVar.textContent = fmtPct(pVar);
          cVar.className = clsPct(pVar);
          const tv = totalsVar.get(w.key);
          tv.sum += pVar; tv.count += 1;
        }

        if (pSu === null) {
          cSu.textContent = 'n/a';
          cSu.className = 'pct zero';
        } else {
          cSu.textContent = fmtPct(pSu);
          cSu.className = clsPct(pSu);
          const tsu = totalsSpikeMax.get(w.key);
          tsu.sum += pSu; tsu.count += 1;
        }

        if (pSd === null) {
          cSd.textContent = 'n/a';
          cSd.className = 'pct zero';
        } else {
          cSd.textContent = fmtPct(pSd);
          cSd.className = clsPct(pSd);
          const tsd = totalsSpikeMin.get(w.key);
          tsd.sum += pSd; tsd.count += 1;
        }

        // ✅ Détails horaires “en dessous”
        if (!windowOpen || !Array.isArray(kl) || kl.length === 0) {
          cHours.innerHTML = `<div class="zero">n/a (pas de données intraday)</div>`;
        } else {
          cHours.innerHTML = renderHourlyTable(w, windowOpen, kl);
        }
      }

      c.statusEl.textContent = 'OK';
      c.loadingEl.textContent = 'Terminé. Données Futures/Spot.';
    } catch (e) {
      c.statusEl.textContent = 'Erreur';
      c.loadingEl.className = 'error';
      c.loadingEl.textContent = 'Échec: ' + (e?.message || e);
    }
  }));

  function renderTotals(totalsMap, container) {
    container.innerHTML = '';
    for (const w of windows) {
      const { sum, count } = totalsMap.get(w.key);
      const badge = document.createElement('span');
      badge.className = 'badge ' + (count === 0 ? 'zero' : (sum >= 0 ? 'positive' : 'negative'));
      const txt = count === 0 ? 'n/a' : ((sum>=0?'+':'') + sum.toFixed(3) + '%');
      badge.textContent = `${w.label} → ${txt}`;
      badge.title = count > 0 ? `${count} symboles avec données` : 'Aucune donnée disponible';
      container.appendChild(badge);
    }
  }

  renderTotals(totalsVar,      totalsBar);
  renderTotals(totalsSpikeMax, totalsSpikeMaxBar);
  renderTotals(totalsSpikeMin, totalsSpikeMinBar);

  document.getElementById('reload').addEventListener('click', (e) => {
    e.preventDefault();
    location.reload();
  });
})();
</script>
</body>
</html>
