<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Variations — Binance Futures (1h) — 1000LUNCUSDT — Multi-jours</title>
  <style>
    body{font-family:Arial,sans-serif;margin:20px;background:#f5f5f5}
    h2{margin:0 0 6px}
    .status{margin:0 0 10px;font-weight:700}
    .status.negative{color:red}
    .status.positive{color:green}

    .card{margin:12px 0 14px;padding:14px;border-radius:8px;background:#fff;box-shadow:0 2px 5px rgba(0,0,0,.10)}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .muted{color:#666;font-size:13px}
    table{background:#fff;border-collapse:collapse}
    th{background:#fafafa;position:sticky;top:0}
    th,td{border:1px solid #ddd;padding:8px}
    .wrap{max-width:1200px}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(360px,1fr));gap:14px}
    .small{font-size:12px}

    select, input, button{font:inherit}
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      background:#eee;
      font-size:12px;
      color:#333;
      margin-left:6px;
    }
  </style>
</head>
<body class="wrap">

  <!-- Contrôles -->
  <div class="card">
    <div class="row">
      <div>
        <button class="prevBtn">Précédant</button>
        <button class="nextBtn">Suivant</button>

        &nbsp;|&nbsp;

        <label>
          Date :
          <input
            type="text"
            class="dateInput"
            placeholder="JJ/MM/AAAA"
            inputmode="numeric"
            style="width:120px"
          />
        </label>

        <button class="goDateBtn">OK</button>

        &nbsp;|&nbsp;

        <label class="small">
          Nombre de jours affichés :
          <input id="daysCount" type="number" min="1" max="60" value="24" style="width:70px" />
        </label>

        &nbsp;|&nbsp;

        <!-- ✅ NOUVEAU: filtre dropdown -->
        <label class="small">
          Filtre :
          <select id="polarityFilter">
            <option value="all">All</option>
            <option value="negative">Negative</option>
            <option value="positive">Positif</option>
          </select>
        </label>

        <button id="reloadBtn">Recharger</button>

        <span class="pill" id="shownCount">—</span>
      </div>

      <div class="muted" id="rangeInfo">—</div>
    </div>
    <div class="muted small" id="fixedInfo"></div>
  </div>

  <!-- CONTAINER DES TABLEAUX -->
  <div id="tables" class="grid"></div>

<script>
/* ========= CONFIG ========= */
const BASE_FUTURES  = "https://fapi.binance.com";
const SYMBOL        = "1000LUNCUSDT";

// Fenêtre demandée : du 20/12/2025 au 27/11/2025 (inclus)
const RANGE_START_UTC = new Date(Date.UTC(2025, 11, 20, 0, 0, 0, 0)); // 20/12/2025
const RANGE_END_UTC   = new Date(Date.UTC(2025, 10, 27, 0, 0, 0, 0)); // 27/11/2025

// Date courante (point de départ d'affichage)
let baseDateUtc = new Date(RANGE_START_UTC);

/* ========= STATUS MANUEL PAR DATE (JJ/MM/AAAA) ========= */
const STATUS_BY_DATE_FR = {
  "20/12/2025": { text: "negative", cls: "negative" },
  "19/12/2025": { text: "positif",  cls: "positive" },
  "18/12/2025": { text: "negative", cls: "negative" },
  "17/12/2025": { text: "negative", cls: "negative" },
  "16/12/2025": { text: "positive", cls: "positive" },
  "15/12/2025": { text: "negative", cls: "negative" },
  "14/12/2025": { text: "negative", cls: "negative" },
  "13/12/2025": { text: "negative", cls: "negative" },
  "12/12/2025": { text: "negative", cls: "negative" },
  "11/12/2025": { text: "negative", cls: "negative" },
  "10/12/2025": { text: "negative", cls: "negative" },
  "09/12/2025": { text: "negative", cls: "negative" },
  "08/12/2025": { text: "positive", cls: "positive" },
  "07/12/2025": { text: "negative", cls: "negative" },
  "06/12/2025": { text: "positive", cls: "positive" },
  "05/12/2025": { text: "positive", cls: "positive" },
  "04/12/2025": { text: "positive", cls: "positive" },
  "03/12/2025": { text: "negative", cls: "negative" },
  "02/12/2025": { text: "negative", cls: "negative" },
  "01/12/2025": { text: "positive", cls: "positive" },
  "30/11/2025": { text: "negative", cls: "negative" },
  "29/11/2025": { text: "negative", cls: "negative" },
  "28/11/2025": { text: "positive", cls: "positive" },
  "27/11/2025": { text: "negative", cls: "negative" },
};

/* ========= UTILS DATES ========= */
const pad2 = n => String(n).padStart(2, "0");
const toFr = d => `${pad2(d.getUTCDate())}/${pad2(d.getUTCMonth()+1)}/${d.getUTCFullYear()}`;
const toYmd = d => `${d.getUTCFullYear()}-${pad2(d.getUTCMonth()+1)}-${pad2(d.getUTCDate())}`;

function addDaysUtc(d, days){
  const x = new Date(d);
  x.setUTCDate(x.getUTCDate() + days);
  return new Date(Date.UTC(x.getUTCFullYear(), x.getUTCMonth(), x.getUTCDate(), 0, 0, 0, 0));
}

function clampToFixedRange(d){
  if(d.getTime() > RANGE_START_UTC.getTime()) return new Date(RANGE_START_UTC);
  if(d.getTime() < RANGE_END_UTC.getTime()) return new Date(RANGE_END_UTC);
  return d;
}

// parse "JJ/MM/AAAA" -> Date UTC (00:00)
function frToUtcDate(fr){
  const m = /^(\d{2})\/(\d{2})\/(\d{4})$/.exec(String(fr || "").trim());
  if(!m) return null;

  const dd = Number(m[1]), mm = Number(m[2]), yy = Number(m[3]);
  if(mm < 1 || mm > 12 || dd < 1 || dd > 31) return null;

  const dt = new Date(Date.UTC(yy, mm-1, dd, 0, 0, 0, 0));
  if(isNaN(dt.getTime())) return null;

  if(dt.getUTCFullYear() !== yy || (dt.getUTCMonth()+1) !== mm || dt.getUTCDate() !== dd) return null;
  return dt;
}

function dayUtcRangeMs(dUtc){
  const y = dUtc.getUTCFullYear();
  const m = dUtc.getUTCMonth();
  const d = dUtc.getUTCDate();
  return {
    start: Date.UTC(y, m, d, 0, 0, 0, 0),
    end:   Date.UTC(y, m, d, 23, 59, 59, 999)
  };
}

/* ========= FORMAT ========= */
const fmtPct = v => `${v>0?"+":""}${v.toFixed(2)}%`;
function applyColor(el, v){
  el.style.color = v > 0 ? "green" : v < 0 ? "red" : "";
}
function hourLabelUTC(ms){
  const d = new Date(ms);
  return `${pad2(d.getUTCHours())}:00`;
}

/* ========= API ========= */
async function fetchKlines1h(symbol, startMs, endMs){
  const url = `${BASE_FUTURES}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=1h&startTime=${startMs}&endTime=${endMs}&limit=24`;
  const r = await fetch(url);
  if(!r.ok) throw new Error(`${symbol} -> HTTP ${r.status}`);
  const arr = await r.json();
  if(!Array.isArray(arr) || arr.length === 0) throw new Error(`${symbol} -> aucune bougie 1h`);
  return arr;
}

function pctFromKline(k){
  const o = +k[1], c = +k[4];
  if(!isFinite(o) || !isFinite(c) || o <= 0) return null;
  return ((c - o) / o) * 100;
}

/* ========= BUILD 1 TABLE CARD ========= */
function createTableCard(dateUtc){
  const fr = toFr(dateUtc);
  const st = STATUS_BY_DATE_FR[fr]; // peut être undefined

  const card = document.createElement("div");
  card.className = "card";
  card.dataset.polarity = st ? st.cls : "unknown"; // ✅ important pour filtrer

  const h2 = document.createElement("h2");
  h2.textContent = `Tableau — ${SYMBOL} — ${fr}`;
  card.appendChild(h2);

  if(st){
    const p = document.createElement("div");
    p.className = `status ${st.cls}`;
    p.textContent = st.text;
    card.appendChild(p);
  }else{
    const p = document.createElement("div");
    p.className = "muted small";
    p.textContent = "(polarité non définie)";
    card.appendChild(p);
  }

  const table = document.createElement("table");
  table.width = "100%";
  table.cellPadding = "8";

  table.innerHTML = `
    <thead>
      <tr>
        <th>Heure (UTC)</th>
        <th>Taux variation 1h</th>
      </tr>
    </thead>
    <tbody>
      <tr><td colspan="2">Chargement...</td></tr>
    </tbody>
  `;

  card.appendChild(table);

  return { card, tbody: table.querySelector("tbody"), status: st };
}

/* ========= FILL TABLE (afficher seulement les heures selon polarité de la date) ========= */
async function fillTableForDate(dateUtc, tbody, status){
  tbody.innerHTML = "";

  const {start, end} = dayUtcRangeMs(dateUtc);
  let klines = await fetchKlines1h(SYMBOL, start, end);

  klines = klines
    .filter(k => k && k[0] >= start && k[0] < start + 24*60*60*1000)
    .sort((a,b)=>a[0]-b[0]);

  // - date negative => afficher UNIQUEMENT les heures négatives
  // - date positive => afficher UNIQUEMENT les heures positives
  // - pas de status => afficher tout
  const filterMode = status ? status.cls : null; // "negative" | "positive" | null

  let rows = 0;

  for(const k of klines){
    const v = pctFromKline(k);
    if(v === null) continue;

    const isNeg = v < 0;
    const isPos = v > 0;

    let ok = true;
    if(filterMode === "negative") ok = isNeg;
    else if(filterMode === "positive") ok = isPos;

    if(!ok) continue;

    rows++;

    const tr = document.createElement("tr");
    const tdH = document.createElement("td");
    const tdV = document.createElement("td");

    tdH.textContent = hourLabelUTC(k[0]);
    tdV.textContent = fmtPct(v);
    applyColor(tdV, v);

    tr.appendChild(tdH);
    tr.appendChild(tdV);
    tbody.appendChild(tr);
  }

  if(rows === 0){
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 2;

    if(filterMode === "negative") td.textContent = "Aucune heure négative trouvée.";
    else if(filterMode === "positive") td.textContent = "Aucune heure positive trouvée.";
    else td.textContent = "Aucune donnée.";

    tr.appendChild(td);
    tbody.appendChild(tr);
  }
}

/* ========= FILTRE UI (All / Negative / Positif) ========= */
function applyPolarityFilter(){
  const sel = document.getElementById("polarityFilter").value; // all | negative | positive
  const cards = Array.from(document.querySelectorAll("#tables .card"));

  let shown = 0;
  for(const c of cards){
    const pol = c.dataset.polarity; // negative | positive | unknown
    let visible = true;

    if(sel === "negative") visible = (pol === "negative");
    else if(sel === "positive") visible = (pol === "positive");
    else visible = true; // all

    c.style.display = visible ? "" : "none";
    if(visible) shown++;
  }

  document.getElementById("shownCount").textContent = `Affichés: ${shown}/${cards.length}`;
}

/* ========= REFRESH MULTI ========= */
async function refreshMulti(){
  baseDateUtc = clampToFixedRange(baseDateUtc);

  const days = Math.max(1, Math.min(60, Number(document.getElementById("daysCount").value || 24)));

  const tablesWrap = document.getElementById("tables");
  tablesWrap.innerHTML = "";

  const maxDaysPossible = Math.floor((baseDateUtc.getTime() - RANGE_END_UTC.getTime()) / (24*60*60*1000)) + 1;
  const realDays = Math.min(days, maxDaysPossible);

  document.getElementById("rangeInfo").textContent =
    `Affiché : ${toFr(baseDateUtc)} → ${toFr(addDaysUtc(baseDateUtc, -(realDays-1)))} (UTC)`;

  document.getElementById("fixedInfo").textContent =
    `Fenêtre fixée : du ${toFr(RANGE_START_UTC)} au ${toFr(RANGE_END_UTC)} (inclus).`;

  const jobs = [];
  for(let i=0;i<realDays;i++){
    const d = addDaysUtc(baseDateUtc, -i);
    const obj = createTableCard(d);
    tablesWrap.appendChild(obj.card);

    jobs.push(
      fillTableForDate(d, obj.tbody, obj.status).catch(err=>{
        console.error(err);
        obj.tbody.innerHTML = `<tr><td colspan="2">Erreur</td></tr>`;
      })
    );
  }

  await Promise.all(jobs);

  // ✅ appliquer le filtre après génération
  applyPolarityFilter();
}

/* ========= NAVIGATION ========= */
document.querySelectorAll(".prevBtn").forEach(btn => {
  btn.addEventListener("click", async ()=>{
    baseDateUtc = addDaysUtc(baseDateUtc, -1);
    baseDateUtc = clampToFixedRange(baseDateUtc);
    document.querySelectorAll(".dateInput").forEach(x => x.value = toFr(baseDateUtc));
    await refreshMulti();
  });
});

document.querySelectorAll(".nextBtn").forEach(btn => {
  btn.addEventListener("click", async ()=>{
    baseDateUtc = addDaysUtc(baseDateUtc, 1);
    baseDateUtc = clampToFixedRange(baseDateUtc);
    document.querySelectorAll(".dateInput").forEach(x => x.value = toFr(baseDateUtc));
    await refreshMulti();
  });
});

document.querySelectorAll(".goDateBtn").forEach(btn => {
  btn.addEventListener("click", async ()=>{
    const wrap = btn.parentElement;
    const inp = wrap.querySelector(".dateInput");
    const dt = frToUtcDate(inp.value);

    if(!dt){
      alert("Date invalide. Utilise le format JJ/MM/AAAA (ex: 20/12/2025).");
      return;
    }

    baseDateUtc = clampToFixedRange(new Date(dt));
    document.querySelectorAll(".dateInput").forEach(x => x.value = toFr(baseDateUtc));

    await refreshMulti();
  });
});

document.querySelectorAll(".dateInput").forEach(inp => {
  inp.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      const btn = inp.parentElement.parentElement.querySelector(".goDateBtn");
      if(btn) btn.click();
    }
  });
});

document.getElementById("reloadBtn").addEventListener("click", refreshMulti);

// ✅ changer le filtre => cacher/montrer sans recharger l'API
document.getElementById("polarityFilter").addEventListener("change", applyPolarityFilter);

/* ========= INIT ========= */
document.querySelectorAll(".dateInput").forEach(x => x.value = toFr(baseDateUtc));
refreshMulti();
</script>

</body>
</html>
