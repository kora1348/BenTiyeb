<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Binance Futures — Variations bougie 22h00 (3 dates)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }
    h1{ margin:0 0 6px }
    p{ margin:0 0 14px; color:#444 }

    .card{
      margin: 12px 0 14px;
      padding: 14px;
      border-radius: 8px;
      background: white;
      box-shadow: 0 2px 5px rgba(0,0,0,.10);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .muted{ color:#666; font-size: 13px; }
    .progressWrap{
      width: 420px;
      max-width: 100%;
    }
    .bar{
      height: 12px;
      background:#e9e9e9;
      border-radius: 999px;
      overflow:hidden;
      border:1px solid #ddd;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: #4CAF50;
      transition: width .15s ease;
    }
    .pct{
      font-weight:700;
      min-width: 64px;
      text-align:right;
    }

    table{
      border-collapse: collapse;
      width: 100%;
      background: white;
      box-shadow: 0 2px 5px rgba(0,0,0,.10);
    }
    th, td{
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      white-space: nowrap;
    }
    th{
      background-color: #4CAF50;
      color: white;
      position: sticky;
      top: 0;
      z-index: 2;
    }
    tr:hover{ background-color: #f1f1f1; }
    .positive{ color: green; font-weight: 700; }
    .negative{ color: red; font-weight: 700; }
    .na{ color:#999; }
    .small{ font-size: 12px; }

    .pill{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background:#f0f0f0;
      border:1px solid #e3e3e3;
      font-size: 12px;
      color:#333;
    }

    .warn{
      background:#fff3cd;
      border:1px solid #ffe69c;
      color:#664d03;
      padding:10px 12px;
      border-radius:8px;
      font-size: 13px;
      margin-top:10px;
    }
  </style>
</head>
<body>
  <h1>Variations Futures — bougie 22h00 (Europe/Brussels)</h1>
  <p>Tableau auto: toutes les cryptos <b>USDT-M PERP</b> (Binance Futures) + variation (%) de la bougie 1h qui ouvre à 22h00.</p>

  <div class="card">
    <div class="row">
      <div>
        <div><b>Chargement automatique…</b></div>
        <div class="muted" id="statusLine">Initialisation</div>
        <div class="muted small" id="subLine"></div>
      </div>

      <div class="progressWrap">
        <div class="row" style="justify-content:space-between; margin-bottom:6px;">
          <span class="pill" id="countsPill">0 / 0</span>
          <span class="pct" id="pct">0%</span>
        </div>
        <div class="bar"><div id="barFill"></div></div>
      </div>
    </div>

    <div class="warn">
      ⚠️ Binance limite les requêtes. Le script gère un <b>concurrency</b> et des <b>retries</b>, mais ça peut rester un peu long selon le nombre de symboles.
    </div>
  </div>

  <table id="cryptoTable">
    <thead>
      <tr>
        <th>Crypto</th>
        <th>07/10/2025 — 22:00</th>
        <th>09/10/2025 — 22:00</th>
        <th>10/10/2025 — 22:00</th>
      </tr>
    </thead>
    <tbody id="tableBody"></tbody>
  </table>

<script>
/**
 * Interprétation des dates demandées:
 * - on considère "22h00" comme heure locale Europe/Brussels.
 * - en octobre 2025, Bruxelles est en heure d'été (CEST, UTC+2) jusqu'au 26/10/2025.
 * => 22:00 Brussels = 20:00 UTC.
 *
 * Si tu veux forcer UTC (au lieu de Brussels), mets USE_BRUSSELS_TZ = false.
 */
const USE_BRUSSELS_TZ = true;

// 3 dates à afficher
const TARGETS = [
  { key: "2025-10-07 22:00", label: "07/10/2025 — 22:00", y:2025, m:10, d:7,  hh:22, mm:0 },
  { key: "2025-10-09 22:00", label: "09/10/2025 — 22:00", y:2025, m:10, d:9,  hh:22, mm:0 },
  { key: "2025-10-10 22:00", label: "10/10/2025 — 22:00", y:2025, m:10, d:10, hh:22, mm:0 },
];

// futures exchangeInfo + klines endpoints
const EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo";
const KLINES_URL = "https://fapi.binance.com/fapi/v1/klines";

// réglages anti rate-limit
const CONCURRENCY = 10;       // augmente si tu veux (mais risque 429)
const RETRIES = 6;            // nb de retries par requête
const BASE_BACKOFF_MS = 450;  // backoff initial

// UI refs
const statusLine = document.getElementById("statusLine");
const subLine = document.getElementById("subLine");
const pctEl = document.getElementById("pct");
const barFill = document.getElementById("barFill");
const countsPill = document.getElementById("countsPill");
const tbody = document.getElementById("tableBody");

// progress tracking
let totalSymbols = 0;
let doneSymbols = 0;
let totalRequests = 0;
let doneRequests = 0;

function setStatus(main, sub=""){
  statusLine.textContent = main;
  subLine.textContent = sub;
}

function setProgress(){
  // on affiche un % basé sur "requêtes klines" (plus réaliste)
  const pct = totalRequests ? Math.min(100, Math.round((doneRequests / totalRequests) * 100)) : 0;
  pctEl.textContent = pct + "%";
  barFill.style.width = pct + "%";

  // on affiche aussi symbole traités
  countsPill.textContent = `${doneSymbols} / ${totalSymbols}`;
}

// util: sleep
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

// fetch avec retry/backoff (gère 429/418/5xx)
async function fetchJsonWithRetry(url, tries = RETRIES){
  let attempt = 0;
  while(true){
    try{
      const res = await fetch(url, { cache: "no-store" });

      // rate limit / ban protection (Binance peut répondre 418/429)
      if(!res.ok){
        const status = res.status;

        // retryable statuses
        if((status === 418 || status === 429 || status >= 500) && attempt < tries){
          const backoff = BASE_BACKOFF_MS * Math.pow(2, attempt) + Math.floor(Math.random()*250);
          attempt++;
          await sleep(backoff);
          continue;
        }
        throw new Error(`HTTP ${status} sur ${url}`);
      }

      return await res.json();
    }catch(err){
      if(attempt < tries){
        const backoff = BASE_BACKOFF_MS * Math.pow(2, attempt) + Math.floor(Math.random()*250);
        attempt++;
        await sleep(backoff);
        continue;
      }
      throw err;
    }
  }
}

// convertit la date cible (Brussels 22:00) en timestamp UTC (ms) pour startTime Binance
function toUtcMsForBinance(target){
  // target.m est 1..12
  // Si on veut Brussels: en octobre => UTC+2 -> on enlève 2h pour obtenir UTC
  const utcOffsetHours = USE_BRUSSELS_TZ ? 2 : 0;

  // Date.UTC attend mois 0..11
  const utcMs = Date.UTC(target.y, target.m - 1, target.d, target.hh - utcOffsetHours, target.mm, 0, 0);
  return utcMs;
}

function formatPct(x){
  if(x === null || Number.isNaN(x)) return "-";
  const v = Number(x);
  const s = (v >= 0 ? "+" : "") + v.toFixed(2) + "%";
  return s;
}

function tdWithValue(value){
  const td = document.createElement("td");
  if(value === null || Number.isNaN(value)){
    td.textContent = "-";
    td.className = "na";
    return td;
  }
  td.textContent = formatPct(value);
  td.className = value >= 0 ? "positive" : "negative";
  return td;
}

// récupère tous les symboles Futures USDT-M PERP "TRADING"
async function fetchAllUsdtPerpSymbols(){
  setStatus("Récupération des symboles Futures…");
  const info = await fetchJsonWithRetry(EXCHANGE_INFO_URL);

  // Binance futures exchangeInfo: info.symbols[]
  const syms = (info.symbols || [])
    .filter(s =>
      s.status === "TRADING" &&
      s.contractType === "PERPETUAL" &&
      s.quoteAsset === "USDT" &&
      s.symbol && s.symbol.endsWith("USDT")
    )
    .map(s => s.symbol)
    .sort((a,b) => a.localeCompare(b));

  return syms;
}

// récupère la bougie 1h qui ouvre à startTime (ms)
async function fetchOneHourCandle(symbol, startTimeMs){
  // interval=1h, limit=1, startTime exact
  const url = `${KLINES_URL}?symbol=${encodeURIComponent(symbol)}&interval=1h&startTime=${startTimeMs}&limit=1`;
  const data = await fetchJsonWithRetry(url);

  doneRequests++;
  setProgress();

  if(!Array.isArray(data) || !data.length) return null;
  const c = data[0];

  // kline fields: [ openTime, open, high, low, close, volume, closeTime, ...]
  const open = parseFloat(c[1]);
  const close = parseFloat(c[4]);
  if(!open || Number.isNaN(open) || Number.isNaN(close)) return null;

  const variation = ((close - open) / open) * 100;
  return variation;
}

// pool concurrency
async function runPool(items, worker, concurrency){
  let i = 0;
  const workers = new Array(concurrency).fill(0).map(async () => {
    while(i < items.length){
      const idx = i++;
      await worker(items[idx], idx);
    }
  });
  await Promise.all(workers);
}

function createRowPlaceholder(symbol){
  const tr = document.createElement("tr");
  tr.dataset.symbol = symbol;

  const tdName = document.createElement("td");
  tdName.textContent = symbol;
  tr.appendChild(tdName);

  // 3 colonnes initialement "-"
  for(let k=0;k<3;k++){
    const td = document.createElement("td");
    td.textContent = "…";
    td.className = "na";
    tr.appendChild(td);
  }

  tbody.appendChild(tr);
  return tr;
}

function updateRow(tr, values){
  // values length = 3
  for(let k=0;k<3;k++){
    tr.children[k+1].replaceWith(tdWithValue(values[k]));
  }
}

async function buildTable(){
  try{
    setStatus("Initialisation…");

    const symbols = await fetchAllUsdtPerpSymbols();
    totalSymbols = symbols.length;

    // total requêtes = nb symboles * 3 dates
    totalRequests = totalSymbols * TARGETS.length;
    doneSymbols = 0;
    doneRequests = 0;

    setStatus("Préparation du tableau…", `${totalSymbols} symboles détectés (USDT-M PERP)`);
    setProgress();

    // Créer toutes les lignes (placeholders) pour un rendu immédiat
    const rowMap = new Map();
    for(const s of symbols){
      rowMap.set(s, createRowPlaceholder(s));
    }

    setStatus("Chargement des bougies 1h…", "On calcule la variation (close-open) / open * 100 pour 22h00");

    // Pré-calcul des startTime (ms) pour les 3 dates
    const startTimes = TARGETS.map(t => toUtcMsForBinance(t));

    // Worker par symbole
    await runPool(symbols, async (symbol) => {
      const vals = [null,null,null];

      // 3 requêtes klines
      for(let k=0;k<TARGETS.length;k++){
        try{
          vals[k] = await fetchOneHourCandle(symbol, startTimes[k]);
        }catch(e){
          // Si un symbole échoue, on laisse "-"
          vals[k] = null;
        }
      }

      // update UI
      const tr = rowMap.get(symbol);
      updateRow(tr, vals);

      doneSymbols++;
      setProgress();
    }, CONCURRENCY);

    setStatus("Terminé ✅", `Bougies traitées: ${doneRequests}/${totalRequests}`);
    setProgress();
  }catch(err){
    console.error(err);
    setStatus("Erreur lors du chargement ❌", String(err.message || err));
  }
}

buildTable();
</script>
</body>
</html>
