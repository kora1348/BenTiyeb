<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Variation — Futures & Spot (Bougie 1D: 01:00 → 00:59)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root{
--bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#94a3b8;
--up:#16a34a; --down:#dc2626; --zero:#64748b; --border:#1f2937; --header:#0b1220; --accent:#2563eb;
--total:#facc15;
}
*{box-sizing:border-box}
body{margin:0;background:#0b1020;color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;padding:24px}
header{max-width:1200px;margin:0 auto 16px;display:flex;gap:12px;align-items:baseline;flex-wrap:wrap}
header h1{margin:0;font-size:20px;font-weight:700}
.meta{color:var(--muted);font-size:14px}
.controls{margin-left:auto;display:flex;gap:12px}
.controls button{background:var(--accent);border:0;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer;font-family:inherit;font-size:14px}
.controls button a{color:#fff;text-decoration:none}
.summary-cards{max-width:1200px;margin:0 auto 16px;display:flex;flex-direction:column;gap:12px}
.summary-card{
padding:12px 16px;border-radius:12px;font-size:14px;
border:1px solid var(--border);
}
#variation_negative{
background:linear-gradient(180deg,rgba(220,38,38,.1),rgba(220,38,38,.04)), var(--card);
border-color:rgba(220,38,38,.35);
color:#fecaca;
}
#spike_max{
background:linear-gradient(180deg,rgba(34,197,94,.1),rgba(34,197,94,.04)), var(--card);
border-color:rgba(34,197,94,.35);
color:#dcfce7;
}
#spike_min{
background:linear-gradient(180deg,rgba(59,130,246,.1),rgba(59,130,246,.04)), var(--card);
border-color:rgba(59,130,246,.35);
color:#dbeafe;
}
.summary-card .title{font-weight:700;margin-bottom:8px}
#variation_negative .title{color:#fca5a5}
#spike_max .title{color:#86efac}
#spike_min .title{color:#93c5fd}
.total-badges{display:flex;gap:10px;flex-wrap:wrap}
.total-badges .badge{
background:#1f2937;border:1px solid var(--border);border-radius:999px;
padding:4px 10px;color:#fff;font-weight:700
}
.total-badges .badge.positive{color:#22c55e}
.total-badges .badge.negative{color:#ef4444}
.total-badges .badge.zero{color:#94a3b8}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(520px,1fr));gap:16px;max-width:1200px;margin:0 auto}
.card{background:linear-gradient(180deg,rgba(255,255,255,.02),transparent),var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden}
.card header{background:var(--header);border-bottom:1px solid var(--border);padding:10px 12px;display:flex;gap:10px;align-items:center}
.symbol{font-weight:700;letter-spacing:.3px}
.status{margin-left:auto;font-size:12px;color:var(--muted)}
.table-wrap{max-height:70vh;overflow:auto}
table{width:100%;border-collapse:separate;border-spacing:0;font-variant-numeric:tabular-nums}
thead th{position:sticky;top:0;background:var(--header);border-bottom:1px solid var(--border);padding:6px 8px;font-size:12px;color:var(--muted);text-align:left}
thead th.num, tbody td.pct{text-align:right}
tbody td, tbody th{border-bottom:1px solid rgba(255,255,255,.06);padding:6px 8px;font-size:12px}
tbody td.time{color:var(--muted)}
.pct{font-weight:600}
.up{color:var(--up)} .down{color:var(--down)} .zero{color:var(--zero)}
.loading,.error{padding:10px 12px;border-top:1px solid var(--border);font-size:13px;color:var(--muted)}
.error{color:#fca5a5}
.chip{font-size:11px;font-weight:700;padding:2px 6px;border-radius:6px;border:1px solid var(--border);color:#94a3b8;margin-left:8px}
.info-banner{max-width:1200px;margin:0 auto 16px;padding:12px;background:rgba(59,130,246,0.1);border:1px solid rgba(59,130,246,0.3);border-radius:8px;color:#93c5fd;font-size:14px;}
</style>
</head>
<body>
<header>
<h1>Variation — Multi-symboles <span class="chip">Bougie 1D: 01:00 → 00:59</span> <span class="chip" id="chipInterval"></span></h1>
<div class="meta" id="metaLine"></div>
<div class="controls"><button id="reload"><a href="/index.html">Accueil</a></button></div>
</header>

<div class="info-banner">
✅ "n/a" = bougie indisponible ou symbole indisponible.<br/>
✅ API utilisée : <strong>Binance Futures (prioritaire) + Spot (fallback)</strong><br/>
✅ Ici on affiche <strong>2 périodes fusionnées</strong> (2 bougies 1D chacune) sur <strong>2 lignes</strong>.
</div>

<div class="summary-cards">
<div id="spike_max" class="summary-card">
<span class="title">TOTAL Spike max (mèche) — périodes fusionnées :</span>
<div id="total_spike_max" class="total-badges"></div>
</div>

<div id="spike_min" class="summary-card">
<span class="title">TOTAL Spike min (mèche) — périodes fusionnées :</span>
<div id="total_spike_min" class="total-badges"></div>
</div>

<div id="variation_negative" class="summary-card">
<span class="title">TOTAL (somme des variations de tous les symboles) — périodes fusionnées :</span>
<div id="total_variation" class="total-badges"></div>
</div>
</div>

<div id="grid" class="grid"></div>

<script>
(async () => {
function fmtPct(p){ return (p >= 0 ? '+' : '') + p.toFixed(3) + '%'; }
function clsPct(p){ return 'pct ' + (p > 0 ? 'up' : (p < 0 ? 'down' : 'zero')); }
function pad(n){ return String(n).padStart(2,'0'); }

const timeZone = "Europe/Brussels";
const INTERVAL = "1d";
document.getElementById('chipInterval').textContent = `Timeframe : ${INTERVAL}`;

const symbols = [
"AEVOUSDT","ARPAUSDT","AXLUSDT","DIAUSDT","EGLDUSDT","IDUSDT","RONINUSDT","WLDUSDT",
"1000SATSUSDT","1000LUNCUSDT","ANKRUSDT","DENTUSDT","ENJUSDT",
];

// ✅ 2 périodes fusionnées (chacune = 2 bougies 1D)
const FUSED_PERIODS = [
{ id:"P1", start:{ d:9, m:12, y:2025 }, days:2 }, // 09/12 -> 11/12
{ id:"P2", start:{ d:15, m:12, y:2025 }, days:2 }, // 15/12 -> 17/12
{ id:"P3", start:{ d:18, m:12, y:2025 }, days:2 }, // 15/12 -> 17/12
{ id:"P4", start:{ d:19, m:12, y:2025 }, days:2 }, // 15/12 -> 17/12
];

function tzOffsetMsAt(date, tz) {
const dtf = new Intl.DateTimeFormat('en-GB', {
timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
});
const parts = dtf.formatToParts(date);
const map = {};
for (const p of parts) map[p.type] = p.value;
const asUTC = Date.UTC(+map.year, +map.month-1, +map.day, +map.hour, +map.minute, +map.second);
return asUTC - date.getTime();
}

function localToUtcMs(y, m, d, hh, mm, ss, ms, tz) {
const approxUtc = Date.UTC(y, m-1, d, hh, mm, ss, ms);
const offset = tzOffsetMsAt(new Date(approxUtc), tz);
return approxUtc - offset;
}

function buildWindow(period){
const s = period.start;
const startUtc = localToUtcMs(s.y, s.m, s.d, 1, 0, 0, 0, timeZone);
const endUtc =
localToUtcMs(s.y, s.m, s.d + period.days, 0, 59, 0, 0, timeZone)
+ 60*1000 - 1;

const label = `${pad(s.d)}/${pad(s.m)}/${s.y} 01:00 → ${pad(s.d + period.days)}/${pad(s.m)}/${s.y} 00:59`;
const key = `${s.y}-${pad(s.m)}-${pad(s.d)}_F${period.days}_${period.id}`;

return { id: period.id, key, label, startUtc, endUtc, days: period.days };
}

const windows = FUSED_PERIODS.map(buildWindow);

(function renderHeaderMeta(){
const meta = document.getElementById('metaLine');
meta.innerHTML = `
${windows.length} périodes fusionnées • ${windows.map(w => `<strong>${w.label}</strong>`).join(' • ')}
• Timeframe : <strong>${INTERVAL}</strong> • API : <strong>Futures + Spot</strong>
• Fuseau : <strong>${timeZone}</strong>
`;
})();

const grid = document.getElementById('grid');
const totalsBar = document.getElementById('total_variation');
const totalsSpikeMaxBar = document.getElementById('total_spike_max');
const totalsSpikeMinBar = document.getElementById('total_spike_min');

function buildCard(symbol) {
const card = document.createElement('div');
card.className = 'card';

const head = document.createElement('header');
const symEl = document.createElement('div');
symEl.className = 'symbol';
symEl.textContent = symbol;

const status = document.createElement('div');
status.className = 'status';
status.textContent = 'Chargement…';

head.appendChild(symEl);
head.appendChild(status);

const wrap = document.createElement('div');
wrap.className = 'table-wrap';

const table = document.createElement('table');
const thead = document.createElement('thead');
thead.innerHTML = `
<tr>
<th>Période (Brussels)</th>
<th class="num">Variation (fusionnée)</th>
<th class="num">Spike max (fusionné)</th>
<th class="num">Spike min (fusionné)</th>
</tr>`;
const tbody = document.createElement('tbody');

for (const w of windows) {
const tr = document.createElement('tr');

const tdTime = document.createElement('td');
tdTime.className = 'time';
tdTime.textContent = w.label;

const tdVar = document.createElement('td');
tdVar.className = 'pct zero';
tdVar.textContent = '—';
tdVar.dataset.target = `${w.key}:var`;

const tdSpikeUp = document.createElement('td');
tdSpikeUp.className = 'pct zero';
tdSpikeUp.textContent = '—';
tdSpikeUp.dataset.target = `${w.key}:su`;

const tdSpikeDn = document.createElement('td');
tdSpikeDn.className = 'pct zero';
tdSpikeDn.textContent = '—';
tdSpikeDn.dataset.target = `${w.key}:sd`;

tr.appendChild(tdTime);
tr.appendChild(tdVar);
tr.appendChild(tdSpikeUp);
tr.appendChild(tdSpikeDn);
tbody.appendChild(tr);
}

table.appendChild(thead);
table.appendChild(tbody);
wrap.appendChild(table);

const loading = document.createElement('div');
loading.className = 'loading';
loading.textContent = `Requêtes klines ${INTERVAL}…`;

card.appendChild(head);
card.appendChild(wrap);
card.appendChild(loading);
grid.appendChild(card);

return { card, statusEl: status, loadingEl: loading, tbody };
}

function pctChange(open, close) {
const o = Number(open), c = Number(close);
if (!isFinite(o) || o === 0 || !isFinite(c)) return null;
return ((c - o) / o) * 100;
}

async function fetchKlines(symbol, startUtc, endUtc, limit) {
try {
const futuresUrl = new URL('https://fapi.binance.com/fapi/v1/klines');
futuresUrl.searchParams.set('symbol', symbol);
futuresUrl.searchParams.set('interval', INTERVAL);
futuresUrl.searchParams.set('startTime', String(startUtc));
futuresUrl.searchParams.set('endTime', String(endUtc));
futuresUrl.searchParams.set('limit', String(limit));

const res = await fetch(futuresUrl.toString());
if (!res.ok) throw new Error(`Futures API returned ${res.status}`);
const data = await res.json();
if (!Array.isArray(data)) throw new Error('Réponse inattendue Futures.');
return data;
} catch (e) {
try {
const spotUrl = new URL('https://api.binance.com/api/v3/klines');
spotUrl.searchParams.set('symbol', symbol);
spotUrl.searchParams.set('interval', INTERVAL);
spotUrl.searchParams.set('startTime', String(startUtc));
spotUrl.searchParams.set('endTime', String(endUtc));
spotUrl.searchParams.set('limit', String(limit));

const res = await fetch(spotUrl.toString());
if (!res.ok) throw new Error(`Spot API returned ${res.status}`);
const data = await res.json();
if (!Array.isArray(data)) throw new Error('Réponse inattendue Spot.');
return data;
} catch (e2) {
return [];
}
}
}

const cards = symbols.map(s => {
const built = buildCard(s);
const rowCells = {};
for (const w of windows) {
rowCells[`${w.key}:var`] = built.tbody.querySelector(`td[data-target="${w.key}:var"]`);
rowCells[`${w.key}:su`] = built.tbody.querySelector(`td[data-target="${w.key}:su"]`);
rowCells[`${w.key}:sd`] = built.tbody.querySelector(`td[data-target="${w.key}:sd"]`);
}
return { symbol: s, ...built, rowCells };
});

// Totaux par période
const totalsVar = new Map();
const totalsSpikeMax = new Map();
const totalsSpikeMin = new Map();
for (const w of windows) {
totalsVar.set(w.key, { sum:0, count:0 });
totalsSpikeMax.set(w.key, { sum:0, count:0 });
totalsSpikeMin.set(w.key, { sum:0, count:0 });
}

await Promise.allSettled(cards.map(async (c) => {
c.statusEl.textContent = 'Chargement…';
c.loadingEl.textContent = `Requêtes klines ${INTERVAL}…`;

try {
for (const w of windows) {
const kl = await fetchKlines(c.symbol, w.startUtc, w.endUtc, w.days);

let pVar = null, pSu = null, pSd = null;

if (kl.length >= 1) {
const first = kl[0];
const last = kl[kl.length - 1];

const open0 = Number(first[1]);
const closeL = Number(last[4]);

let highMax = -Infinity;
let lowMin = Infinity;

for (const candle of kl) {
const h = Number(candle[2]);
const l = Number(candle[3]);
if (isFinite(h)) highMax = Math.max(highMax, h);
if (isFinite(l)) lowMin = Math.min(lowMin, l);
}

if (isFinite(open0) && open0 !== 0 && isFinite(closeL)) {
pVar = pctChange(open0, closeL);
pSu = isFinite(highMax) ? ((highMax - open0) / open0) * 100 : null;
pSd = isFinite(lowMin) ? ((lowMin - open0) / open0) * 100 : null;
}
}

const cVar = c.rowCells[`${w.key}:var`];
const cSu = c.rowCells[`${w.key}:su`];
const cSd = c.rowCells[`${w.key}:sd`];

if (pVar === null) {
cVar.textContent = 'n/a';
cVar.className = 'pct zero';
cVar.title = `Période indisponible pour ${w.label}`;
} else {
cVar.textContent = fmtPct(pVar);
cVar.className = clsPct(pVar);
const tv = totalsVar.get(w.key);
tv.sum += pVar; tv.count += 1;
}

if (pSu === null) {
cSu.textContent = 'n/a';
cSu.className = 'pct zero';
cSu.title = `Période indisponible pour ${w.label}`;
} else {
cSu.textContent = fmtPct(pSu);
cSu.className = clsPct(pSu);
const tsu = totalsSpikeMax.get(w.key);
tsu.sum += pSu; tsu.count += 1;
}

if (pSd === null) {
cSd.textContent = 'n/a';
cSd.className = 'pct zero';
cSd.title = `Période indisponible pour ${w.label}`;
} else {
cSd.textContent = fmtPct(pSd);
cSd.className = clsPct(pSd);
const tsd = totalsSpikeMin.get(w.key);
tsd.sum += pSd; tsd.count += 1;
}
}

c.statusEl.textContent = 'OK';
c.loadingEl.textContent = 'Terminé. Données Futures/Spot.';
} catch (e) {
c.statusEl.textContent = 'Erreur';
c.loadingEl.className = 'error';
c.loadingEl.textContent = 'Échec: ' + (e?.message || e);
}
}));

function renderTotals(totalsMap, container) {
container.innerHTML = '';
for (const w of windows) {
const { sum, count } = totalsMap.get(w.key);
const badge = document.createElement('span');
badge.className = 'badge ' + (count === 0 ? 'zero' : (sum >= 0 ? 'positive' : 'negative'));
const txt = count === 0 ? 'n/a' : ((sum >= 0 ? '+' : '') + sum.toFixed(3) + '%');
badge.textContent = `${w.label} : ${txt}`;
badge.title = count > 0 ? `${count} symboles avec données` : 'Aucune donnée disponible';
container.appendChild(badge);
}
}

renderTotals(totalsVar, totalsBar);
renderTotals(totalsSpikeMax, totalsSpikeMaxBar);
renderTotals(totalsSpikeMin, totalsSpikeMinBar);

document.getElementById('reload').addEventListener('click', (e) => {
e.preventDefault();
location.reload();
});
})();
</script>
</body>
</html>