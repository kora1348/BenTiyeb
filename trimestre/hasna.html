<!doctype html> <html lang="fr"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width,initial-scale=1" /> <title>Vue Trimestrielle - Signaux Delta</title> <style> :root{ --bg:#fff; --text:#111; --muted:#666; --border:#e6e6e6; --header:#f5f5f5; --danger-bg:#ffe6e6; --danger-text:#b00020; --danger-border:#ffd1d1; --success-bg:#e6f9f0; --success-text:#0a7a2f; --success-border:#b7e5d4; } body{ margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; } .wrap{ width:90%; margin:24px auto 48px; } .header{ display:flex; align-items:center; justify-content:space-between; gap:16px; flex-wrap:wrap; margin-bottom:20px; padding-bottom:16px; border-bottom:2px solid var(--border); } h1{ font-size:22px; margin:0; font-weight:700; } .back-btn{ padding:10px 16px; background:#fff; border:2px solid var(--border); border-radius:10px; font-weight:700; font-size:13px; cursor:pointer; transition:all .2s; text-decoration:none; color:var(--text); display:inline-block; } .back-btn:hover{ background:#f5f5f5; border-color:var(--text); } .info-cards{ display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin-bottom:20px; } .info-card{ background:#fff; border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 2px 12px rgba(0,0,0,.04); } .info-card.red{ background:var(--danger-bg); border-color:var(--danger-border); } .info-card.green{ background:var(--success-bg); border-color:var(--success-border); } .info-card.both{ background: linear-gradient(135deg, var(--success-bg) 0%, var(--danger-bg) 100%); border: 2px solid; border-image: linear-gradient(135deg, var(--success-border) 0%, var(--danger-border) 100%); border-image-slice: 1; } .info-label{ font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.6px; margin-bottom:6px; } .info-value{ font-size:24px; font-weight:900; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; line-height:1.15; } .month-section{ margin-bottom:30px; } .month-title{ font-size:18px; font-weight:900; margin-bottom:12px; padding:10px 14px; background:#f8f9fa; border-radius:10px; border-left:4px solid var(--text); } .table-wrap{ border:1px solid var(--border); border-radius:14px; overflow:hidden; background:#fff; box-shadow:0 2px 12px rgba(0,0,0,.04); margin-bottom:20px; } .loadingbar-wrap{ padding:10px 12px; border-bottom:1px solid var(--border); background:#fff; } .loadingbar-top{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:8px; font-size:12px; color:var(--muted); } .bar{ height:10px; border-radius:999px; background:#f0f0f0; overflow:hidden; border:1px solid var(--border); } .bar > div{ height:100%; width:0%; background:#cfcfcf; transition:width .25s ease; } table{ width:100%; border-collapse:collapse; } thead th{ background:var(--header); font-size:12px; text-transform:uppercase; letter-spacing:.6px; padding:12px 10px; border-bottom:1px solid var(--border); text-align:left; position:sticky; top:0; z-index:1; } tbody td{ padding:10px; border-bottom:1px solid var(--border); font-size:13px; vertical-align:middle; } tbody tr:hover{ background:#fafafa; } .right{ text-align:right; font-variant-numeric:tabular-nums; } .mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; } .muted{ color:var(--muted); } .loading{ display:inline-flex; align-items:center; gap:8px; padding:40px; justify-content:center; } .dot{ width:8px; height:8px; border-radius:50%; background:#999; display:inline-block; animation:pulse 1s infinite ease-in-out; } .dot:nth-child(2){ animation-delay:.15s } .dot:nth-child(3){ animation-delay:.3s } @keyframes pulse{ 0%,100%{ transform:scale(.7); opacity:.5 } 50%{ transform:scale(1); opacity:1 } } .error-msg{ padding:20px; background:var(--danger-bg); border:1px solid var(--danger-border); border-radius:14px; color:var(--danger-text); text-align:center; } .note{ margin-top:16px; padding:12px; background:#f8f9fa; border-radius:10px; font-size:12px; color:var(--muted); line-height:1.5; } .signal-type-badge{ display:inline-block; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:900; margin-left:8px; } .signal-type-badge.long{ background:var(--success-text); color:#fff; } .signal-type-badge.short{ background:var(--danger-text); color:#fff; } .tabs{ display:flex; gap:8px; margin-bottom:16px; border-bottom:2px solid var(--border); padding-bottom:0; } .tab{ padding:12px 20px; background:transparent; border:none; border-bottom:3px solid transparent; font-weight:700; font-size:14px; cursor:pointer; transition:all .2s; color:var(--muted); } .tab:hover{ color:var(--text); background:#f5f5f5; } .tab.active{ color:var(--text); border-bottom-color:var(--text); } .tab.active.long{ border-bottom-color:var(--success-text); color:var(--success-text); } .tab.active.short{ border-bottom-color:var(--danger-text); color:var(--danger-text); } .tab-content{ display:none; } .tab-content.active{ display:block; } .row-click{ cursor:pointer; } .row-click:hover{ background:#fafafa; } </style> </head> <body> <div class="wrap"> <div class="header"> <div> <h1 id="pageTitle">Vue Trimestrielle - Analyse des Signaux</h1> </div> <a href="imane.html" class="back-btn">← Retour</a> </div> <div class="info-cards"> <div class="info-card" id="typeCard"> <div class="info-label">Type de Signal</div> <div class="info-value" id="signalType">—</div> </div> <div class="info-card"> <div class="info-label">Trimestre</div> <div class="info-value" id="quarterDisplay">—</div> </div> <div class="info-card" id="datesCardLong" style="display:none;"> <div class="info-label">Dates LONG (≥ 53)</div> <div class="info-value" id="datesCountLong">0</div> </div> <div class="info-card" id="datesCardShort" style="display:none;"> <div class="info-label">Dates SHORT (≥ 53)</div> <div class="info-value" id="datesCountShort">0</div> </div> </div> <div id="tabsContainer" style="display:none;"> <div class="tabs"> <button class="tab active long" id="tabLong"> Signaux LONG <span class="signal-type-badge long" id="badgeLong">0</span> </button> <button class="tab short" id="tabShort"> Signaux SHORT <span class="signal-type-badge short" id="badgeShort">0</span> </button> </div> </div> <!-- Tab Content for LONG --> <div id="contentLong" class="tab-content active"> <div id="monthsContainerLong"></div> </div> <!-- Tab Content for SHORT --> <div id="contentShort" class="tab-content"> <div id="monthsContainerShort"></div> </div> <div class="note"> <b>À propos de cette vue trimestrielle :</b><br/> - Cette page affiche les performances de 3 mois consécutifs pour le trimestre sélectionné.<br/> - <b>Q1</b> : Janvier, Février, Mars<br/> - <b>Q2</b> : Avril, Mai, Juin<br/> - <b>Q3</b> : Juillet, Août, Septembre<br/> - <b>Q4</b> : Octobre, Novembre, Décembre<br/> - Seules les dates avec un total de signaux ≥ 53 sont affichées.<br/> - <b>Signaux LONG (≤ -3)</b> : CoeffHier - CoeffAvantHier ≤ -3<br/> - <b>Signaux SHORT (≥ +3)</b> : CoeffHier - CoeffAvantHier ≥ +3<br/> - ✅ Cliquez sur une ligne pour ouvrir le détail dans hasna-4.html. </div> </div> <script> (() => { const PERP_BASE = "https://fapi.binance.com"; const QUOTE = "USDT"; const DAY_INTERVAL = "1d"; const WORKERS = 6; const DELAY_MS = 180; const MIN_SIGNALS = 53; const MONTHS_FR = ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"]; const DAYS_FR = ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"]; const pageTitleEl = document.getElementById("pageTitle"); const typeCardEl = document.getElementById("typeCard"); const signalTypeEl = document.getElementById("signalType"); const quarterDisplayEl = document.getElementById("quarterDisplay"); const datesCardLong = document.getElementById("datesCardLong"); const datesCardShort = document.getElementById("datesCardShort"); const datesCountLongEl = document.getElementById("datesCountLong"); const datesCountShortEl = document.getElementById("datesCountShort"); const tabsContainer = document.getElementById("tabsContainer"); const tabLong = document.getElementById("tabLong"); const tabShort = document.getElementById("tabShort"); const contentLong = document.getElementById("contentLong"); const contentShort = document.getElementById("contentShort"); const badgeLong = document.getElementById("badgeLong"); const badgeShort = document.getElementById("badgeShort"); const monthsContainerLong = document.getElementById("monthsContainerLong"); const monthsContainerShort = document.getElementById("monthsContainerShort"); const LISTING_CACHE_KEY = "binance_listing_cache_perp_v1"; const DAY_CLOSE_CACHE_NS = "binance_day_close_cache_perp_v1"; let quarterlyData = null; let symbols = []; let resultsLong = { month1: [], month2: [], month3: [] }; let resultsShort = { month1: [], month2: [], month3: [] }; let analyzeBothTypes = false; let progressState = { long: { done: 0, total: 0 }, short: { done: 0, total: 0 } }; function loadJSON(key, fallback) { try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); } catch { return fallback; } } function saveJSON(key, obj) { localStorage.setItem(key, JSON.stringify(obj)); } function fmtDateFR(d) { const dd = String(d.getUTCDate()).padStart(2, "0"); const mm = String(d.getUTCMonth() + 1).padStart(2, "0"); const yy = String(d.getUTCFullYear()); return ${dd}/${mm}/${yy}; } function ymdUTC(d) { const y = d.getUTCFullYear(); const m = String(d.getUTCMonth() + 1).padStart(2, "0"); const dd = String(d.getUTCDate()).padStart(2, "0"); return ${y}-${m}-${dd}; } function startOfDayUTC(d) { return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0, 0, 0, 0); } function addDaysUTC(d, delta) { return new Date(Date.UTC( d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + delta, 0, 0, 0, 0 )); } function signedCoeffInt(ref, price) { if (ref == null || price == null) return null; if (!isFinite(ref) || !isFinite(price) || ref <= 0 || price <= 0) return null; if (price >= ref) return +Math.round(price / ref); return -Math.round(ref / price); } async function fetchJSON(url) { const res = await fetch(url, { cache: "no-store" }); if (!res.ok) throw new Error(HTTP ${res.status}); return res.json(); } async function loadPerpSymbols() { const info = await fetchJSON(${PERP_BASE}/fapi/v1/exchangeInfo); return (info.symbols || []) .filter(s => s && s.status === "TRADING") .filter(s => s.quoteAsset === QUOTE) .filter(s => s.contractType === "PERPETUAL") .map(s => ({ id: PERP:${s.symbol}, symbol: s.symbol })); } async function fetchListing(symbol) { const url = ${PERP_BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=1d&startTime=0&limit=1; const data = await fetchJSON(url); if (!Array.isArray(data) || !data.length) return null; const k = data[0]; return { t: Number(k[0]), p: Number(k[1]) }; } async function fetchDayClose(symbol, dayStartUtcMs) { const start = dayStartUtcMs; const end = dayStartUtcMs + 24 * 60 * 60 * 1000 - 1; const url = ${PERP_BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${DAY_INTERVAL}&startTime=${start}&endTime=${end}&limit=1; const data = await fetchJSON(url); if (!Array.isArray(data) || !data.length) return null; const k = data[0]; return Number(k[4]); } function createLoadingBar(containerId, type, monthLabel) { const container = document.getElementById(containerId); const barId = loadingBar_${type}_${monthLabel.replace(/\s/g, '_')}; const doneId = done_${type}_${monthLabel.replace(/\s/g, '_')}; const totalId = total_${type}_${monthLabel.replace(/\s/g, '_')}; const pctId = pct_${type}_${monthLabel.replace(/\s/g, '_')}; const barFillId = barFill_${type}_${monthLabel.replace(/\s/g, '_')}; const html = <div class="loadingbar-wrap" id="${barId}"> <div class="loadingbar-top"> <div> <span>Analyse ${type.toUpperCase()} - ${monthLabel}:</span> <b><span id="${doneId}">0</span>/<span id="${totalId}">0</span></b> </div> <div class="mono"><span id="${pctId}">0%</span></div> </div> <div class="bar"><div id="${barFillId}"></div></div> </div> ; return { html, doneId, totalId, pctId, barFillId }; } function updateProgress(doneId, totalId, pctId, barFillId, done, total) { document.getElementById(doneId).textContent = String(done); document.getElementById(totalId).textContent = String(total); const p = total ? Math.round(done / total * 100) : 0; document.getElementById(pctId).textContent = p + "%"; document.getElementById(barFillId).style.width = p + "%"; } function updateBadges() { const totalLong = resultsLong.month1.length + resultsLong.month2.length + resultsLong.month3.length; const totalShort = resultsShort.month1.length + resultsShort.month2.length + resultsShort.month3.length; badgeLong.textContent = String(totalLong); badgeShort.textContent = String(totalShort); datesCountLongEl.textContent = String(totalLong); datesCountShortEl.textContent = String(totalShort); } function renderResults(type, monthIndex, results, monthName) { const monthKey = month${monthIndex + 1}; const containerId = type === 'long' ? 'monthsContainerLong' : 'monthsContainerShort'; const container = document.getElementById(containerId); const signalLabel = type === 'long' ? 'LONG' : 'SHORT'; const sectionId = section_${type}_${monthIndex}; const tbodyId = tbody_${type}_${monthIndex}; let sectionEl = document.getElementById(sectionId); if (!sectionEl) { const sectionHTML = <div class="month-section" id="${sectionId}"> <div class="month-title">${monthName} ${quarterlyData.year}</div> <div class="table-wrap"> <table> <thead> <tr> <th style="width:30%;">Date</th> <th class="right" style="width:20%;">Nombre de Signaux ${signalLabel}</th> <th style="width:50%;">Jour de la Semaine</th> </tr> </thead> <tbody id="${tbodyId}"> <tr><td colspan="3"> <div class="loading"> <span class="dot"></span> <span class="dot"></span> <span class="dot"></span> <span class="muted">Chargement…</span> </div> </td></tr> </tbody> </table> </div> </div> ; container.insertAdjacentHTML('beforeend', sectionHTML); } const tbody = document.getElementById(tbodyId); if (!results.length) { tbody.innerHTML = <tr><td colspan="3" class="muted">Aucune date avec un total ≥ ${MIN_SIGNALS} signaux ${signalLabel} trouvée pour ${monthName} ${quarterlyData.year}.</td></tr>; return; } tbody.innerHTML = results.map(r => { const dayName = DAYS_FR[r.date.getUTCDay()]; const depotDate = addDaysUTC(r.date, 1); const depotYmd = ymdUTC(depotDate); return <tr class="row-click" data-ymd="${depotYmd}" data-type="${type}"> <td class="mono"> <b>${fmtDateFR(depotDate)}</b> <span class="muted"> → Dépôt</span> </td> <td class="right mono"><b>${r.count}</b></td> <td>${dayName}</td> </tr> ; }).join(""); } async function analyzeDatesForMonth(type, monthIndex, monthName) { const isLong = (type === 'long'); const year = quarterlyData.year; const month = quarterlyData.months[monthIndex]; try { if (symbols.length === 0) { symbols = await loadPerpSymbols(); } const listingCache = loadJSON(LISTING_CACHE_KEY, {}); const dayCloseCache = loadJSON(DAY_CLOSE_CACHE_NS, {}); // Load listing prices if needed const symbolsWithoutListing = symbols.filter(s => !listingCache[s.id]); if (symbolsWithoutListing.length > 0) { let idx = 0; let done = 0; async function listingWorker() { while (idx < symbolsWithoutListing.length) { const s = symbolsWithoutListing[idx++]; await new Promise(res => setTimeout(res, DELAY_MS)); try { const info = await fetchListing(s.symbol); if (info) { listingCache[s.id] = { t: info.t, p: info.p }; saveJSON(LISTING_CACHE_KEY, listingCache); } } catch {} done++; } } await Promise.all(Array.from({ length: WORKERS }, () => listingWorker())); } const today = new Date(); const todayUTC = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate())); const lastDay = new Date(Date.UTC(year, month + 1, 0)); const daysInMonth = lastDay.getUTCDate(); const datesToAnalyze = []; for (let day = 1; day <= daysInMonth; day++) { const d = new Date(Date.UTC(year, month, day)); if (d <= todayUTC) datesToAnalyze.push(d); } const dateResults = []; for (let i = 0; i < datesToAnalyze.length; i++) { const date = datesToAnalyze[i]; const prev1 = addDaysUTC(date, -1); const prev2 = addDaysUTC(date, -2); const prev1Key = ymdUTC(prev1); const prev2Key = ymdUTC(prev2); dayCloseCache[prev1Key] = dayCloseCache[prev1Key] || {}; dayCloseCache[prev2Key] = dayCloseCache[prev2Key] || {}; let signalCount = 0; for (const s of symbols) { const listing = listingCache[s.id]; if (!listing || !listing.p) continue; let close_prev2 = dayCloseCache[prev2Key][s.id]; let close_prev1 = dayCloseCache[prev1Key][s.id]; if (close_prev2 === undefined) { try { await new Promise(res => setTimeout(res, DELAY_MS)); close_prev2 = await fetchDayClose(s.symbol, startOfDayUTC(prev2)); dayCloseCache[prev2Key][s.id] = close_prev2; saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); } catch { close_prev2 = null; dayCloseCache[prev2Key][s.id] = null; } } if (close_prev1 === undefined) { try { await new Promise(res => setTimeout(res, DELAY_MS)); close_prev1 = await fetchDayClose(s.symbol, startOfDayUTC(prev1)); dayCloseCache[prev1Key][s.id] = close_prev1; saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); } catch { close_prev1 = null; dayCloseCache[prev1Key][s.id] = null; } } const coeff_prev2 = signedCoeffInt(listing.p, close_prev2); const coeff_prev1 = signedCoeffInt(listing.p, close_prev1); if (coeff_prev2 !== null && coeff_prev1 !== null) { const delta = coeff_prev1 - coeff_prev2; if (isLong && delta <= -3) signalCount++; if (!isLong && delta >= 3) signalCount++; } } if (signalCount >= MIN_SIGNALS) { dateResults.push({ date, count: signalCount }); } } dateResults.sort((a, b) => b.date.getTime() - a.date.getTime()); if (isLong) { resultsLong[month${monthIndex + 1}] = dateResults; } else { resultsShort[month${monthIndex + 1}] = dateResults; } renderResults(type, monthIndex, dateResults, monthName); updateBadges(); } catch (e) { console.error(e); const tbodyId = tbody_${type}_${monthIndex}; const tbody = document.getElementById(tbodyId); if (tbody) { tbody.innerHTML = <tr><td colspan="3" class="error-msg">Erreur lors du chargement des données: ${e.message}</td></tr>; } } } async function analyzeQuarter(type) { const isLong = (type === 'long'); const monthNames = quarterlyData.months.map(m => MONTHS_FR[m]); for (let i = 0; i < 3; i++) { await analyzeDatesForMonth(type, i, monthNames[i]); } } document.addEventListener("click", async (e) => { const row = e.target.closest(".row-click"); if (!row) return; const ymd = row.getAttribute("data-ymd"); const type = row.getAttribute("data-type"); if (!ymd || !type) return; try { const [Y, M, D] = ymd.split("-").map(n => parseInt(n, 10)); const clickedDate = new Date(Date.UTC(Y, M - 1, D)); const refDate = addDaysUTC(clickedDate, -1); const listingCache = loadJSON(LISTING_CACHE_KEY, {}); const dayCloseCache = loadJSON(DAY_CLOSE_CACHE_NS, {}); const prev1 = addDaysUTC(clickedDate, -1); const prev2 = addDaysUTC(clickedDate, -2); const prev1Key = ymdUTC(prev1); const prev2Key = ymdUTC(prev2); dayCloseCache[prev1Key] = dayCloseCache[prev1Key] || {}; dayCloseCache[prev2Key] = dayCloseCache[prev2Key] || {}; const pickedSymbols = []; for (const s of symbols) { const listing = listingCache[s.id]; if (!listing || !listing.p) continue; let close_prev2 = dayCloseCache[prev2Key][s.id]; let close_prev1 = dayCloseCache[prev1Key][s.id]; if (close_prev2 === undefined) { try { await new Promise(res => setTimeout(res, DELAY_MS)); close_prev2 = await fetchDayClose(s.symbol, startOfDayUTC(prev2)); dayCloseCache[prev2Key][s.id] = close_prev2; saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); } catch { close_prev2 = null; dayCloseCache[prev2Key][s.id] = null; } } if (close_prev1 === undefined) { try { await new Promise(res => setTimeout(res, DELAY_MS)); close_prev1 = await fetchDayClose(s.symbol, startOfDayUTC(prev1)); dayCloseCache[prev1Key][s.id] = close_prev1; saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); } catch { close_prev1 = null; dayCloseCache[prev1Key][s.id] = null; } } const coeff_prev2 = signedCoeffInt(listing.p, close_prev2); const coeff_prev1 = signedCoeffInt(listing.p, close_prev1); if (coeff_prev2 !== null && coeff_prev1 !== null) { const delta = coeff_prev1 - coeff_prev2; if (type === "long" && delta <= -3) pickedSymbols.push(s.symbol); if (type === "short" && delta >= 3) pickedSymbols.push(s.symbol); } } saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); const visualizationData = { type: type, date: fmtDateFR(refDate), data: pickedSymbols.map(sym => ({ symbol: sym })) }; localStorage.setItem("visualizationData", JSON.stringify(visualizationData)); window.location.href = "hasna-4.html"; } catch (err) { console.error(err); alert(Erreur: ${err.message || err}); } }); tabLong.addEventListener("click", () => { tabLong.classList.add("active"); tabShort.classList.remove("active"); contentLong.classList.add("active"); contentShort.classList.remove("active"); }); tabShort.addEventListener("click", () => { tabShort.classList.add("active"); tabLong.classList.remove("active"); contentShort.classList.add("active"); contentLong.classList.remove("active"); }); async function init() { try { const dataStr = localStorage.getItem("quarterlyViewData"); if (!dataStr) { monthsContainerLong.innerHTML = <div class="error-msg">Aucune donnée disponible. Veuillez retourner à la page principale.</div>; return; } quarterlyData = JSON.parse(dataStr); quarterDisplayEl.textContent = ${quarterlyData.quarterLabel} ${quarterlyData.year}; const monthNames = quarterlyData.months.map(m => MONTHS_FR[m]); if (quarterlyData.type === "both") { analyzeBothTypes = true; typeCardEl.classList.add("both"); signalTypeEl.innerHTML = LONG (≤ -3) + SHORT (≥ +3); pageTitleEl.textContent = Vue Trimestrielle - Analyse Complète des Signaux; tabsContainer.style.display = "block"; datesCardLong.style.display = "block"; datesCardShort.style.display = "block"; await Promise.all([ analyzeQuarter('long'), analyzeQuarter('short') ]); } else if (quarterlyData.type === "long") { typeCardEl.classList.add("green"); signalTypeEl.textContent = "Delta ≤ -3 (LONG)"; pageTitleEl.textContent = Vue Trimestrielle - Signaux LONG; datesCardLong.style.display = "block"; await analyzeQuarter('long'); } else { typeCardEl.classList.add("red"); signalTypeEl.textContent = "Delta ≥ +3 (SHORT)"; pageTitleEl.textContent = Vue Trimestrielle - Signaux SHORT; datesCardShort.style.display = "block"; tabsContainer.style.display = "none"; contentLong.style.display = "none"; contentShort.classList.add("active"); await analyzeQuarter('short'); } } catch (e) { console.error(e); monthsContainerLong.innerHTML = <div class="error-msg">Erreur lors du chargement des données: ${e.message}</div>; } } init(); })(); </script> </body> </html> UN AUTRE code quand c'est mensiuel ça marche super bien <!doctype html> <html lang="fr"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width,initial-scale=1" /> <title>Vue Mensuelle - Signaux Delta</title> <style> :root{ --bg:#fff; --text:#111; --muted:#666; --border:#e6e6e6; --header:#f5f5f5; --danger-bg:#ffe6e6; --danger-text:#b00020; --danger-border:#ffd1d1; --success-bg:#e6f9f0; --success-text:#0a7a2f; --success-border:#b7e5d4; } body{ margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; } .wrap{ width:90%; margin:24px auto 48px; } .header{ display:flex; align-items:center; justify-content:space-between; gap:16px; flex-wrap:wrap; margin-bottom:20px; padding-bottom:16px; border-bottom:2px solid var(--border); } h1{ font-size:22px; margin:0; font-weight:700; } .back-btn{ padding:10px 16px; background:#fff; border:2px solid var(--border); border-radius:10px; font-weight:700; font-size:13px; cursor:pointer; transition:all .2s; text-decoration:none; color:var(--text); display:inline-block; } .back-btn:hover{ background:#f5f5f5; border-color:var(--text); } .info-cards{ display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin-bottom:20px; } .info-card{ background:#fff; border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 2px 12px rgba(0,0,0,.04); } .info-card.red{ background:var(--danger-bg); border-color:var(--danger-border); } .info-card.green{ background:var(--success-bg); border-color:var(--success-border); } .info-card.both{ background: linear-gradient(135deg, var(--success-bg) 0%, var(--danger-bg) 100%); border: 2px solid; border-image: linear-gradient(135deg, var(--success-border) 0%, var(--danger-border) 100%); border-image-slice: 1; } .info-label{ font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.6px; margin-bottom:6px; } .info-value{ font-size:24px; font-weight:900; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; line-height:1.15; } .table-wrap{ border:1px solid var(--border); border-radius:14px; overflow:hidden; background:#fff; box-shadow:0 2px 12px rgba(0,0,0,.04); margin-bottom:20px; } .loadingbar-wrap{ padding:10px 12px; border-bottom:1px solid var(--border); background:#fff; } .loadingbar-top{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:8px; font-size:12px; color:var(--muted); } .bar{ height:10px; border-radius:999px; background:#f0f0f0; overflow:hidden; border:1px solid var(--border); } .bar > div{ height:100%; width:0%; background:#cfcfcf; transition:width .25s ease; } table{ width:100%; border-collapse:collapse; } thead th{ background:var(--header); font-size:12px; text-transform:uppercase; letter-spacing:.6px; padding:12px 10px; border-bottom:1px solid var(--border); text-align:left; position:sticky; top:0; z-index:1; } tbody td{ padding:10px; border-bottom:1px solid var(--border); font-size:13px; vertical-align:middle; } tbody tr:hover{ background:#fafafa; } .right{ text-align:right; font-variant-numeric:tabular-nums; } .mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; } .muted{ color:var(--muted); } .loading{ display:inline-flex; align-items:center; gap:8px; padding:40px; justify-content:center; } .dot{ width:8px; height:8px; border-radius:50%; background:#999; display:inline-block; animation:pulse 1s infinite ease-in-out; } .dot:nth-child(2){ animation-delay:.15s } .dot:nth-child(3){ animation-delay:.3s } @keyframes pulse{ 0%,100%{ transform:scale(.7); opacity:.5 } 50%{ transform:scale(1); opacity:1 } } .error-msg{ padding:20px; background:var(--danger-bg); border:1px solid var(--danger-border); border-radius:14px; color:var(--danger-text); text-align:center; } .note{ margin-top:16px; padding:12px; background:#f8f9fa; border-radius:10px; font-size:12px; color:var(--muted); line-height:1.5; } .signal-type-badge{ display:inline-block; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:900; margin-left:8px; } .signal-type-badge.long{ background:var(--success-text); color:#fff; } .signal-type-badge.short{ background:var(--danger-text); color:#fff; } .tabs{ display:flex; gap:8px; margin-bottom:16px; border-bottom:2px solid var(--border); padding-bottom:0; } .tab{ padding:12px 20px; background:transparent; border:none; border-bottom:3px solid transparent; font-weight:700; font-size:14px; cursor:pointer; transition:all .2s; color:var(--muted); } .tab:hover{ color:var(--text); background:#f5f5f5; } .tab.active{ color:var(--text); border-bottom-color:var(--text); } .tab.active.long{ border-bottom-color:var(--success-text); color:var(--success-text); } .tab.active.short{ border-bottom-color:var(--danger-text); color:var(--danger-text); } .tab-content{ display:none; } .tab-content.active{ display:block; } .row-click{ cursor:pointer; } .row-click:hover{ background:#fafafa; } </style> </head> <body> <div class="wrap"> <div class="header"> <div> <h1 id="pageTitle">Vue Mensuelle - Analyse des Signaux</h1> </div> <a href="imane.html" class="back-btn">← Retour</a> </div> <div class="info-cards"> <div class="info-card" id="typeCard"> <div class="info-label">Type de Signal</div> <div class="info-value" id="signalType">—</div> </div> <div class="info-card"> <div class="info-label">Mois</div> <div class="info-value" id="monthDisplay">—</div> </div> <div class="info-card" id="datesCardLong" style="display:none;"> <div class="info-label">Dates LONG (≥ 53)</div> <div class="info-value" id="datesCountLong">0</div> </div> <div class="info-card" id="datesCardShort" style="display:none;"> <div class="info-label">Dates SHORT (≥ 53)</div> <div class="info-value" id="datesCountShort">0</div> </div> </div> <div id="tabsContainer" style="display:none;"> <div class="tabs"> <button class="tab active long" id="tabLong"> Signaux LONG <span class="signal-type-badge long" id="badgeLong">0</span> </button> <button class="tab short" id="tabShort"> Signaux SHORT <span class="signal-type-badge short" id="badgeShort">0</span> </button> </div> </div> <!-- Tab Content for LONG --> <div id="contentLong" class="tab-content active"> <div class="table-wrap"> <div class="loadingbar-wrap" id="loadingBarLong" style="display:none;"> <div class="loadingbar-top"> <div> <span id="loadingLabelLong">Analyse LONG en cours:</span> <b><span id="doneLong">0</span>/<span id="totalLong">0</span></b> </div> <div class="mono"><span id="pctLong">0%</span></div> </div> <div class="bar"><div id="barFillLong"></div></div> </div> <table> <thead> <tr> <th style="width:30%;">Date</th> <th class="right" style="width:20%;">Nombre de Signaux LONG</th> <th style="width:50%;">Jour de la Semaine</th> </tr> </thead> <tbody id="tbodyLong"> <tr><td colspan="3"> <div class="loading"> <span class="dot"></span> <span class="dot"></span> <span class="dot"></span> <span class="muted">Chargement…</span> </div> </td></tr> </tbody> </table> </div> </div> <!-- Tab Content for SHORT --> <div id="contentShort" class="tab-content"> <div class="table-wrap"> <div class="loadingbar-wrap" id="loadingBarShort" style="display:none;"> <div class="loadingbar-top"> <div> <span id="loadingLabelShort">Analyse SHORT en cours:</span> <b><span id="doneShort">0</span>/<span id="totalShort">0</span></b> </div> <div class="mono"><span id="pctShort">0%</span></div> </div> <div class="bar"><div id="barFillShort"></div></div> </div> <table> <thead> <tr> <th style="width:30%;">Date</th> <th class="right" style="width:20%;">Nombre de Signaux SHORT</th> <th style="width:50%;">Jour de la Semaine</th> </tr> </thead> <tbody id="tbodyShort"> <tr><td colspan="3"> <div class="loading"> <span class="dot"></span> <span class="dot"></span> <span class="dot"></span> <span class="muted">Chargement…</span> </div> </td></tr> </tbody> </table> </div> </div> <div class="note"> <b>À propos de cette vue :</b><br/> - Cette page affiche toutes les dates d'un mois où le nombre total de signaux delta est supérieur ou égal à 53.<br/> - <b>Signaux LONG (≤ -3)</b> : CoeffHier - CoeffAvantHier ≤ -3<br/> - <b>Signaux SHORT (≥ +3)</b> : CoeffHier - CoeffAvantHier ≥ +3<br/> - Seules les dates passées sont analysées (pas de dates futures).<br/> - Les données sont récupérées depuis le cache si disponibles, sinon elles sont chargées depuis l'API Binance.<br/> - ✅ Cliquez sur une ligne pour ouvrir le détail dans imane-4.html. </div> </div> <script> (() => { const PERP_BASE = "https://fapi.binance.com"; const QUOTE = "USDT"; const DAY_INTERVAL = "1d"; const WORKERS = 6; const DELAY_MS = 180; const MIN_SIGNALS = 53; const DAYS_FR = ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"]; const tbodyLong = document.getElementById("tbodyLong"); const tbodyShort = document.getElementById("tbodyShort"); const pageTitleEl = document.getElementById("pageTitle"); const typeCardEl = document.getElementById("typeCard"); const signalTypeEl = document.getElementById("signalType"); const monthDisplayEl = document.getElementById("monthDisplay"); const datesCardLong = document.getElementById("datesCardLong"); const datesCardShort = document.getElementById("datesCardShort"); const datesCountLongEl = document.getElementById("datesCountLong"); const datesCountShortEl = document.getElementById("datesCountShort"); const tabsContainer = document.getElementById("tabsContainer"); const tabLong = document.getElementById("tabLong"); const tabShort = document.getElementById("tabShort"); const contentLong = document.getElementById("contentLong"); const contentShort = document.getElementById("contentShort"); const badgeLong = document.getElementById("badgeLong"); const badgeShort = document.getElementById("badgeShort"); const loadingBarLongEl = document.getElementById("loadingBarLong"); const loadingLabelLongEl = document.getElementById("loadingLabelLong"); const doneLongEl = document.getElementById("doneLong"); const totalLongEl = document.getElementById("totalLong"); const pctLongEl = document.getElementById("pctLong"); const barFillLongEl = document.getElementById("barFillLong"); const loadingBarShortEl = document.getElementById("loadingBarShort"); const loadingLabelShortEl = document.getElementById("loadingLabelShort"); const doneShortEl = document.getElementById("doneShort"); const totalShortEl = document.getElementById("totalShort"); const pctShortEl = document.getElementById("pctShort"); const barFillShortEl = document.getElementById("barFillShort"); const LISTING_CACHE_KEY = "binance_listing_cache_perp_v1"; const DAY_CLOSE_CACHE_NS = "binance_day_close_cache_perp_v1"; let monthlyData = null; let symbols = []; let resultsLong = []; let resultsShort = []; let analyzeBothTypes = false; function loadJSON(key, fallback) { try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); } catch { return fallback; } } function saveJSON(key, obj) { localStorage.setItem(key, JSON.stringify(obj)); } function fmtDateFR(d) { const dd = String(d.getUTCDate()).padStart(2, "0"); const mm = String(d.getUTCMonth() + 1).padStart(2, "0"); const yy = String(d.getUTCFullYear()); return ${dd}/${mm}/${yy}; } function ymdUTC(d) { const y = d.getUTCFullYear(); const m = String(d.getUTCMonth() + 1).padStart(2, "0"); const dd = String(d.getUTCDate()).padStart(2, "0"); return ${y}-${m}-${dd}; } function startOfDayUTC(d) { return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0, 0, 0, 0); } function addDaysUTC(d, delta) { return new Date(Date.UTC( d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + delta, 0, 0, 0, 0 )); } function signedCoeffInt(ref, price) { if (ref == null || price == null) return null; if (!isFinite(ref) || !isFinite(price) || ref <= 0 || price <= 0) return null; if (price >= ref) return +Math.round(price / ref); return -Math.round(ref / price); } async function fetchJSON(url) { const res = await fetch(url, { cache: "no-store" }); if (!res.ok) throw new Error(HTTP ${res.status}); return res.json(); } async function loadPerpSymbols() { const info = await fetchJSON(${PERP_BASE}/fapi/v1/exchangeInfo); return (info.symbols || []) .filter(s => s && s.status === "TRADING") .filter(s => s.quoteAsset === QUOTE) .filter(s => s.contractType === "PERPETUAL") .map(s => ({ id: PERP:${s.symbol}, symbol: s.symbol })); } async function fetchListing(symbol) { const url = ${PERP_BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=1d&startTime=0&limit=1; const data = await fetchJSON(url); if (!Array.isArray(data) || !data.length) return null; const k = data[0]; return { t: Number(k[0]), p: Number(k[1]) }; } async function fetchDayClose(symbol, dayStartUtcMs) { const start = dayStartUtcMs; const end = dayStartUtcMs + 24 * 60 * 60 * 1000 - 1; const url = ${PERP_BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${DAY_INTERVAL}&startTime=${start}&endTime=${end}&limit=1; const data = await fetchJSON(url); if (!Array.isArray(data) || !data.length) return null; const k = data[0]; return Number(k[4]); } function updateProgress(type, done, total) { if (type === 'long') { doneLongEl.textContent = String(done); totalLongEl.textContent = String(total); const p = total ? Math.round(done / total * 100) : 0; pctLongEl.textContent = p + "%"; barFillLongEl.style.width = p + "%"; } else { doneShortEl.textContent = String(done); totalShortEl.textContent = String(total); const p = total ? Math.round(done / total * 100) : 0; pctShortEl.textContent = p + "%"; barFillShortEl.style.width = p + "%"; } } function updateBadges() { badgeLong.textContent = String(resultsLong.length); badgeShort.textContent = String(resultsShort.length); } function renderResults(type, results) { const tbody = type === 'long' ? tbodyLong : tbodyShort; const signalLabel = type === 'long' ? 'LONG' : 'SHORT'; if (!results.length) { tbody.innerHTML = <tr><td colspan="3" class="muted">Aucune date avec un total ≥ ${MIN_SIGNALS} signaux ${signalLabel} trouvée pour ce mois.</td></tr>; return; } tbody.innerHTML = results.map(r => { const dayName = DAYS_FR[r.date.getUTCDay()]; const depotDate = addDaysUTC(r.date, 1); const depotYmd = ymdUTC(depotDate); return <tr class="row-click" data-ymd="${depotYmd}" data-type="${type}"> <td class="mono"> <b>${fmtDateFR(depotDate)}</b> <span class="muted"> → Dépôt</span> </td> <td class="right mono"><b>${r.count}</b></td> <td>${dayName}</td> </tr> ; }).join(""); } async function analyzeDatesForType(type) { const isLong = (type === 'long'); const loadingBar = isLong ? loadingBarLongEl : loadingBarShortEl; const loadingLabel = isLong ? loadingLabelLongEl : loadingLabelShortEl; try { loadingBar.style.display = "block"; loadingLabel.textContent = Chargement des symboles...; if (symbols.length === 0) { symbols = await loadPerpSymbols(); } const listingCache = loadJSON(LISTING_CACHE_KEY, {}); const dayCloseCache = loadJSON(DAY_CLOSE_CACHE_NS, {}); loadingLabel.textContent = "Chargement des prix de listing..."; const symbolsWithoutListing = symbols.filter(s => !listingCache[s.id]); if (symbolsWithoutListing.length > 0) { updateProgress(type, 0, symbolsWithoutListing.length); let idx = 0; let done = 0; async function listingWorker() { while (idx < symbolsWithoutListing.length) { const s = symbolsWithoutListing[idx++]; await new Promise(res => setTimeout(res, DELAY_MS)); try { const info = await fetchListing(s.symbol); if (info) { listingCache[s.id] = { t: info.t, p: info.p }; saveJSON(LISTING_CACHE_KEY, listingCache); } } catch {} done++; updateProgress(type, done, symbolsWithoutListing.length); } } await Promise.all(Array.from({ length: WORKERS }, () => listingWorker())); } const year = monthlyData.year; const month = monthlyData.month; const today = new Date(); const todayUTC = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate())); const lastDay = new Date(Date.UTC(year, month + 1, 0)); const daysInMonth = lastDay.getUTCDate(); const datesToAnalyze = []; for (let day = 1; day <= daysInMonth; day++) { const d = new Date(Date.UTC(year, month, day)); if (d <= todayUTC) datesToAnalyze.push(d); } loadingLabel.textContent = Analyse de ${datesToAnalyze.length} dates (${type.toUpperCase()})...; updateProgress(type, 0, datesToAnalyze.length); const dateResults = []; for (let i = 0; i < datesToAnalyze.length; i++) { const date = datesToAnalyze[i]; const prev1 = addDaysUTC(date, -1); const prev2 = addDaysUTC(date, -2); const prev1Key = ymdUTC(prev1); const prev2Key = ymdUTC(prev2); dayCloseCache[prev1Key] = dayCloseCache[prev1Key] || {}; dayCloseCache[prev2Key] = dayCloseCache[prev2Key] || {}; let signalCount = 0; for (const s of symbols) { const listing = listingCache[s.id]; if (!listing || !listing.p) continue; let close_prev2 = dayCloseCache[prev2Key][s.id]; let close_prev1 = dayCloseCache[prev1Key][s.id]; if (close_prev2 === undefined) { try { await new Promise(res => setTimeout(res, DELAY_MS)); close_prev2 = await fetchDayClose(s.symbol, startOfDayUTC(prev2)); dayCloseCache[prev2Key][s.id] = close_prev2; saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); } catch { close_prev2 = null; dayCloseCache[prev2Key][s.id] = null; } } if (close_prev1 === undefined) { try { await new Promise(res => setTimeout(res, DELAY_MS)); close_prev1 = await fetchDayClose(s.symbol, startOfDayUTC(prev1)); dayCloseCache[prev1Key][s.id] = close_prev1; saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); } catch { close_prev1 = null; dayCloseCache[prev1Key][s.id] = null; } } const coeff_prev2 = signedCoeffInt(listing.p, close_prev2); const coeff_prev1 = signedCoeffInt(listing.p, close_prev1); if (coeff_prev2 !== null && coeff_prev1 !== null) { const delta = coeff_prev1 - coeff_prev2; if (isLong && delta <= -3) signalCount++; if (!isLong && delta >= 3) signalCount++; } } if (signalCount >= MIN_SIGNALS) { dateResults.push({ date, count: signalCount }); } updateProgress(type, i + 1, datesToAnalyze.length); } dateResults.sort((a, b) => b.date.getTime() - a.date.getTime()); if (isLong) { resultsLong = dateResults; datesCountLongEl.textContent = String(resultsLong.length); } else { resultsShort = dateResults; datesCountShortEl.textContent = String(resultsShort.length); } updateBadges(); loadingBar.style.display = "none"; renderResults(type, dateResults); } catch (e) { console.error(e); const tbody = isLong ? tbodyLong : tbodyShort; tbody.innerHTML = <tr><td colspan="3" class="error-msg">Erreur lors du chargement des données: ${e.message}</td></tr>; loadingBar.style.display = "none"; } } document.addEventListener("click", async (e) => { const row = e.target.closest(".row-click"); if (!row) return; const ymd = row.getAttribute("data-ymd"); const type = row.getAttribute("data-type"); if (!ymd || !type) return; try { const [Y, M, D] = ymd.split("-").map(n => parseInt(n, 10)); const clickedDate = new Date(Date.UTC(Y, M - 1, D)); const refDate = addDaysUTC(clickedDate, -1); const tbody = type === 'long' ? tbodyLong : tbodyShort; tbody.innerHTML = <tr><td colspan="3" class="muted">Préparation du détail pour ${fmtDateFR(clickedDate)}…</td></tr>; const listingCache = loadJSON(LISTING_CACHE_KEY, {}); const dayCloseCache = loadJSON(DAY_CLOSE_CACHE_NS, {}); const prev1 = addDaysUTC(clickedDate, -1); const prev2 = addDaysUTC(clickedDate, -2); const prev1Key = ymdUTC(prev1); const prev2Key = ymdUTC(prev2); dayCloseCache[prev1Key] = dayCloseCache[prev1Key] || {}; dayCloseCache[prev2Key] = dayCloseCache[prev2Key] || {}; const pickedSymbols = []; for (const s of symbols) { const listing = listingCache[s.id]; if (!listing || !listing.p) continue; let close_prev2 = dayCloseCache[prev2Key][s.id]; let close_prev1 = dayCloseCache[prev1Key][s.id]; if (close_prev2 === undefined) { try { await new Promise(res => setTimeout(res, DELAY_MS)); close_prev2 = await fetchDayClose(s.symbol, startOfDayUTC(prev2)); dayCloseCache[prev2Key][s.id] = close_prev2; saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); } catch { close_prev2 = null; dayCloseCache[prev2Key][s.id] = null; } } if (close_prev1 === undefined) { try { await new Promise(res => setTimeout(res, DELAY_MS)); close_prev1 = await fetchDayClose(s.symbol, startOfDayUTC(prev1)); dayCloseCache[prev1Key][s.id] = close_prev1; saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); } catch { close_prev1 = null; dayCloseCache[prev1Key][s.id] = null; } } const coeff_prev2 = signedCoeffInt(listing.p, close_prev2); const coeff_prev1 = signedCoeffInt(listing.p, close_prev1); if (coeff_prev2 !== null && coeff_prev1 !== null) { const delta = coeff_prev1 - coeff_prev2; if (type === "long" && delta <= -3) pickedSymbols.push(s.symbol); if (type === "short" && delta >= 3) pickedSymbols.push(s.symbol); } } saveJSON(DAY_CLOSE_CACHE_NS, dayCloseCache); const visualizationData = { type: type, date: fmtDateFR(refDate), data: pickedSymbols.map(sym => ({ symbol: sym })) }; localStorage.setItem("visualizationData", JSON.stringify(visualizationData)); window.location.href = "imane-4.html"; } catch (err) { console.error(err); const tbody = type === 'long' ? tbodyLong : tbodyShort; tbody.innerHTML = <tr><td colspan="3" class="error-msg">Erreur: ${err.message || err}</td></tr>; } }); tabLong.addEventListener("click", () => { tabLong.classList.add("active"); tabShort.classList.remove("active"); contentLong.classList.add("active"); contentShort.classList.remove("active"); }); tabShort.addEventListener("click", () => { tabShort.classList.add("active"); tabLong.classList.remove("active"); contentShort.classList.add("active"); contentLong.classList.remove("active"); }); async function init() { try { const dataStr = localStorage.getItem("monthlyViewData"); if (!dataStr) { tbodyLong.innerHTML = <tr><td colspan="3" class="error-msg">Aucune donnée disponible. Veuillez retourner à la page principale.</td></tr>; return; } monthlyData = JSON.parse(dataStr); monthDisplayEl.textContent = ${monthlyData.monthName} ${monthlyData.year}; if (monthlyData.type === "both") { analyzeBothTypes = true; typeCardEl.classList.add("both"); signalTypeEl.innerHTML = LONG (≤ -3) + SHORT (≥ +3); pageTitleEl.textContent = Vue Mensuelle - Analyse Complète des Signaux; tabsContainer.style.display = "block"; datesCardLong.style.display = "block"; datesCardShort.style.display = "block"; await Promise.all([ analyzeDatesForType('long'), analyzeDatesForType('short') ]); } else if (monthlyData.type === "long") { typeCardEl.classList.add("green"); signalTypeEl.textContent = "Delta ≤ -3 (LONG)"; pageTitleEl.textContent = Vue Mensuelle - Signaux LONG; datesCardLong.style.display = "block"; await analyzeDatesForType('long'); } else { typeCardEl.classList.add("red"); signalTypeEl.textContent = "Delta ≥ +3 (SHORT)"; pageTitleEl.textContent = Vue Mensuelle - Signaux SHORT; datesCardShort.style.display = "block"; tabsContainer.style.display = "none"; contentLong.style.display = "none"; contentShort.classList.add("active"); await analyzeDatesForType('short'); } } catch (e) { console.error(e); tbodyLong.innerHTML = <tr><td colspan="3" class="error-msg">Erreur lors du chargement des données: ${e.message}</td></tr>; } } init(); })(); </script> </body> </html>