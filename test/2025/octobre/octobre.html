<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Variations 1 day — Multi-jours (Europe/Brussels)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#94a3b8;
      --up:#16a34a; --down:#dc2626; --zero:#64748b; --border:#1f2937; --header:#0b1220; --accent:#2563eb;
    }
    *{box-sizing:border-box}
    body{margin:0;background:#0b1020;color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;padding:24px}
    header{max-width:1200px;margin:0 auto 16px;display:flex;gap:12px;align-items:baseline;flex-wrap:wrap}
    header h1{margin:0;font-size:20px;font-weight:700}
    .meta{color:var(--muted);font-size:14px}
    .controls{margin-left:auto;display:flex;gap:12px}
    .controls a, .controls button{background:var(--accent);border:0;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer;font-family:inherit;font-size:14px;text-decoration:none}
    #totals{
      max-width:1200px;margin:8px auto 16px;
      background:linear-gradient(180deg,rgba(148,163,184,.08),rgba(148,163,184,.03)), var(--card);
      border:1px solid var(--border);
      color:#cbd5e1; padding:10px 12px;border-radius:12px;font-size:14px;
    }
    #totals .title{font-weight:700;color:#e2e8f0}
    #totals .badges{display:flex;gap:10px;flex-wrap:wrap;margin-top:6px}
    #totals .badge{
      background:#1f2937;border:1px solid var(--border);border-radius:999px;
      padding:4px 10px;color:#fff;font-weight:700
    }
    #totals .badge.positive{color:#22c55e}
    #totals .badge.negative{color:#ef4444}
    #totals .badge.zero{color:#94a3b8}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(520px,1fr));gap:16px;max-width:1200px;margin:0 auto}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),transparent),var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden}
    .card header{background:var(--header);border-bottom:1px solid var(--border);padding:10px 12px;display:flex;gap:10px;align-items:center}
    .symbol{font-weight:700;letter-spacing:.3px}
    .status{margin-left:auto;font-size:12px;color:var(--muted)}
    .table-wrap{max-height:70vh;overflow:auto}
    table{width:100%;border-collapse:separate;border-spacing:0;font-variant-numeric:tabular-nums}
    thead th{position:sticky;top:0;background:var(--header);border-bottom:1px solid var(--border);padding:6px 8px;font-size:12px;color:var(--muted);text-align:left}
    thead th.num, tbody td.pct{text-align:right}
    tbody td, tbody th{border-bottom:1px solid rgba(255,255,255,.06);padding:6px 8px;font-size:12px}
    tbody td.time{color:var(--muted)}
    .pct{font-weight:600}
    .up{color:var(--up)} .down{color:var(--down)} .zero{color:var(--zero)}
    .loading,.error{padding:10px 12px;border-top:1px solid var(--border);font-size:13px;color:var(--muted)}
    .error{color:#fca5a5}
    .chip{font-size:11px;font-weight:700;padding:2px 6px;border-radius:6px;border:1px solid var(--border);color:#94a3b8;margin-left:8px}
  </style>
</head>
<body>
  <header>
    <h1>Variation 1 day — Europe/Brussels <span class="chip">+ Spike max / min</span></h1>
    <div class="meta" id="metaLine"></div>
    <div class="controls">
      <a href="/index.html">Accueil</a>
      <button id="reload">Recharger</button>
    </div>
  </header>

  <div id="totals">
    <div class="title">TOTAL par jour (somme des variations de tous les symboles) :</div>
    <div class="badges" id="totalsBadges"></div>
  </div>

  <div id="grid" class="grid"></div>

<script>
(async () => {
  // --------- PARAMÈTRES ---------
  const symbols = [
    "ARIAUSDT",
    "NILUSDT",
    "SOLVUSDT",
    "SQDUSDT",
    "VFYUSDT",
    "YALAUSDT",
    // tu peux en ajouter d'autres ici (majuscules)
  ].map(s => s.toUpperCase().trim());

  const INTERVAL = "1d"; // 1 day

  // Jours d'octobre 2025 à garder
  const days = [
    { y:2025, m:10, d:12 },
    { y:2025, m:10, d:27 },
    { y:2025, m:10, d:31 },
  ];

  const pad = n => String(n).padStart(2, '0');

  // JJ/MM/AAAA pour affichage
  function labelDay(y,m,d){
    return `${pad(d)}/${pad(m)}/${y}`;
  }

  // Conversion clé "YYYY-MM-DD" -> "DD/MM/YYYY" pour les badges
  function formatKeyToFr(key){
    const [y, m, d] = key.split('-'); // "2025-10-12"
    return `${d}/${m}/${y}`;          // "12/10/2025"
  }

  const fmtPct = p => (p >= 0 ? '+' : '') + p.toFixed(3) + '%';
  const clsPct = p => 'pct ' + (p > 0 ? 'up' : (p < 0 ? 'down' : 'zero'));

  // --------- HEADER META ---------
  (function renderHeaderMeta(){
    const meta = document.getElementById('metaLine');
    const list = days.map(({y,m,d}) => `<strong>${labelDay(y,m,d)}</strong>`).join(' &nbsp;•&nbsp; ');
    meta.innerHTML = `Jours : ${list} • Timeframe : <strong>1d</strong> (bougie journalière Binance en UTC)`;
  })();

  // --------- DOM / CARTES ---------
  const grid = document.getElementById('grid');
  const totalsBadges = document.getElementById('totalsBadges');

  function buildCard(symbol) {
    const card = document.createElement('div'); card.className = 'card';
    const head = document.createElement('header');
    const symEl = document.createElement('div'); symEl.className = 'symbol'; symEl.textContent = symbol;
    const status = document.createElement('div'); status.className = 'status'; status.textContent = 'Validation symbole…';
    head.appendChild(symEl); head.appendChild(status);

    const wrap = document.createElement('div'); wrap.className = 'table-wrap';
    const table = document.createElement('table');
    const thead = document.createElement('thead');
    thead.innerHTML = `
      <tr>
        <th>Jour</th>
        <th class="num">Variation 1d</th>
        <th class="num">Spike max (High)</th>
        <th class="num">Spike min (Low)</th>
      </tr>`;
    const tbody = document.createElement('tbody');

    for (const {y,m,d} of days) {
      const tr = document.createElement('tr');

      const tdDay = document.createElement('td');
      tdDay.className = 'time';
      tdDay.textContent = labelDay(y,m,d);

      const keyBase = `${y}-${m}-${d}`;

      const tdVar = document.createElement('td');
      tdVar.className = 'pct zero';
      tdVar.textContent = '—';
      tdVar.dataset.key = `${keyBase}:var`;

      const tdSu = document.createElement('td');
      tdSu.className = 'pct zero';
      tdSu.textContent = '—';
      tdSu.dataset.key = `${keyBase}:su`;

      const tdSd = document.createElement('td');
      tdSd.className = 'pct zero';
      tdSd.textContent = '—';
      tdSd.dataset.key = `${keyBase}:sd`;

      tr.appendChild(tdDay);
      tr.appendChild(tdVar);
      tr.appendChild(tdSu);
      tr.appendChild(tdSd);

      tbody.appendChild(tr);
    }

    table.appendChild(thead);
    table.appendChild(tbody);
    wrap.appendChild(table);

    const loading = document.createElement('div');
    loading.className = 'loading';
    loading.textContent = 'En attente…';

    card.appendChild(head);
    card.appendChild(wrap);
    card.appendChild(loading);
    grid.appendChild(card);

    return { card, statusEl: status, loadingEl: loading, tbody };
  }

  // Helpers variation/spikes
  const pctChange = (o,c) => {
    const open = Number(o), close = Number(c);
    if (!isFinite(open) || open === 0 || !isFinite(close)) return null;
    return ((close - open) / open) * 100;
  };

  function spikeMaxPct(open, high) {
    const o = Number(open), h = Number(high);
    if (!isFinite(o) || o === 0 || !isFinite(h)) return null;
    return ((h - o) / o) * 100;
  }

  function spikeMinPct(open, low) {
    const o = Number(open), l = Number(low);
    if (!isFinite(o) || o === 0 || !isFinite(l)) return null;
    return ((l - o) / o) * 100;
  }

  // --------- FETCH UTILS ---------
  async function fetchJson(url) {
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
    return r.json();
  }

  let futuresInfo = null, spotInfo = null;

  async function loadExchangeInfos(){
    futuresInfo = await fetchJson('https://fapi.binance.com/fapi/v1/exchangeInfo');   // USDT-M Futures
    spotInfo    = await fetchJson('https://api.binance.com/api/v3/exchangeInfo');     // Spot
  }

  function symbolExistsIn(info, symbol){
    if (!info || !Array.isArray(info.symbols)) return false;
    return info.symbols.some(s => s.symbol === symbol);
  }

  function pickMarket(symbol) {
    const inFutures = symbolExistsIn(futuresInfo, symbol);
    const inSpot    = symbolExistsIn(spotInfo, symbol);
    if (inFutures) return { market:'futures' };
    if (inSpot)    return { market:'spot' };
    return { market:'none' };
  }

  async function fetchKline1d(symbol, openTimeMs, market) {
    const base = market === 'futures'
      ? 'https://fapi.binance.com/fapi/v1/klines'
      : 'https://api.binance.com/api/v3/klines';

    const url = new URL(base);
    url.searchParams.set('symbol', symbol);
    url.searchParams.set('interval', INTERVAL);
    url.searchParams.set('startTime', String(openTimeMs));
    url.searchParams.set('limit', '1');

    const res = await fetch(url.toString());
    if (!res.ok) {
      console.warn(symbol, market, '->', res.status, res.statusText);
      return null;
    }
    const data = await res.json();
    if (!Array.isArray(data) || data.length === 0) return null;

    const k = data[0]; // [ openTime, open, high, low, close, ... ]
    if (+k[0] !== openTimeMs) {
      // Pas exactement le jour demandé
      return null;
    }
    return {
      open: k[1],
      high: k[2],
      low:  k[3],
      close:k[4],
    };
  }

  // Préparer les cartes
  const cards = symbols.map(s => {
    const built = buildCard(s);
    const cells = {};
    for (const {y,m,d} of days) {
      const keyBase = `${y}-${m}-${d}`;
      cells[`${keyBase}:var`] = built.tbody.querySelector(`td[data-key="${keyBase}:var"]`);
      cells[`${keyBase}:su`]  = built.tbody.querySelector(`td[data-key="${keyBase}:su"]`);
      cells[`${keyBase}:sd`]  = built.tbody.querySelector(`td[data-key="${keyBase}:sd"]`);
    }
    return { symbol: s, ...built, cells };
  });

  // Totaux par jour
  const totalMap = new Map();
  for (const {y,m,d} of days) {
    const key = `${y}-${pad(m)}-${pad(d)}`; // YYYY-MM-DD pour la clé interne
    totalMap.set(key, { sum:0, count:0 });
  }

  // --- RUN ---
  try {
    await loadExchangeInfos();
  } catch (e) {
    alert("Impossible de charger l'exchangeInfo Binance. Vérifie la connexion réseau.");
    return;
  }

  await Promise.all(cards.map(async (c) => {
    const { market } = pickMarket(c.symbol);

    if (market === 'none') {
      c.statusEl.textContent = 'Symbole inconnu (ni Futures USDT-M, ni Spot)';
      c.loadingEl.className = 'error';
      c.loadingEl.textContent = 'Vérifie l’orthographe (ex: INJUSDT, STXUSDT…).';
      return;
    }

    c.statusEl.textContent = market === 'futures' ? 'Futures USDT-M' : 'Spot';
    c.loadingEl.textContent = 'Requêtes klines 1d…';

    try {
      for (const {y,m,d} of days) {
        const openTimeMs = Date.UTC(y, m-1, d, 0, 0, 0, 0); // minuit UTC du jour
        const k = await fetchKline1d(c.symbol, openTimeMs, market);

        let pVar = null, pSu = null, pSd = null;
        if (k) {
          pVar = pctChange(k.open, k.close);
          pSu  = spikeMaxPct(k.open, k.high);
          pSd  = spikeMinPct(k.open, k.low);
        }

        const keyBase = `${y}-${m}-${d}`;
        const tdVar = c.cells[`${keyBase}:var`];
        const tdSu  = c.cells[`${keyBase}:su`];
        const tdSd  = c.cells[`${keyBase}:sd`];

        if (pVar === null) {
          tdVar.textContent = 'n/a'; tdVar.className = 'pct zero';
        } else {
          tdVar.textContent = fmtPct(pVar); tdVar.className = clsPct(pVar);
          const tKey = `${y}-${pad(m)}-${pad(d)}`; // même format que dans totalMap
          const agg = totalMap.get(tKey);
          agg.sum += pVar; agg.count += 1;
        }

        if (pSu === null) { tdSu.textContent = 'n/a'; tdSu.className = 'pct zero'; }
        else { tdSu.textContent = fmtPct(pSu); tdSu.className = clsPct(pSu); }

        if (pSd === null) { tdSd.textContent = 'n/a'; tdSd.className = 'pct zero'; }
        else { tdSd.textContent = fmtPct(pSd); tdSd.className = clsPct(pSd); }
      }
      c.loadingEl.textContent = 'Terminé.';
    } catch (e) {
      c.statusEl.textContent = 'Erreur';
      c.loadingEl.className = 'error';
      c.loadingEl.textContent = 'Échec: ' + (e?.message || e);
    }
  }));

  // Afficher les totaux (avec date en français)
  totalsBadges.innerHTML = '';
  for (const [key, {sum, count}] of totalMap.entries()) {
    const badge = document.createElement('span');
    badge.className = 'badge ' + (count === 0 ? 'zero' : (sum >= 0 ? 'positive' : 'negative'));
    const txt = count === 0 ? 'n/a' : ((sum>=0?'+':'') + sum.toFixed(3) + '%');

    // Ici on convertit la clé "YYYY-MM-DD" en "DD/MM/YYYY"
    badge.textContent = `${formatKeyToFr(key)} → ${txt}`;

    totalsBadges.appendChild(badge);
  }

  document.getElementById('reload').addEventListener('click', () => location.reload());
})();
</script>
</body>
</html>
