<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Variations 30m — Sélection Binance Futures</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --ok:#10b981; --bad:#ef4444; --text:#e5e7eb; --border:#1f2937; --warn:#f59e0b; }
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:18px;border-bottom:1px solid var(--border)}
    h1{margin:0;font-size:18px}
    h2{margin:0;font-size:16px;color:var(--text)}
    .sub{color:var(--muted);font-size:13px;margin-top:6px;line-height:1.4}
    .wrap{padding:16px;display:flex;flex-direction:column;gap:16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:16px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{border-bottom:1px solid var(--border);padding:8px 10px;white-space:nowrap}
    th{position:sticky;top:0;background:var(--card);text-align:left}
    tfoot td{font-weight:700;border-top:1px solid var(--border)}
    .pos{color:var(--ok);font-variant-numeric:tabular-nums}
    .neg{color:var(--bad);font-variant-numeric:tabular-nums}
    .na{color:var(--muted)}
    .warn{color:var(--warn)}
    .tag{display:inline-block;font-size:11px;border:1px solid var(--border);border-radius:6px;padding:2px 6px;color:var(--muted);margin-left:8px}
    .negative-sequence {background:rgba(239,68,68,0.1);border-left:3px solid var(--bad);margin-top:8px;padding:8px 12px;border-radius:6px;font-size:13px}
    .negative-sequence span {color:var(--bad);font-weight:bold}
    .card-header {display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  </style>
</head>
<body>
  <header>
    <h1>Variation 30m — Sélection de cryptos Futures <span class="tag">USDT-M PERP</span></h1>
    <div class="sub">
      09/10/2025 04:30 • 08:00 • 08:30 • 09:30 • 18:30 • 20:30 (Europe/Brussels)
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <p style="color:var(--muted);font-size:13px;margin-bottom:8px">
        Calcul = (Close − Open) / Open × 100 sur la bougie 30m à l’heure indiquée (Europe/Brussels).
        La ligne « Total (∑) » additionne les variations (%) de toutes les lignes pour chaque date.
      </p>

      <table id="table">
        <thead>
          <tr id="thead-row">
            <th>Symbole</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
        <tfoot>
          <tr id="total-row">
            <td>Total (∑)</td>
          </tr>
        </tfoot>
      </table>

      <p id="progress" class="warn">Chargement…</p>
    </div>

    <!-- Nouvelle carte pour les cryptos négatives consécutives -->
    <div class="card">
      <div class="card-header">
        <h2>Cryptos négatives sur chaque période</h2>
      </div>
      <p style="color:var(--muted);font-size:13px;margin-bottom:12px">
        Cryptos qui affichent une variation négative à chaque intervalle de temps consécutif
      </p>
      <div id="negative-cryptos-container">
        <p id="negative-cryptos-status" class="warn">Analyse en cours…</p>
        <div id="negative-cryptos-list"></div>
      </div>
    </div>
  </div>

  <script>
    const BASE = "https://fapi.binance.com";
    const INTERVAL = "30m"; // Changé de 5m à 30m

    // --- Ta sélection (mise en MAJ + trim automatiquement) ---
    const symbolsInput = [
      "AGTUSDT",
      "INUSDT",
      "QUSDT",
      "STOUSDT",
    ].map(s => s.toUpperCase().trim());

    // --- Timestamps (heure Bruxelles) MIS À JOUR ---
    const points = [
      { label:"09/10 04:30", y:2025, m:10, d:9, h:4, min:30 },
      { label:"09/10 08:00", y:2025, m:10, d:9, h:8, min:0 },
      { label:"09/10 08:30", y:2025, m:10, d:9, h:8, min:30 },
      { label:"09/10 09:30", y:2025, m:10, d:9, h:9, min:30 },
      { label:"09/10 18:30", y:2025, m:10, d:9, h:18, min:30 },
      { label:"09/10 20:30", y:2025, m:10, d:9, h:20, min:30 },
    ];

    const theadRow = document.getElementById("thead-row");
    const tbody = document.getElementById("tbody");
    const totalRow = document.getElementById("total-row");
    const progress = document.getElementById("progress");
    const negativeCryptosList = document.getElementById("negative-cryptos-list");
    const negativeCryptosStatus = document.getElementById("negative-cryptos-status");

    // Stockage des résultats pour analyse des négatives consécutives
    const allResults = [];

    // En-têtes colonnes
    for (const p of points) {
      const th = document.createElement("th");
      th.textContent = p.label;
      theadRow.appendChild(th);
    }

    // --------- Conversion Brussels -> UTC (DST OK) ----------
    function tzOffsetMsAt(date, tz) {
      const fmt = new Intl.DateTimeFormat('en-GB', {
        timeZone: tz,
        year:'numeric', month:'2-digit', day:'2-digit',
        hour:'2-digit', minute:'2-digit', second:'2-digit',
        hour12:false
      });
      const parts = Object.fromEntries(fmt.formatToParts(date).map(p => [p.type, p.value]));
      const asUTC = Date.UTC(+parts.year, +parts.month - 1, +parts.day, +parts.hour, +parts.minute, +parts.second);
      return asUTC - date.getTime();
    }
    function brusselsLocalToUtcMs(y, m, d, h, min) {
      const approxUtc = Date.UTC(y, m - 1, d, h, min, 0, 0);
      const offset = tzOffsetMsAt(new Date(approxUtc), 'Europe/Brussels');
      return approxUtc - offset; // clé: on soustrait l'offset
    }

    const pointTimes = points.map(p => ({
      label: p.label,
      openTimeMs: brusselsLocalToUtcMs(p.y, p.m, p.d, p.h, p.min)
    }));

    // --------- Vérification des symboles PERP USDT-M ----------
    async function fetchPerpSet(){
      const r = await fetch(`${BASE}/fapi/v1/exchangeInfo`);
      if(!r.ok) throw new Error("exchangeInfo error");
      const info = await r.json();
      const valid = info.symbols
        .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
        .map(s => s.symbol);
      return new Set(valid);
    }

    // --------- Bougie 30m exacte ----------
    async function fetchKlinePct(symbol, openTimeMs){
      const url = `${BASE}/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&startTime=${openTimeMs}&limit=1`;
      const r = await fetch(url);
      if(!r.ok) return null;
      const data = await r.json();
      if(!Array.isArray(data) || data.length === 0) return null;
      const k = data[0]; // [ openTime, open, high, low, close, ... ]
      if(+k[0] !== openTimeMs) return null; // pas la bougie exacte => ignore
      const open = parseFloat(k[1]), close = parseFloat(k[4]);
      if(!isFinite(open) || !isFinite(close) || open === 0) return null;
      return (close - open) / open * 100;
    }

    function fmtPct(v){
      if(v == null) return `<span class="na">—</span>`;
      const cls = v >= 0 ? "pos" : "neg";
      return `<span class="${cls}">${v.toFixed(2)}%</span>`;
    }
    function fmtTotal(v){
      if(v == null) return `<span class="na">—</span>`;
      const cls = v >= 0 ? "pos" : "neg";
      return `<span class="${cls}">${v.toFixed(2)}%</span>`;
    }

    // --------- Analyse des cryptos négatives consécutives ----------
    function analyzeNegativeCryptos() {
      negativeCryptosStatus.textContent = "Analyse des données...";
      
      if (allResults.length === 0) {
        negativeCryptosStatus.textContent = "Aucune donnée disponible";
        return;
      }

      // Trouver les cryptos qui sont négatives à chaque période
      const alwaysNegativeCryptos = [];
      
      for (const result of allResults) {
        const symbol = result.symbol;
        const allNegative = result.percentages.every(pct => pct !== null && pct < 0);
        
        if (allNegative) {
          alwaysNegativeCryptos.push({
            symbol: symbol,
            percentages: result.percentages
          });
        }
      }

      // Afficher les résultats
      negativeCryptosList.innerHTML = '';
      
      if (alwaysNegativeCryptos.length === 0) {
        negativeCryptosStatus.textContent = "Aucune crypto n'est négative sur toutes les périodes";
        return;
      }

      negativeCryptosStatus.textContent = `${alwaysNegativeCryptos.length} crypto(s) négative(s) sur toutes les périodes`;

      // Afficher chaque crypto négative
      alwaysNegativeCryptos.forEach(crypto => {
        const cryptoDiv = document.createElement('div');
        cryptoDiv.className = 'negative-sequence';
        
        let percentagesHtml = crypto.percentages.map((pct, index) => {
          return `${points[index].label}: <span>${pct.toFixed(2)}%</span>`;
        }).join(' • ');
        
        cryptoDiv.innerHTML = `<strong>${crypto.symbol}</strong><br>${percentagesHtml}`;
        negativeCryptosList.appendChild(cryptoDiv);
      });
    }

    async function main(){
      progress.textContent = "Validation des symboles PERP USDT-M…";
      const perpSet = await fetchPerpSet();

      // Ligne des totaux
      const totalCells = [];
      for (let i=0;i<pointTimes.length;i++){
        const td = document.createElement("td");
        td.innerHTML = `<span class="na">—</span>`;
        totalRow.appendChild(td);
        totalCells.push(td);
      }
      const sums = new Array(pointTimes.length).fill(0);
      const counts = new Array(pointTimes.length).fill(0);

      let done = 0;
      for(const sym of symbolsInput){
        const tr = document.createElement("tr");
        const tdSym = document.createElement("td");
        tdSym.textContent = sym;
        tr.appendChild(tdSym);

        const tds = [];
        const percentages = []; // Stocker les pourcentages pour l'analyse
        
        for(let i=0;i<pointTimes.length;i++){
          const td = document.createElement("td");
          td.innerHTML = `<span class="warn">…</span>`;
          tr.appendChild(td);
          tds.push(td);
        }
        tbody.appendChild(tr);

        if(!perpSet.has(sym)){
          // Symbole inconnu en PERP USDT-M
          for(let i=0;i<pointTimes.length;i++){
            tds[i].innerHTML = `<span class="na">symbole inconnu</span>`;
            percentages.push(null);
          }
        } else {
          // Remplir les variations
          for(let i=0;i<pointTimes.length;i++){
            try{
              const pct = await fetchKlinePct(sym, pointTimes[i].openTimeMs);
              tds[i].innerHTML = fmtPct(pct);
              percentages.push(pct);
              if(pct != null){ sums[i] += pct; counts[i]++; }
            }catch{
              tds[i].innerHTML = `<span class="na">—</span>`;
              percentages.push(null);
            }
            // petite pause pour ménager l'API
            await new Promise(r=>setTimeout(r,80));
          }
        }

        // Stocker les résultats pour l'analyse
        allResults.push({
          symbol: sym,
          percentages: percentages
        });

        done++;
        if(done % 2 === 0) progress.textContent = `Progression : ${done}/${symbolsInput.length}`;
      }

      // Totaux par date
      for(let i=0;i<pointTimes.length;i++){
        totalCells[i].innerHTML = counts[i] > 0 ? fmtTotal(sums[i]) : `<span class="na">—</span>`;
      }

      progress.textContent = "Terminé ✅";
      
      // Analyser les cryptos négatives
      analyzeNegativeCryptos();
    }

    main().catch(e=>{
      console.error(e);
      progress.textContent = "Erreur : " + e.message;
      negativeCryptosStatus.textContent = "Erreur lors de l'analyse";
    });
  </script>
</body>
</html>