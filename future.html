<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Bitcoin Extreme Oscillators - Feux de Trading</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      padding: 8px;
      border: 1px solid #ccc;
      text-align: center;
    }
    th {
      background-color: #f5f5f5;
      position: sticky;
      top: 0;
    }
    .green {
      color: green;
      font-weight: bold;
    }
    .red {
      color: red;
      font-weight: bold;
    }
    .neutral {
      color: gray;
    }
    .signal-box {
      margin-top: 30px;
      padding: 15px;
      border: 2px solid #333;
      border-radius: 6px;
      background: #fafafa;
    }
    .signal-box ul {
      margin-top: 10px;
    }
    .signal-box li {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>ðŸ“Š Bitcoin Cycle Extreme Oscillators</h1>
  <p>SÃ©lectionne une date (UTC) pour voir les recommandations de trading :</p>
  <input type="date" id="customDate" />
  <button onclick="loadCryptoData()">Rechercher</button>

  <div id="loading">En attente de chargement...</div>

  <table id="cryptoTable">
    <thead>
      <tr>
        <th>#</th>
        <th>Crypto</th>
        <th>Variation</th>
        <th>Funding</th>
        <th>Score</th>
        <th>Feu</th>
        <th>EntrÃ©e OK ?</th>
        <th>Sortie RecommandÃ©e</th>
      </tr>
    </thead>
    <tbody id="cryptoTableBody"></tbody>
  </table>

  <div id="recommendations" class="signal-box"></div>

  <script>
    const cryptoScores = [];
    let total = 0, loaded = 0;

    async function loadCryptoData() {
      const date = document.getElementById("customDate").value;
      if (!date) return alert("SÃ©lectionne une date.");

      const target = new Date(date);
      target.setUTCHours(2, 0, 0, 0);
      const end = new Date(target);
      end.setUTCDate(end.getUTCDate() + 1);
      end.setUTCHours(1, 59, 59, 999);

      document.getElementById("loading").textContent = "Chargement...";
      document.getElementById("cryptoTableBody").innerHTML = '';
      document.getElementById("recommendations").innerHTML = '';
      cryptoScores.length = 0;

      const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
      const data = await res.json();

      const symbols = data.symbols
        .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
        .map(s => s.baseAsset)
        .filter((v, i, a) => a.indexOf(v) === i);

      total = symbols.length;
      loaded = 0;

      for (const sym of symbols) {
        fetchCrypto(sym, target, end);
      }
    }

    async function fetchCrypto(symbol, start, end) {
      try {
        const [kRes, fRes] = await Promise.all([
          fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}USDT&interval=1d&limit=1000`),
          fetch(`https://fapi.binance.com/fapi/v1/fundingRate?symbol=${symbol}USDT&limit=1000`)
        ]);

        const kData = await kRes.json();
        const fData = await fRes.json();

        const kline = kData.find(k => {
          const d = new Date(k[0]);
          return d.toISOString().slice(0, 10) === start.toISOString().slice(0, 10);
        });

        if (!kline) return increment();

        const open = parseFloat(kline[1]);
        const close = parseFloat(kline[4]);
        const variation = ((close - open) / open) * 100;

        let funding = 0;
        let count = 0;
        for (const f of fData) {
          const t = new Date(f.fundingTime);
          if (t >= start && t <= end) {
            funding += parseFloat(f.fundingRate) * 100;
            count++;
          }
        }

        let score = 0;
        if (variation >= 3) score++;
        else if (variation <= -3) score--;

        if (funding <= -0.05) score++;
        else if (funding >= 0.05) score--;

        let feu = 'âšª';
        let feuClass = 'neutral';
        let decision = '';
        let entree = 'NON';
        let sortie = 'NON';

        if (score === 2) {
          feu = 'ðŸŸ¢';
          feuClass = 'green';
          decision = 'LONG';
          entree = 'OUI';
        } else if (score === -2) {
          feu = 'ðŸ”´';
          feuClass = 'red';
          decision = 'SHORT';
          entree = 'OUI';
        }

        if ((score === 1 && funding >= 0.05) || (score === -1 && funding <= -0.05)) {
          sortie = 'OUI';
        }

        if (decision)
          cryptoScores.push({ symbol, score, decision });

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${loaded + 1}</td>
          <td>${symbol}</td>
          <td class="${variation > 0 ? 'green' : variation < 0 ? 'red' : 'neutral'}">${variation.toFixed(2)}%</td>
          <td class="${funding > 0 ? 'red' : funding < 0 ? 'green' : 'neutral'}">${funding.toFixed(5)}%</td>
          <td>${score}</td>
          <td class="${feuClass}">${feu}</td>
          <td>${entree}</td>
          <td>${sortie}</td>
        `;
        document.getElementById("cryptoTableBody").appendChild(row);
      } catch (e) {
        console.warn("Erreur:", symbol, e);
      } finally {
        increment();
      }
    }

    function increment() {
      loaded++;
      if (loaded === total) {
        document.getElementById("loading").textContent = "Chargement terminÃ©.";
        showRecommendations();
      }
    }

    function showRecommendations() {
      const box = document.getElementById("recommendations");
      if (cryptoScores.length === 0) {
        box.innerHTML = `<strong>Aucune crypto ne prÃ©sente de score extrÃªme aujourdâ€™hui.</strong>`;
        return;
      }
      box.innerHTML = `<strong>ðŸ”¥ Cryptos recommandÃ©es aujourdâ€™hui :</strong><ul>` +
        cryptoScores.map(c => {
          const color = c.decision === 'LONG' ? 'green' : 'red';
          return `<li class="${color}">${c.symbol} â†’ ${c.decision} (Score ${c.score})</li>`;
        }).join('') + `</ul>`;
    }
  </script>
</body>
</html>
