<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Listings ‚Äî Bougie n¬∞20 (Binance Futures USDT-M PERP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --ok:#10b981; --bad:#ef4444; --text:#e5e7eb; --border:#1f2937;}
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;font-size:13px}
    header{padding:18px 16px;border-bottom:1px solid var(--border)}
    h1{margin:0;font-size:20px}
    .sub{color:var(--muted);font-size:13px;margin-top:4px}
    main{max-width:1180px;margin:18px auto;padding:0 12px}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin:16px 0;align-items:flex-end}
    label{font-size:12px}
    label span{display:block;margin-bottom:4px;font-size:11px}
    select,button{background:#0b1220;color:var(--text);border:1px solid var(--border);border-radius:8px;padding:8px 10px;font-size:12px}
    button{cursor:pointer}
    .btn-danger{border-color:#3b1d1d;background:#1a0e0e}
    #status{font-size:11px}
    #nCalendar{font-size:12px;margin-left:auto}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;position:relative}
    table{width:100%;border-collapse:collapse;margin-top:6px}
    th,td{padding:10px;border-bottom:1px solid var(--border);font-size:13px;text-align:right;vertical-align:top;white-space:nowrap}
    th:first-child,td:first-child{text-align:left}
    th:nth-child(2),td:nth-child(2){text-align:center;}
    th:nth-child(3),td:nth-child(3){text-align:center;}
    .up{color:var(--ok);font-weight:600}
    .down{color:var(--bad);font-weight:600}
    .muted{color:var(--muted)}
    .error{color:var(--bad);margin-top:8px}
    .hint{font-size:11px;color:var(--muted);margin-top:8px;line-height:1.45}
    .badge{border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:12px}
    .right{position:absolute;top:-70px;right:12px}
    #homeBtn { color:white!important; border:1px solid var(--border); }
    #homeBtn a { color:white!important; text-decoration:none; display:block; }
    .candle-date-banner{
      margin:16px 0 6px;display:flex;justify-content:center;align-items:center;
      background:#facc15;color:#111827;border:1px solid #f59e0b;border-radius:12px;
      padding:10px 14px;font-weight:700;font-size:18px;letter-spacing:.5px;
    }

    /* DUPE CARD */
    .dupe-card{margin:16px 0 10px;background:#0f1222;border:1px solid #23324a}
    .dupe-title{display:flex;gap:8px;align-items:center;margin-bottom:8px;font-weight:700}
    .dupe-month{margin-top:10px}
    .dupe-month h4{margin:8px 0 6px;font-size:13px;color:#d1d5db}
    .dupe-pill{
      display:inline-flex;gap:6px;align-items:center;border:1px solid var(--border);
      border-radius:999px;padding:6px 10px;margin:4px 6px 0 0;font-size:12px
    }
    .dupe-pill.positive{border-color:rgba(16,185,129,.35);background:rgba(16,185,129,.08)}
    .dupe-pill.negative{border-color:rgba(239,68,68,.35);background:rgba(239,68,68,.08)}
  </style>
</head>
<body>
  <header>
    <h1 id="h1">Listings en janvier ‚Ä¢ Bougie n¬∞<span id="nLabel">20</span></h1>
    <div class="sub">
      March√© analys√© : <b>Binance Futures ‚Äî USDT-M PERP</b>
    </div>
  </header>

  <main>
    <div class="controls">
      <label>
        <span class="muted">Ann√©e (affich√©e +1)</span>
        <select id="yearSel"></select>
      </label>
      <label>
        <span class="muted">Mois</span>
        <select id="monthSel"></select>
      </label>
      <label>
        <span class="muted">N¬∞ de bougie (daily)</span>
        <select id="candleSel"></select>
      </label>

      <div style="display:flex;gap:8px;align-items:center">
        <button id="runBtn">Run</button>
        <button id="clearBtn" class="btn-danger">üóëÔ∏è Effacer</button>
        <button id="homeBtn"><a href="/index.html">Accueil</a></button>
        <span id="status" class="muted"></span>
      </div>

      <div class="muted" id="nCalendar">
        Bougie n¬∞<b><span id="nCalN">20</span></b> ‚Äî <b><span id="nCalDate">‚Äî</span></b>
      </div>
    </div>

    <!-- CARD x2 -->
    <div id="dupeCard" class="card dupe-card" style="display:none">
      <div class="dupe-title">
        üö® <span>Minutes ‚Äúx2‚Äù (m√™me jour ‚Ä¢ m√™me polarit√©) ‚Äî Bougie 3m</span>
      </div>
      <div class="muted" style="margin-bottom:8px">
        Condition: <b>2 dates</b> qui ont <b>exactement 2 cryptos</b> de la m√™me polarit√© (sur la bougie 3m) dans <b>Jan + Jun + Sep</b>.
      </div>
      <div id="dupeContent"></div>
    </div>

    <div class="card">
      <div class="right badge"><span id="progress">‚Äî</span></div>

      <table>
        <thead>
          <tr>
            <th style="width:150px">Symbole</th>
            <th style="width:250px">Date bougie 3m<br><span class="muted">(m√™me jour que daily ‚Ä¢ heure actuelle)</span></th>
            <th style="width:170px">Variation bougie 3m</th>
            <th style="width:240px">Date bougie n¬∞<span id="thN1">20</span></th>
            <th style="width:170px">Variation bougie n¬∞<span id="thN2">20</span></th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>

      <div id="err" class="error"></div>
      <div class="hint">
        Bougie 3m: m√™me <b>jour</b> que la bougie daily n¬∞N, avec l‚Äô<b>heure actuelle</b>, align√©e en 3 minutes.
      </div>

      <div id="candleDateBanner" class="candle-date-banner">‚Äî</div>
    </div>
  </main>

  <script>
    const tz='Europe/Brussels';

    const yearSel   = document.getElementById('yearSel');
    const monthSel  = document.getElementById('monthSel');
    const candleSel = document.getElementById('candleSel');
    const runBtn    = document.getElementById('runBtn');
    const clearBtn  = document.getElementById('clearBtn');
    const statusEl  = document.getElementById('status');
    const progressEl= document.getElementById('progress');
    const tbody     = document.getElementById('tbody');
    const errEl     = document.getElementById('err');

    const nLabel = document.getElementById('nLabel');
    const thN1   = document.getElementById('thN1');
    const thN2   = document.getElementById('thN2');

    const nCalN    = document.getElementById('nCalN');
    const nCalDate = document.getElementById('nCalDate');

    const candleDateBanner = document.getElementById('candleDateBanner');

    const dupeCard = document.getElementById('dupeCard');
    const dupeContent = document.getElementById('dupeContent');

    const dayMs = 24*60*60*1000;

    // Banner perso (inchang√©)
    const BANNER_BASE_MS = Date.UTC(2025, 9, 9, 0, 0, 0);

    // On travaille sur ces 3 mois seulement (comme ton projet)
    const ALLOWED_MONTHS = [0,5,8]; // Jan, Jun, Sep

    let lastRows = [];

    const CACHE = {
      symbols: null,
      dailyKlines: new Map(),
      monthRows: new Map(),
      computed: new Map(),
      k3m: new Map(),
    };

    const keyMonth    = (Y,M)=>`${Y}-${M}`;
    const keyComputed = (Y,M,N)=>`${Y}-${M}-${N}`;
    const key3m = (sym, openTime)=>`${sym}|${openTime}`;

    function formatShortFrDate(ms){
      return new Intl.DateTimeFormat('fr-BE',{timeZone:tz,year:'2-digit',month:'2-digit',day:'2-digit'}).format(new Date(ms));
    }
    function toBrusselsDate(ms){
      return new Intl.DateTimeFormat('fr-BE',{
        timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'
      }).format(new Date(ms));
    }
    function monthYearInBrussels(ms){
      const d = new Date(new Intl.DateTimeFormat('en-CA',{timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit'}).format(new Date(ms))+'T00:00:00');
      return { y: d.getUTCFullYear(), m: d.getUTCMonth() };
    }
    const fmtPct = n => (n>=0?'+':'') + n.toFixed(4) + ' %';

    // cl√© jour (sur la date 3m) => YYYY-MM-DD (Brussels)
    const dayKeyFromMs = (ms)=> new Intl.DateTimeFormat('en-CA',{
      timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit'
    }).format(new Date(ms));

    // jour affichage => DD/MM/YY (Brussels)
    const dayHumanFromMs = (ms)=> new Intl.DateTimeFormat('fr-BE',{
      timeZone:tz,year:'2-digit',month:'2-digit',day:'2-digit'
    }).format(new Date(ms));

    async function fetchJSON(url){
      const r = await fetch(url);
      if(!r.ok) throw new Error(`HTTP ${r.status} ‚Äî ${await r.text()}`);
      return r.json();
    }

    async function mapLimit(items, limit, worker){
      const ret=[]; let i=0, active=0, done=0;
      return new Promise(resolve=>{
        const next=()=>{
          while(active<limit && i<items.length){
            const idx=i++, it=items[idx]; active++;
            Promise.resolve(worker(it,idx))
              .then(res=>{ ret[idx]=res; })
              .catch(()=>{ ret[idx]=null; })
              .finally(()=>{
                active--; done++;
                progressEl.textContent = `${done}/${items.length}`;
                if(done===items.length) resolve(ret); else next();
              });
          }
        };
        next();
      });
    }

    // ===== 3m logic =====
    const THREE_MIN_MS = 3*60*1000;

    function get3mOpenFromDailyOpen(openTimeDailyMs){
      const daily = new Date(openTimeDailyMs);
      const now = new Date();
      daily.setHours(now.getHours(), now.getMinutes(), 0, 0);
      return Math.floor(daily.getTime() / THREE_MIN_MS) * THREE_MIN_MS;
    }

    async function get3mCandlePctAt(sym, openTimeMs){
      const k = key3m(sym, openTimeMs);
      if (CACHE.k3m.has(k)) return CACHE.k3m.get(k);

      const u = new URL('https://fapi.binance.com/fapi/v1/klines');
      u.searchParams.set('symbol', sym);
      u.searchParams.set('interval', '3m');
      u.searchParams.set('startTime', String(openTimeMs));
      u.searchParams.set('endTime', String(openTimeMs + THREE_MIN_MS));
      u.searchParams.set('limit', '1');

      try{
        const kl = await fetchJSON(u.toString());
        if(!kl || !kl.length){
          const res = { openTime: openTimeMs, pct: null };
          CACHE.k3m.set(k, res);
          return res;
        }
        const candle = kl[0];
        const o = parseFloat(candle[1]);
        const c = parseFloat(candle[4]);
        const pct = (o>0) ? ((c-o)/o*100) : 0;

        const res = { openTime: candle[0], pct };
        CACHE.k3m.set(k, res);
        return res;
      }catch{
        const res = { openTime: openTimeMs, pct: null };
        CACHE.k3m.set(k, res);
        return res;
      }
    }

    // ===== Futures symbols + daily =====
    async function getSymbolsOnce(){
      if (CACHE.symbols) return CACHE.symbols;
      const ex = await fetchJSON('https://fapi.binance.com/fapi/v1/exchangeInfo');
      CACHE.symbols = (ex.symbols||[])
        .filter(s => s.contractType==='PERPETUAL' && s.quoteAsset==='USDT' && s.status==='TRADING')
        .map(s => s.symbol);
      return CACHE.symbols;
    }

    async function getDailyKlines(sym){
      if (CACHE.dailyKlines.has(sym)) return CACHE.dailyKlines.get(sym);

      const u=new URL('https://fapi.binance.com/fapi/v1/klines');
      u.searchParams.set('symbol',sym);
      u.searchParams.set('interval','1d');
      u.searchParams.set('limit','500');
      u.searchParams.set('startTime','0');

      const klines = await fetchJSON(u.toString());
      CACHE.dailyKlines.set(sym, klines||[]);
      return klines||[];
    }

    async function warmMonth(Y,M){
      const k = keyMonth(Y,M);
      if (CACHE.monthRows.has(k)) return CACHE.monthRows.get(k);

      const symbols = await getSymbolsOnce();
      statusEl.textContent = `Pr√©paration du mois ${String(M+1).padStart(2,'0')}/${Y}‚Ä¶`;
      progressEl.textContent = '‚Äî';

      const rows = await mapLimit(symbols, 8, async (sym)=>{
        try{
          const klines = await getDailyKlines(sym);
          if(!klines.length) return null;

          // listing = premi√®re bougie daily existante
          const openTime1 = klines[0][0];

          // on garde uniquement ceux dont le listing tombe dans le mois (Brussels)
          const {y,m} = monthYearInBrussels(openTime1);
          if (y!==Y || m!==M) return null;

          return { sym, openTime1, dailyKlines: klines };
        }catch{ return null; }
      });

      const kept = rows.filter(Boolean);
      CACHE.monthRows.set(k, kept);
      return kept;
    }

    async function computeRows(Y,M,N){
      const kc = keyComputed(Y,M,N);
      if (CACHE.computed.has(kc)) return CACHE.computed.get(kc);

      const base = CACHE.monthRows.get(keyMonth(Y,M)) || [];
      if(!base.length){ CACHE.computed.set(kc, []); return []; }

      const rows = await mapLimit(base, 10, async (r)=>{
        const kl = r.dailyKlines;

        // daily N
        let openTimeN=null, pctN=null;
        if (kl.length>=N){
          const candle = kl[N-1];
          openTimeN = candle[0];
          const o=parseFloat(candle[1]), c=parseFloat(candle[4]);
          pctN = o>0 ? ((c-o)/o*100) : 0;
        }

        // 3m derived
        let openTime3m=null, pct3m=null;
        if (openTimeN !== null){
          const target3mOpen = get3mOpenFromDailyOpen(openTimeN);
          const c3 = await get3mCandlePctAt(r.sym, target3mOpen);
          openTime3m = c3.openTime;
          pct3m = c3.pct;
        }

        return { sym:r.sym, openTime1:r.openTime1, openTime3m, pct3m, openTimeN, pctN };
      });

      // tri par date N
      rows.sort((a,b)=>{
        if (a.openTimeN && b.openTimeN) return a.openTimeN - b.openTimeN;
        if (a.openTimeN) return -1;
        if (b.openTimeN) return 1;
        return a.sym.localeCompare(b.sym);
      });

      CACHE.computed.set(kc, rows);
      return rows;
    }

    function renderTable(rows){
      tbody.innerHTML='';
      if(!rows.length){
        tbody.innerHTML = `<tr><td colspan="5" class="muted">Aucun nouveau PERP USDT-M list√© pour les crit√®res choisis.</td></tr>`;
        return;
      }

      const frag = document.createDocumentFragment();
      rows.forEach(r=>{
        const tr = document.createElement('tr');

        const date3m = (r.openTime3m==null) ? '<span class="muted">‚Äî</span>' : toBrusselsDate(r.openTime3m);
        const pct3m  = (r.pct3m==null) ? '<span class="muted">‚Äî</span>' : `<span class="${r.pct3m>=0?'up':'down'}">${fmtPct(r.pct3m)}</span>`;

        const dateN  = (r.openTimeN==null) ? '<span class="muted">‚Äî</span>' : toBrusselsDate(r.openTimeN);
        const pctN   = (r.pctN==null) ? '<span class="muted">‚Äî</span>' : `<span class="${r.pctN>=0?'up':'down'}">${fmtPct(r.pctN)}</span>`;

        tr.innerHTML = `
          <td>${r.sym}</td>
          <td>${date3m}</td>
          <td>${pct3m}</td>
          <td>${dateN}</td>
          <td>${pctN}</td>
        `;
        frag.appendChild(tr);
      });
      tbody.appendChild(frag);
    }

    // ==============================
    // NEW: dupe card based on 3m dates
    // Condition: each month (Jan/Jun/Sep) must have exactly 2 "x2" days
    // where x2 day means: exactly 2 positives OR exactly 2 negatives on that day (3m pct)
    // ==============================
    function buildX2ReportForMonth(rows){
      const byDay = new Map(); // dayKey -> {pos:[sym], neg:[sym], ms:number}

      rows.forEach(r=>{
        if (r.openTime3m==null || r.pct3m==null) return;
        if (r.pct3m === 0) return;

        const k = dayKeyFromMs(r.openTime3m);
        if (!byDay.has(k)) byDay.set(k, {pos:[],neg:[], ms:r.openTime3m});
        const bag = byDay.get(k);
        (r.pct3m > 0 ? bag.pos : bag.neg).push(r.sym);
      });

      const x2 = []; // {dayHuman, sign, syms[]}
      for (const bag of byDay.values()){
        if (bag.pos.length === 2) x2.push({ dayHuman: dayHumanFromMs(bag.ms), sign:'positive', syms: bag.pos.slice(0,2) });
        if (bag.neg.length === 2) x2.push({ dayHuman: dayHumanFromMs(bag.ms), sign:'negative', syms: bag.neg.slice(0,2) });
      }

      // Important: keep only days that are x2 (we expect 2 of them for the rule)
      return x2;
    }

    async function updateDupeCardFor3m(Y,N){
      // calc rows for Jan/Jun/Sep
      await Promise.all(ALLOWED_MONTHS.map(m => warmMonth(Y,m)));
      const rowsByMonth = await Promise.all(ALLOWED_MONTHS.map(m => computeRows(Y,m,N)));

      const monthNamesShort = ['Jan','F√©v','Mar','Avr','Mai','Jun','Jul','Ao√ª','Sep','Oct','Nov','D√©c'];

      const report = ALLOWED_MONTHS.map((M, idx)=>{
        const x2 = buildX2ReportForMonth(rowsByMonth[idx]);
        return { M, label: monthNamesShort[M], x2 };
      });

      const ok = report.every(b => b.x2.length === 2);

      dupeContent.innerHTML = '';
      if(!ok){
        dupeCard.style.display='none';
        return;
      }

      // render card
      report.forEach(block=>{
        const wrap = document.createElement('div');
        wrap.className = 'dupe-month';
        wrap.innerHTML = `<h4>${block.label} ‚Äî x2 = ${block.x2.length}</h4>`;

        const pills = document.createElement('div');
        block.x2.forEach(d=>{
          const pill = document.createElement('span');
          pill.className = `dupe-pill ${d.sign==='positive'?'positive':'negative'}`;
          const signTxt = d.sign==='positive' ? 'Haussi√®re' : 'Baissi√®re';
          const syms = d.syms.join(', ');
          pill.innerHTML = `<b>${d.dayHuman}</b> ‚Ä¢ ${signTxt} ‚Ä¢ x2 <span class="muted" style="margin-left:6px">${syms}</span>`;
          pills.appendChild(pill);
        });

        wrap.appendChild(pills);
        dupeContent.appendChild(wrap);
      });

      dupeCard.style.display='block';
    }

    function updateBannerOnly(){
      const n = parseInt(candleSel.value,10);
      const ms = BANNER_BASE_MS + (n-20)*dayMs;
      candleDateBanner.textContent = formatShortFrDate(ms);
    }

    function updateNCalendar(){
      const n = parseInt(candleSel.value,10);
      nCalN.textContent = n;
      const ms = BANNER_BASE_MS + (n-20)*dayMs;
      nCalDate.textContent = new Intl.DateTimeFormat('fr-BE', {
        timeZone: tz,
        day: '2-digit',
        month: '2-digit',
        year: '2-digit'
      }).format(ms);
    }

    function updateLabels(){
      const n = parseInt(candleSel.value,10);
      nLabel.textContent = n;
      thN1.textContent = n;
      thN2.textContent = n;
      updateNCalendar();
      updateBannerOnly();
    }

    async function buildAndRenderCurrent(Y,M,N){
      const rows = await computeRows(Y,M,N);
      lastRows = rows;
      renderTable(rows);
      updateLabels();
    }

    async function run(){
      errEl.textContent=''; tbody.innerHTML=''; progressEl.textContent='‚Äî';
      lastRows=[];

      const Y = parseInt(yearSel.value,10);
      const M = parseInt(monthSel.value,10);
      const N = parseInt(candleSel.value,10);

      try{
        statusEl.textContent = 'Chargement initial (une seule fois)‚Ä¶';
        await warmMonth(Y,M);
        Promise.allSettled(ALLOWED_MONTHS.filter(mm=>mm!==M).map(mm=>warmMonth(Y,mm)));

        statusEl.textContent = `Calcul daily N=${N} + 3m‚Ä¶`;
        await buildAndRenderCurrent(Y,M,N);

        statusEl.textContent = 'V√©rification des minutes x2 (3m)‚Ä¶';
        await updateDupeCardFor3m(Y, N);

        statusEl.textContent = `Termin√© (cache) ‚Äî ${lastRows.length} symbole(s) ‚Ä¢ N=${N} ‚Ä¢ ${String(M+1).padStart(2,'0')}/${Y}`;
      }catch(e){
        console.error(e);
        errEl.textContent='Erreur: '+e.message;
        statusEl.textContent='';
      }
    }

    function clearAll(){
      CACHE.symbols = null;
      CACHE.dailyKlines.clear();
      CACHE.monthRows.clear();
      CACHE.computed.clear();
      CACHE.k3m.clear();

      lastRows = [];
      tbody.innerHTML = '';
      errEl.textContent = '';
      progressEl.textContent = '‚Äî';
      nCalDate.textContent = '‚Äî';
      candleDateBanner.textContent = '‚Äî';

      dupeContent.innerHTML='';
      dupeCard.style.display='none';

      updateLabels();
      statusEl.textContent = 'Tout effac√© ‚Äî s√©lectionne tes param√®tres puis clique Run.';
    }

    async function tryFastRender(){
      const Y = parseInt(yearSel.value,10);
      const M = parseInt(monthSel.value,10);
      const N = parseInt(candleSel.value,10);

      if (CACHE.monthRows.has(keyMonth(Y,M))){
        statusEl.textContent = 'Recalcul rapide depuis le cache‚Ä¶';
        await buildAndRenderCurrent(Y,M,N);
        await updateDupeCardFor3m(Y, N);
        statusEl.textContent = `OK (cache) ‚Ä¢ ${lastRows.length} symbole(s)`;
      }else{
        statusEl.textContent = 'Param√®tres modifi√©s ‚Äî cliquez sur Run (premier chargement seulement)';
      }
    }

    (function initSelectors(){
      const years=[2024];
      years.forEach(y=>{
        const o=document.createElement('option');
        o.value=String(y);
        o.textContent=String(y+1);
        yearSel.appendChild(o);
      });
      yearSel.value='2024';

      const limitedMonths=[
        {label:'01 Jan', value:0},
        {label:'06 Jun', value:5},
        {label:'09 Sep', value:8},
      ];
      limitedMonths.forEach(({label,value})=>{
        const o=document.createElement('option');
        o.value=value;
        o.textContent=label;
        monthSel.appendChild(o);
      });
      monthSel.value=0;

      for(let n=1;n<=500;n++){
        const o=document.createElement('option');
        o.value=n;
        o.textContent=String(n);
        candleSel.appendChild(o);
      }
      candleSel.value='96';

      updateLabels();
      updateNCalendar();
      updateBannerOnly();
    })();

    candleSel.addEventListener('change', async ()=>{ updateLabels(); await tryFastRender(); });
    yearSel.addEventListener('change', tryFastRender);
    monthSel.addEventListener('change', tryFastRender);

    runBtn.addEventListener('click', run);
    clearBtn.addEventListener('click', clearAll);

    const h1 = document.getElementById('h1');
    const monthNames = ['janvier','f√©vrier','mars','avril','mai','juin','juillet','ao√ªt','septembre','octobre','novembre','d√©cembre'];
    const updateHeader = () => {
      h1.innerHTML = `Listings en ${monthNames[+monthSel.value]} ‚Ä¢ Bougie n¬∞<span id="nLabel">${candleSel.value}</span>`;
    };
    monthSel.addEventListener('change', updateHeader);
    candleSel.addEventListener('change', updateHeader);
    updateHeader();
  </script>
</body>
</html>
