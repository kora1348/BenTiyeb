<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Analyse journalière Binance - Timeframe 1h (02h00 → 01h59)</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 20px; }
th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
th { background-color: #eee; }
#progressContainer {
    width: 100%;
    background-color: #ddd;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 10px;
}
#progressBar {
    height: 20px;
    width: 0%;
    background-color: #4caf50;
    text-align: center;
    color: white;
    font-size: 12px;
    line-height: 20px;
    transition: width 0.3s ease;
}
#alertGreen div { color: green; margin-bottom: 4px; }
#alertRed div { color: red; margin-bottom: 4px; }
#alertsContainer {
    display: flex;
    gap: 40px;
    margin-top: 20px;
}
#alertGreen, #alertRed { flex: 1; }
#alertGreen h3, #alertRed h3 {
    margin-bottom: 8px;
    border-bottom: 1px solid #ccc;
    padding-bottom: 4px;
}
</style>
</head>
<body>

<h2>Alertes : Cryptos - Analyse journalière 1h (02h00 → 01h59)</h2>

<div id="progressContainer">
    <div id="progressBar">0%</div>
</div>

<div id="alertsContainer">
    <div id="alertGreen">
        <h3>Variations entre -10% et -19% (Vert)</h3>
    </div>
    <div id="alertRed">
        <h3>Variations ≥ 20% (Rouge)</h3>
    </div>
</div>

<table>
<thead>
<tr>
    <th>Crypto</th>
    <th>Période</th>
    <th>Total variations positives (%)</th>
    <th>Total variations négatives (%)</th>
</tr>
</thead>
<tbody id="cryptoTableBody"></tbody>
</table>

<script>
// Définir la période : 02h00 aujourd'hui -> 01h59 demain
function getPeriodTimestamps() {
    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 2, 0, 0); // 02h00 aujourd'hui
    const end = new Date(start.getTime() + (24 * 60 * 60 * 1000) - 60 * 1000); // 23h59 après +22h = 01h59 demain
    return {
        startTime: start.getTime(),
        endTime: end.getTime()
    };
}

async function fetchUsdtSymbols() {
    const resp = await fetch('https://api.binance.com/api/v3/exchangeInfo');
    const data = await resp.json();
    return data.symbols
        .filter(s => s.status === 'TRADING' && s.symbol.endsWith('USDT') && s.isSpotTradingAllowed)
        .map(s => s.symbol);
}

async function fetchOneHourKlines(symbol, startTime, endTime) {
    const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&startTime=${startTime}&endTime=${endTime}`;
    const resp = await fetch(url);
    return resp.json();
}

function updateProgress(current, total) {
    const progressBar = document.getElementById('progressBar');
    const percent = Math.round((current / total) * 100);
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
}

async function main() {
    const alertGreenDiv = document.getElementById('alertGreen');
    const alertRedDiv = document.getElementById('alertRed');
    const tbody = document.getElementById('cryptoTableBody');
    tbody.innerHTML = '';
    alertGreenDiv.innerHTML = '<h3>Variations entre -10% et -19% (Vert)</h3>';
    alertRedDiv.innerHTML = '<h3>Variations ≥ 20% (Rouge)</h3>';

    let alertsGreen = [];
    let alertsRed = [];

    try {
        const { startTime, endTime } = getPeriodTimestamps();
        const symbols = await fetchUsdtSymbols();
        const total = symbols.length;
        let processed = 0;

        for (const symbol of symbols) {
            try {
                const klines = await fetchOneHourKlines(symbol, startTime, endTime);
                if (klines.length === 0) continue;

                let totalPositive = 0;
                let totalNegative = 0;

                for (let i = 1; i < klines.length; i++) {
                    const prevClose = parseFloat(klines[i - 1][4]);
                    const close = parseFloat(klines[i][4]);
                    const variation = ((close - prevClose) / prevClose) * 100;

                    if (variation > 0) totalPositive += variation;
                    else totalNegative += variation;
                }

                // Alertes
                if (totalNegative <= -10 && totalNegative >= -19) {
                    alertsGreen.push({ symbol, date: new Date().toISOString().slice(0,10), variation: totalNegative.toFixed(2) });
                }
                if (totalPositive >= 20) {
                    alertsRed.push({ symbol, date: new Date().toISOString().slice(0,10), variation: totalPositive.toFixed(2) });
                }

                // Ligne tableau
                tbody.insertAdjacentHTML('beforeend', `
                    <tr>
                        <td>${symbol}</td>
                        <td>02:00 → 01:59</td>
                        <td>${totalPositive.toFixed(2)}%</td>
                        <td>${totalNegative.toFixed(2)}%</td>
                    </tr>
                `);
            } catch (e) {
                tbody.insertAdjacentHTML('beforeend', `<tr><td>${symbol}</td><td colspan="3" style="color:red;">Erreur: ${e.message}</td></tr>`);
            }

            processed++;
            updateProgress(processed, total);
        }

        // Affichage alertes vertes
        alertsGreen.forEach(a => {
            alertGreenDiv.insertAdjacentHTML('beforeend', `<div>${a.symbol} : ${a.variation}% (${a.date})</div>`);
        });
        if (alertsGreen.length === 0) {
            alertGreenDiv.insertAdjacentHTML('beforeend', '<div>Aucune alerte verte détectée.</div>');
        }

        // Affichage alertes rouges
        alertsRed.forEach(a => {
            alertRedDiv.insertAdjacentHTML('beforeend', `<div>${a.symbol} : ${a.variation}% (${a.date})</div>`);
        });
        if (alertsRed.length === 0) {
            alertRedDiv.insertAdjacentHTML('beforeend', '<div>Aucune alerte rouge détectée.</div>');
        }

    } catch (e) {
        alertGreenDiv.innerHTML = `<div style="color:red;">Erreur globale : ${e.message}</div>`;
        alertRedDiv.innerHTML = '';
    }
}

main();
</script>

</body>
</html>
