<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Variation 1m — 10/10/2025 23h00–23h59 (Europe/Brussels)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#94a3b8;
      --up:#16a34a; --down:#dc2626; --zero:#64748b; --border:#1f2937; --header:#0b1220; --accent:#2563eb;
    }
    *{box-sizing:border-box}
    body{margin:0;background:#0b1020;color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;padding:24px}
    header{max-width:1200px;margin:0 auto 16px;display:flex;gap:12px;align-items:baseline;flex-wrap:wrap}
    header h1{margin:0;font-size:20px;font-weight:700}
    .meta{color:var(--muted);font-size:14px}
    .controls{margin-left:auto}
    .controls button{background:var(--accent);border:0;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer}

    /* Bandeau variation négative */
    #variation_negative{
      max-width:1200px;margin:8px auto 16px;
      background:linear-gradient(180deg,rgba(220,38,38,.1),rgba(220,38,38,.04)), var(--card);
      border:1px solid rgba(220,38,38,.35);
      color:#fecaca; /* rouge clair */
      padding:10px 12px;border-radius:12px;font-size:14px;
    }
    #variation_negative .title{font-weight:700;color:#fca5a5}
    #variation_negative .times{color:#ffd1d1}

    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(380px,1fr));gap:16px;max-width:1200px;margin:0 auto}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),transparent),var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden}
    .card header{background:var(--header);border-bottom:1px solid var(--border);padding:10px 12px;display:flex;gap:10px;align-items:center}
    .symbol{font-weight:700;letter-spacing:.3px}
    .status{margin-left:auto;font-size:12px;color:var(--muted)}
    .table-wrap{max-height:70vh;overflow:auto}
    table{width:100%;border-collapse:separate;border-spacing:0;font-variant-numeric:tabular-nums}
    thead th{position:sticky;top:0;background:var(--header);border-bottom:1px solid var(--border);padding:6px 8px;font-size:12px;color:var(--muted);text-align:left}
    tbody td, tbody th{border-bottom:1px solid rgba(255,255,255,.06);padding:6px 8px;font-size:12px}
    tbody td.time{color:var(--muted)}
    .pct{font-weight:600;text-align:right}
    .up{color:var(--up)} .down{color:var(--down)} .zero{color:var(--zero)}
    .loading,.error{padding:10px 12px;border-top:1px solid var(--border);font-size:13px;color:var(--muted)}
    .error{color:#fca5a5}
    footer.small{max-width:1200px;margin:18px auto 0;color:var(--muted);font-size:12px}
  </style>
</head>
<body>
  <header>
    <h1>Variation 1m — Heure 23h (Europe/Brussels)</h1>
    <div class="meta">Date : <strong>10/10/2025</strong> • Plage : <strong>23:00 → 23:59</strong> • Timeframe : <strong>1m</strong></div>
    <div class="controls"><button id="reload">Recharger</button></div>
  </header>

  <!-- Bandeau d’alerte quand toutes les cryptos sont négatives à une ou plusieurs minutes -->
  <div id="variation_negative">Analyse en cours…</div>

  <div id="grid" class="grid"></div>

  <footer class="small">
    Chaque carte affiche les 60 minutes de 23:00 à 23:59 pour le 10/10/2025 (Europe/Brussels).
  </footer>

<script>
(async () => {
  // --- Paramètres utilisateur ---
  const symbols = [
    "AEVOUSDT","ARPAUSDT","AXLUSDT","DIAUSDT","EGLDUSDT","IDUSDT","RONINUSDT","WLDUSDT",
    "1000SATSUSDT","ANKRUSDT","DENTUSDT","ENJUSDT","NXPCUSDT"
  ];
  const timeZone = "Europe/Brussels";
  const interval = "1m";

  // --- Calcul précis de la fenêtre horaire locale 2025-10-10 23:00 → 23:59:59.999 (Brussels) ---
  function localToUtcMs(y, m /*1-12*/, d, hh, mm, ss, ms, tz) {
    // Construit une date "approx" en UTC puis corrige avec l'offset du fuseau à ce moment-là
    const approxUtc = Date.UTC(y, m-1, d, hh, mm, ss, ms);
    const offset = tzOffsetMsAt(new Date(approxUtc), tz);
    return approxUtc - offset;
  }
  function tzOffsetMsAt(date, tz) {
    const dtf = new Intl.DateTimeFormat('en-GB', {
      timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
    });
    const parts = dtf.formatToParts(date);
    const map = {};
    for (const p of parts) map[p.type] = p.value;
    const asUTC = Date.UTC(+map.year, +map.month-1, +map.day, +map.hour, +map.minute, +map.second);
    return asUTC - date.getTime();
  }

  // 10/10/2025 23:00:00.000 → 23:59:59.999 (heure Brussels)
  const startTime = localToUtcMs(2025, 10, 10, 23, 0, 0, 0, timeZone);
  const endTime   = localToUtcMs(2025, 10, 10, 23, 59, 59, 999, timeZone);

  // --- UI helpers ---
  const grid = document.getElementById('grid');
  const banner = document.getElementById('variation_negative');

  function buildCard(symbol) {
    const card = document.createElement('div'); card.className = 'card';
    const head = document.createElement('header');
    const symEl = document.createElement('div'); symEl.className = 'symbol'; symEl.textContent = symbol;
    const status = document.createElement('div'); status.className = 'status'; status.textContent = 'Chargement…';
    head.appendChild(symEl); head.appendChild(status);

    const wrap = document.createElement('div'); wrap.className = 'table-wrap';
    const table = document.createElement('table');
    table.innerHTML = `
      <thead><tr><th>Heure (Brussels)</th><th style="text-align:right">Variation (1m)</th></tr></thead>
      <tbody></tbody>
    `;
    const tbody = table.querySelector('tbody');

    // 60 lignes vides 23:00 → 23:59
    for (let i = 0; i < 60; i++) {
      const tr = document.createElement('tr');
      const t = document.createElement('td'); t.className = 'time';
      t.textContent = `23:${String(i).padStart(2,'0')}`;
      const v = document.createElement('td'); v.className = 'pct zero'; v.textContent = '—';
      tr.appendChild(t); tr.appendChild(v); tbody.appendChild(tr);
    }

    wrap.appendChild(table);
    const loading = document.createElement('div'); loading.className = 'loading'; loading.textContent = 'Requête klines 1m…';

    card.appendChild(head); card.appendChild(wrap); card.appendChild(loading);
    grid.appendChild(card);

    return { card, statusEl: status, loadingEl: loading, tbody };
  }

  function pctChange(open, close) {
    const o = Number(open), c = Number(close);
    if (!isFinite(o) || o === 0 || !isFinite(c)) return null;
    return ((c - o) / o) * 100;
  }

  // Place une bougie à son minute-index en Europe/Brussels
  function minuteIndexIn23h(openTimeMs) {
    // Convertit l’openTime (UTC) en heure Brussels et renvoie la minute si l’heure==23, sinon -1
    const dt = new Date(openTimeMs);
    const fmt = new Intl.DateTimeFormat('fr-BE', { timeZone: timeZone, hour: '2-digit', minute: '2-digit', hour12: false });
    const [hStr, mStr] = fmt.format(dt).split(':');
    const h = Number(hStr), m = Number(mStr);
    return h === 23 ? m : -1;
  }

  async function fetchKlines(symbol) {
    const url = new URL('https://api.binance.com/api/v3/klines');
    url.searchParams.set('symbol', symbol);
    url.searchParams.set('interval', interval);
    url.searchParams.set('startTime', String(startTime));
    url.searchParams.set('endTime', String(endTime));
    url.searchParams.set('limit', '1000'); // suffisant pour 60 bougies
    const res = await fetch(url.toString());
    if (!res.ok) {
      const txt = await res.text().catch(()=> '');
      throw new Error(`HTTP ${res.status} ${res.statusText} — ${txt}`);
    }
    const data = await res.json();
    if (!Array.isArray(data)) throw new Error('Réponse inattendue de Binance.');
    return data;
  }

  // Enregistre les variations négatives par symbole et par minute (0..59)
  const negBySymbol = new Map();   // symbol -> Array(60) de booleans (true si négatif), undefined si pas de donnée
  const dataBySymbol = new Map();  // symbol -> Array(60) de booleans (true si on a une bougie pour cette minute)

  function renderHour23(tbody, klines, symbol) {
    const negArr = Array(60).fill(undefined);
    const hasArr = Array(60).fill(false);

    let filled = 0;
    for (const k of klines) {
      const openTime = k[0];       // open time (ms)
      const open = k[1];
      const close = k[4];
      const idx = minuteIndexIn23h(openTime);
      if (idx >= 0 && idx < 60) {
        const p = pctChange(open, close);
        const row = tbody.children[idx];
        const cell = row.children[1];

        if (p === null) {
          cell.textContent = 'n/a';
          cell.className = 'pct zero';
          negArr[idx] = undefined;
          hasArr[idx] = false;
        } else {
          cell.textContent = (p >= 0 ? '+' : '') + p.toFixed(3) + '%';
          cell.className = 'pct ' + (p > 0 ? 'up' : (p < 0 ? 'down' : 'zero'));
          negArr[idx] = (p < 0);
          hasArr[idx] = true;
        }
        filled++;
      }
    }

    negBySymbol.set(symbol, negArr);
    dataBySymbol.set(symbol, hasArr);
    return filled;
  }

  const cards = symbols.map(s => ({ symbol: s, ...buildCard(s) }));

  function updateNegativeBanner() {
    // Cherche toutes les minutes m où, pour tous les symbols,
    // on a une donnée ET elle est négative.
    const minutesAllNeg = [];
    for (let m = 0; m < 60; m++) {
      let allNeg = true;
      for (const s of symbols) {
        const hasArr = dataBySymbol.get(s);
        const negArr = negBySymbol.get(s);
        if (!hasArr || !negArr || !hasArr[m] || negArr[m] !== true) {
          allNeg = false; break;
        }
      }
      if (allNeg) minutesAllNeg.push(m);
    }

    if (minutesAllNeg.length === 0) {
      banner.innerHTML = `<span class="title">Variation négative synchronisée :</span> aucune minute entre 23:00 et 23:59 où <em>toutes</em> les cryptos sont négatives (données complètes requises).`;
    } else {
      const times = minutesAllNeg.map(m => `23:${String(m).padStart(2,'0')}`).join(', ');
      banner.innerHTML = `<span class="title">Variation négative synchronisée :</span> à <span class="times">${times}</span>, <strong>toutes</strong> les cryptos étaient négatives.`;
    }
  }

  async function loadAll() {
    banner.textContent = 'Analyse en cours…';
    await Promise.all(cards.map(async (c) => {
      c.statusEl.textContent = 'Chargement…';
      c.loadingEl.className = 'loading';
      c.loadingEl.textContent = 'Requête klines 1m…';
      try {
        const kl = await fetchKlines(c.symbol);
        const count = renderHour23(c.tbody, kl, c.symbol);
        c.statusEl.textContent = `OK • ${count}/60 minutes`;
        if (count < 60) {
          c.loadingEl.className = 'error';
          c.loadingEl.textContent = `Données manquantes pour certaines minutes (${count}/60).`;
        } else {
          c.loadingEl.textContent = 'Terminé.';
        }
      } catch (e) {
        c.statusEl.textContent = 'Erreur';
        c.loadingEl.className = 'error';
        c.loadingEl.textContent = 'Échec: ' + (e?.message || e);
        // En cas d'erreur, on force des tableaux vides pour éviter un "allNeg" faux-positif
        negBySymbol.set(c.symbol, Array(60).fill(undefined));
        dataBySymbol.set(c.symbol, Array(60).fill(false));
      }
    }));
    updateNegativeBanner();
  }

  // 1er chargement + bouton
  loadAll();
  document.getElementById('reload').addEventListener('click', loadAll);
})();
</script>
</body>
</html>
