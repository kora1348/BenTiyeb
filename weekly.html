<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liquidations Binance - Alerte Ultra-Pr√©cise</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #0e1621;
  color: #e3eaf2;
  margin: 0;
  padding: 20px;
}
.container {
  max-width: 1000px;
  margin: 0 auto;
  background: #17212b;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}
h1 {
  color: #64b5f6;
  text-align: center;
  margin-bottom: 20px;
}
.alert-banner {
  background: #1f2d3b;
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 15px;
  font-weight: bold;
  border-left: 4px solid #64b5f6;
  line-height: 1.5em;
  white-space: pre-line;
}
.alert-short {
  border-left-color: #ff5252;
}
.alert-long {
  border-left-color: #4caf50;
}
select {
  width: 100%;
  padding: 12px;
  background: #2b3a4a;
  color: white;
  border: 1px solid #3d4f62;
  border-radius: 6px;
  font-size: 16px;
  margin-bottom: 20px;
}
.chart-container {
  background: #1f2d3b;
  padding: 15px;
  border-radius: 10px;
  margin-bottom: 20px;
  border-left: 4px solid #64b5f6;
}
canvas {
  width: 100% !important;
  height: 350px !important;
}
.price-info {
  background: #252b3b;
  padding: 15px;
  border-radius: 8px;
  margin-top: 15px;
}
.red { color: #ff5252; font-weight: bold; }
.green { color: #4caf50; font-weight: bold; }
.highlight {
  background: #3a4466;
  padding: 2px 6px;
  border-radius: 4px;
}
.loading {
  color: #64b5f6;
  text-align: center;
  padding: 20px;
  font-style: italic;
}
.accuracy-indicator {
  font-size: 12px;
  color: #aaa;
  margin-top: 5px;
}
.filter-panel {
  background: #1f2d3b;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 15px;
}
.filter-control {
  margin: 10px 0;
}
.filter-label {
  display: block;
  margin-bottom: 5px;
}
.filter-slider {
  width: 100%;
}
.filter-value {
  color: #64b5f6;
  font-weight: bold;
}
.real-liquidations {
  margin-top: 10px;
  font-size: 14px;
  color: #888;
}
</style>
</head>
<body>
<div class="container">
  <h1>üî• Liquidations Binance - Version Ultra-Pr√©cise</h1>

  <div class="filter-panel">
    <div class="filter-control">
      <label class="filter-label">Distance maximale: <span class="filter-value" id="distanceValue">10%</span></label>
      <input type="range" min="1" max="30" value="10" class="filter-slider" id="distanceFilter">
    </div>
    <div class="filter-control">
      <label class="filter-label">Seuil de confiance: <span class="filter-value" id="confidenceValue">3 √©toiles</span></label>
      <input type="range" min="1" max="5" value="3" class="filter-slider" id="confidenceFilter">
    </div>
  </div>

  <div id="shortAlert" class="alert-banner alert-short" style="display: none;"></div>
  <div id="longAlert" class="alert-banner alert-long" style="display: none;"></div>

  <select id="cryptoSelect">
    <option value="">Chargement des cryptos...</option>
  </select>

  <div class="chart-container">
    <canvas id="priceChart"></canvas>
  </div>

  <div class="price-info" id="priceInfo">
    S√©lectionnez une cryptomonnaie pour voir les donn√©es d√©taill√©es.
  </div>
</div>

<script>
let priceChart = null;
let allSymbols = [];
let shortAlerts = [];
let longAlerts = [];
let realLiquidations = {};

// Param√®tres configurables
const SETTINGS = {
  MAX_DISTANCE: 5,  // Chang√© de 10 √† 5
  MIN_CONFIDENCE: 4, // Chang√© de 3 √† 4
  SHORT_BUFFER: 0.98,
  LONG_BUFFER: 1.02,
  VOLATILITY_WINDOW: 14,
  USE_SMOOTHING: true
};

// Chargement initial
document.addEventListener('DOMContentLoaded', () => {
  // CORRECTION : Mise √† jour des valeurs affich√©es AVANT le chargement
  document.getElementById('distanceValue').textContent = SETTINGS.MAX_DISTANCE + '%';
  document.getElementById('confidenceValue').textContent = SETTINGS.MIN_CONFIDENCE + ' √©toiles';
  document.getElementById('distanceFilter').value = SETTINGS.MAX_DISTANCE;
  document.getElementById('confidenceFilter').value = SETTINGS.MIN_CONFIDENCE;

  loadAllSymbols();
  setupEventListeners();
  setInterval(checkAllLiquidations, 3 * 60 * 1000);
});
function setupEventListeners() {
  document.getElementById('cryptoSelect').addEventListener('change', loadChart);
  
  document.getElementById('distanceFilter').addEventListener('input', function(e) {
    SETTINGS.MAX_DISTANCE = parseInt(e.target.value);
    document.getElementById('distanceValue').textContent = SETTINGS.MAX_DISTANCE + '%';
    checkAllLiquidations();
  });
  
  document.getElementById('confidenceFilter').addEventListener('input', function(e) {
    SETTINGS.MIN_CONFIDENCE = parseInt(e.target.value);
    document.getElementById('confidenceValue').textContent = SETTINGS.MIN_CONFIDENCE + ' √©toiles';
    checkAllLiquidations();
  });
}

async function loadAllSymbols() {
  try {
    const [exchangeInfo, liquidations] = await Promise.all([
      axios.get('https://fapi.binance.com/fapi/v1/exchangeInfo'),
      fetchRealLiquidations()
    ]);
    
    allSymbols = exchangeInfo.data.symbols
      .filter(s => s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT')
      .map(s => s.symbol);
    
    realLiquidations = processRealLiquidations(liquidations);
    updateSelect();
    await checkAllLiquidations();
  } catch (e) {
    console.error("Erreur de chargement:", e);
  }
}

async function fetchRealLiquidations() {
  try {
    const response = await axios.get('https://fapi.binance.com/fapi/v1/allForceOrders?limit=1000');
    return response.data;
  } catch (e) {
    console.warn("Impossible de r√©cup√©rer les liquidations r√©elles, utilisation des estimations");
    return [];
  }
}

function processRealLiquidations(liquidations) {
  const result = {};
  
  liquidations.forEach(liq => {
    if (!result[liq.symbol]) {
      result[liq.symbol] = { shorts: [], longs: [] };
    }
    
    if (liq.side === 'SELL') { // Liquidation short
      result[liq.symbol].shorts.push({
        price: parseFloat(liq.price),
        time: new Date(liq.time),
        quantity: parseFloat(liq.executedQty)
      });
    } else { // Liquidation long
      result[liq.symbol].longs.push({
        price: parseFloat(liq.price),
        time: new Date(liq.time),
        quantity: parseFloat(liq.executedQty)
      });
    }
  });
  
  return result;
}

async function checkAllLiquidations() {
  shortAlerts = [];
  longAlerts = [];
  
  const toCheck = allSymbols.slice(0, 100); // Limit√© aux 100 premi√®res pour performance

  const tasks = toCheck.map(async (symbol) => {
    try {
      const [priceData, liqData] = await Promise.all([
        fetchPriceData(symbol),
        fetchLiquidationData(symbol)
      ]);
      
      const lastPrice = priceData[priceData.length - 1].close;
      const zones = calculateLiquidationZones(symbol, priceData, liqData);
      const confidence = calculateConfidenceScore(priceData, liqData);
      
      // Calcul des distances (toujours positives)
      const distanceShort = Math.abs(((zones.short - lastPrice) / lastPrice) * 100);
      const distanceLong = Math.abs(((lastPrice - zones.long) / lastPrice) * 100);

      // Filtrage bas√© sur les param√®tres
      if (distanceShort < SETTINGS.MAX_DISTANCE && confidence.short * 5 >= SETTINGS.MIN_CONFIDENCE) {
        shortAlerts.push(createAlertData(symbol, lastPrice, zones.short, distanceShort, confidence.short, 'short'));
      }

      if (distanceLong < SETTINGS.MAX_DISTANCE && confidence.long * 5 >= SETTINGS.MIN_CONFIDENCE) {
        longAlerts.push(createAlertData(symbol, lastPrice, zones.long, distanceLong, confidence.long, 'long'));
      }
    } catch (e) {
      console.warn(`Erreur avec ${symbol}:`, e.message);
    }
  });

  await Promise.all(tasks);
  updateAlertDisplays();
}

function createAlertData(symbol, price, liqPrice, distance, confidence, type) {
  return {
    symbol,
    price: price.toFixed(4),
    liq: liqPrice.toFixed(4),
    dist: distance.toFixed(2),
    confidence,
    type,
    realLiq: realLiquidations[symbol]?.[type === 'short' ? 'shorts' : 'longs'] || []
  };
}

function updateAlertDisplays() {
  const shortBox = document.getElementById('shortAlert');
  const longBox = document.getElementById('longAlert');
  
  // Tri par distance (plus proche en premier)
  shortAlerts.sort((a, b) => a.dist - b.dist);
  longAlerts.sort((a, b) => a.dist - b.dist);

  // Affichage des shorts
  if (shortAlerts.length > 0) {
    shortBox.innerHTML = shortAlerts.map(s => 
      `üìâ ${s.symbol} ‚Äî Prix: ${s.price}, Liq: ${s.liq} (Distance: +${s.dist}%) ${getConfidenceStars(s.confidence)}
      ${getRealLiquidationInfo(s.realLiq)}`
    ).join('\n');
    shortBox.style.display = 'block';
  } else {
    shortBox.style.display = 'none';
  }

  // Affichage des longs
  if (longAlerts.length > 0) {
    longBox.innerHTML = longAlerts.map(s =>
      `üìà ${s.symbol} ‚Äî Prix: ${s.price}, Liq: ${s.liq} (Distance: -${s.dist}%) ${getConfidenceStars(s.confidence)}
      ${getRealLiquidationInfo(s.realLiq)}`
    ).join('\n');
    longBox.style.display = 'block';
  } else {
    longBox.style.display = 'none';
  }
}

function getRealLiquidationInfo(liquidations) {
  if (liquidations.length === 0) return '';
  
  const lastLiq = liquidations[0];
  const liqCount = liquidations.length;
  const totalQty = liquidations.reduce((sum, liq) => sum + liq.quantity, 0);
  
  return `<div class="real-liquidations">
    Liquidations r√©centes: ${liqCount} (Total: ${totalQty.toFixed(2)})
  </div>`;
}

async function fetchPriceData(symbol) {
  const res = await axios.get(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=1h&limit=48`);
  return res.data.map(d => ({
    time: new Date(d[0]),
    open: +d[1], high: +d[2], low: +d[3], close: +d[4],
    volume: +d[5]
  }));
}

async function fetchLiquidationData(symbol) {
  return realLiquidations[symbol] || { shorts: [], longs: [] };
}

function calculateLiquidationZones(symbol, priceData, liqData) {
  // 1. Calcul bas√© sur les liquidations r√©elles si disponibles
  if (liqData.shorts.length > 0 || liqData.longs.length > 0) {
    const realShort = liqData.shorts.length > 0 ? 
      weightedAverage(liqData.shorts.map(liq => liq.price)) : null;
    
    const realLong = liqData.longs.length > 0 ? 
      weightedAverage(liqData.longs.map(liq => liq.price)) : null;
    
    // 2. Calcul estim√© comme fallback
    const estimated = calculateEstimatedZones(priceData);
    
    return {
      short: realShort || estimated.short,
      long: realLong || estimated.long,
      isReal: !!realShort || !!realLong
    };
  }
  
  // 3. Retourner seulement l'estimation si aucune donn√©e r√©elle
  return calculateEstimatedZones(priceData);
}

function calculateEstimatedZones(priceData) {
  const highs = priceData.map(d => d.high);
  const lows = priceData.map(d => d.low);
  const closes = priceData.map(d => d.close);
  
  // Calcul de la volatilit√©
  const volatility = calculateVolatility(closes);
  
  // Filtrage des valeurs extr√™mes
  const filteredHighs = filterOutliers(highs);
  const filteredLows = filterOutliers(lows);
  
  // Ajustement dynamique bas√© sur la volatilit√©
  const shortBuffer = SETTINGS.SHORT_BUFFER - (volatility * 0.3);
  const longBuffer = SETTINGS.LONG_BUFFER + (volatility * 0.3);
  
  return {
    short: weightedAverage(filteredHighs) * shortBuffer,
    long: weightedAverage(filteredLows) * longBuffer
  };
}

function calculateConfidenceScore(priceData, liqData) {
  // Score bas√© sur les liquidations r√©elles
  if (liqData.shorts.length > 0 || liqData.longs.length > 0) {
    const recency = calculateRecencyScore(liqData);
    const quantityScore = Math.min(1, liqData.shorts.concat(liqData.longs).reduce((sum, liq) => sum + liq.quantity, 0) / 1000);
    
    return {
      short: liqData.shorts.length > 0 ? 0.8 + (0.2 * recency) + (0.1 * quantityScore) : 0.5,
      long: liqData.longs.length > 0 ? 0.8 + (0.2 * recency) + (0.1 * quantityScore) : 0.5
    };
  }
  
  // Score bas√© sur l'estimation (volatilit√© + volume)
  const volatility = calculateVolatility(priceData.map(d => d.close));
  const volumeScore = Math.min(1, priceData.reduce((sum, d) => sum + d.volume, 0) / 100000);
  
  return {
    short: Math.min(1, 0.7 - (volatility * 2) + (volumeScore * 0.3)),
    long: Math.min(1, 0.7 - (volatility * 2) + (volumeScore * 0.3))
  };
}

function calculateRecencyScore(liqData) {
  const now = Date.now();
  const lastShort = liqData.shorts.length > 0 ? Math.max(...liqData.shorts.map(liq => liq.time.getTime())) : 0;
  const lastLong = liqData.longs.length > 0 ? Math.max(...liqData.longs.map(liq => liq.time.getTime())) : 0;
  
  const shortRecency = lastShort > 0 ? Math.max(0, 1 - (now - lastShort) / (24 * 60 * 60 * 1000)) : 0;
  const longRecency = lastLong > 0 ? Math.max(0, 1 - (now - lastLong) / (24 * 60 * 60 * 1000)) : 0;
  
  return Math.max(shortRecency, longRecency);
}

function calculateVolatility(prices) {
  if (prices.length < 2) return 0;
  
  const returns = [];
  for (let i = 1; i < prices.length; i++) {
    returns.push(Math.log(prices[i] / prices[i-1]));
  }
  
  const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
  const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
  
  return Math.sqrt(variance) * Math.sqrt(365); // Volatilit√© annualis√©e
}

function filterOutliers(values) {
  if (values.length < 3) return values;
  
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const stdDev = Math.sqrt(values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length);
  
  return values.filter(v => Math.abs(v - mean) <= stdDev * 1.5);
}

function weightedAverage(values, weights) {
  if (!weights) {
    weights = [];
    const totalWeights = values.length * (values.length + 1) / 2;
    for (let i = 0; i < values.length; i++) {
      weights.push((i + 1) / totalWeights);
    }
  }
  
  return values.reduce((a, v, i) => a + v * weights[i], 0);
}

function getConfidenceStars(confidence) {
  const stars = '‚òÖ'.repeat(Math.round(confidence * 5));
  return `[${stars.padEnd(5, '‚òÜ')}]`;
}

function updateSelect() {
  const select = document.getElementById('cryptoSelect');
  select.innerHTML = allSymbols.map(s => `<option value="${s}">${s}</option>`).join('');
}

async function loadChart() {
  const symbol = document.getElementById('cryptoSelect').value;
  if (!symbol) return;

  document.getElementById('priceInfo').innerHTML = `<div class="loading">Chargement des donn√©es pour ${symbol}...</div>`;

  try {
    const [priceData, liqData] = await Promise.all([
      fetchPriceData(symbol),
      fetchLiquidationData(symbol)
    ]);
    
    const zones = calculateLiquidationZones(symbol, priceData, liqData);
    updateChart(symbol, priceData, zones);
    updateInfo(symbol, priceData, zones);
  } catch (e) {
    document.getElementById('priceInfo').innerHTML = `<span class="red">Erreur : ${e.message}</span>`;
  }
}

function updateChart(symbol, data, zones) {
  const ctx = document.getElementById('priceChart').getContext('2d');
  if (priceChart) priceChart.destroy();

  const annotations = {
    shortLine: {
      type: 'line',
      yMin: zones.short,
      yMax: zones.short,
      borderColor: '#ff5252',
      borderWidth: 2,
      borderDash: [5, 5],
      label: {
        content: `Short ~${zones.short.toFixed(2)}`,
        display: true,
        backgroundColor: 'rgba(255,82,82,0.7)'
      }
    },
    longLine: {
      type: 'line',
      yMin: zones.long,
      yMax: zones.long,
      borderColor: '#4caf50',
      borderWidth: 2,
      borderDash: [5, 5],
      label: {
        content: `Long ~${zones.long.toFixed(2)}`,
        display: true,
        backgroundColor: 'rgba(76,175,80,0.7)'
      }
    }
  };

  priceChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.map(d => d.time.toLocaleTimeString()),
      datasets: [{
        label: `${symbol} Prix`,
        data: data.map(d => d.close),
        borderColor: '#64b5f6',
        tension: 0.1,
        pointRadius: 0,
        borderWidth: 2
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: false },
        annotation: { annotations }
      },
      scales: {
        x: { grid: { color: '#2b3a4a' } },
        y: { grid: { color: '#2b3a4a' } }
      }
    }
  });
}

function updateInfo(symbol, data, zones) {
  const last = data[data.length - 1].close;
  const distShort = Math.abs(((zones.short - last) / last * 100)).toFixed(2);
  const distLong = Math.abs(((last - zones.long) / last * 100)).toFixed(2);
  const confidence = calculateConfidenceScore(data, realLiquidations[symbol] || { shorts: [], longs: [] });

  document.getElementById('priceInfo').innerHTML = `
    <strong>${symbol}</strong> ‚Äî Dernier prix: <span class="highlight">${last.toFixed(4)}</span>
    <div class="accuracy-indicator">Pr√©cision: ${getConfidenceStars((confidence.short + confidence.long)/2)} ${zones.isReal ? '(Bas√© sur donn√©es r√©elles)' : '(Estimation)'}</div><br>
    <span class="red">üìâ Liquidation Short: ${zones.short.toFixed(4)}</span><br>
    Distance: <span class="red">+${distShort}%</span><br><br>
    <span class="green">üìà Liquidation Long: ${zones.long.toFixed(4)}</span><br>
    Distance: <span class="green">-${distLong}%</span>
  `;
}
</script>
</body>
</html>