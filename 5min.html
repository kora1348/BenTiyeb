<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Analyse Cryptos Baissi√®res</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --ok:#10b981; --bad:#ef4444; --text:#e5e7eb; --border:#1f2937; --warn:#f59e0b; }
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:18px;border-bottom:1px solid var(--border)}
    h1{margin:0;font-size:18px}
    .sub{color:var(--muted);font-size:13px;line-height:1.4;margin-top:6px}
    .wrap{padding:16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px;margin-bottom:16px}
    table{width:100%;border-collapse:collapse;font-size:12px}
    th,td{border-bottom:1px solid var(--border);padding:6px 8px;white-space:nowrap}
    th{position:sticky;top:0;background:var(--card);text-align:left;z-index:1}
    .pos{color:var(--ok);font-variant-numeric:tabular-nums}
    .neg{color:var(--bad);font-variant-numeric:tabular-nums}
    .na{color:var(--muted)}
    .warn{color:var(--warn)}
    .results-grid {display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px;}
    .crypto-list {max-height: 400px; overflow-y: auto;}
    .time-slots {max-height: 400px; overflow-y: auto;}
    .highlight {background: rgba(239, 68, 68, 0.1); border-left: 3px solid var(--bad);}
  </style>
</head>
<body>
  <header>
    <h1>Analyse des Cryptomonnaies Baissi√®res</h1>
    <div class="sub">
      D√©tection automatique des cryptos avec pattern : 1√®re bougie haussi√®re, 3 suivantes baissi√®res<br>
      Timeframe : <strong>5 minutes</strong> ‚Äî Points analys√©s : 14/10/25 23:35, 15/10/25 09:45, 19/10/25 12:50, 23/10/25 22:05 (Europe/Brussels)
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <h3>R√©sultats de l'Analyse</h3>
      <div class="results-grid">
        <div class="crypto-list">
          <h4>üìâ Cryptos ‚â•80% Baissi√®res</h4>
          <div id="bearish-cryptos">Calcul en cours...</div>
        </div>
        <div class="time-slots">
          <h4>üïí Heures de Baisse G√©n√©ralis√©e</h4>
          <div id="bearish-hours">Calcul en cours...</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Donn√©es Brutes (4 p√©riodes de 5m)</h3>
      <div style="overflow:auto; max-height:75vh;">
        <table id="table">
          <thead>
            <tr id="thead-row">
              <th>Symbole</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
      <p id="progress" class="warn">Pr√©paration‚Ä¶</p>
    </div>
  </div>

  <script>
    const BASE = "https://fapi.binance.com";
    const INTERVAL = "5m";              // timeframe 5 minutes
    const TF_MS = 5 * 60 * 1000;
    const MAX_CONCURRENCY = 8;
    const BEARISH_THRESHOLD = 0.8;      // utilis√© pour les heures (üïí)

    const TZ = "Europe/Brussels";

    // ==============================
    // 1) OUTILS TZ Brussels <-> UTC
    // ==============================
    function tzOffsetMsAt(date, tz) {
      const fmt = new Intl.DateTimeFormat('en-GB', {
        timeZone: tz,
        year:'numeric', month:'2-digit', day:'2-digit',
        hour:'2-digit', minute:'2-digit', second:'2-digit',
        hour12:false
      });
      const parts = Object.fromEntries(fmt.formatToParts(date).map(p => [p.type, p.value]));
      const asUTC = Date.UTC(+parts.year, +parts.month - 1, +parts.day, +parts.hour, +parts.minute, +parts.second);
      return asUTC - date.getTime();
    }

    function brusselsLocalToUtcMs(y, m, d, h, min) {
      const approxUtc = Date.UTC(y, m - 1, d, h, min, 0, 0);
      const offset = tzOffsetMsAt(new Date(approxUtc), TZ);
      return approxUtc - offset;
    }

    function formatBrusselsLabel(utcMs) {
      const fmt = new Intl.DateTimeFormat("fr-BE", {
        timeZone: TZ,
        year: "2-digit",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        hour12: false
      });
      return fmt.format(new Date(utcMs)).replace(",", "");
    }

    function floorToTfOpenUtc(msUtc, tfMs) {
      return msUtc - (msUtc % tfMs);
    }

    // =======================================================
    // 2) G√âN√àRE LES BOUGIES 5m POUR LES 4 DATES DEMAND√âES
    // =======================================================
    function generateSpecificPoints() {
      const localPoints = [
        { y: 2025, m: 10, d: 14, h: 23, min: 35 },
        { y: 2025, m: 10, d: 15, h:  9, min: 45 },
        { y: 2025, m: 10, d: 19, h: 12, min: 50 },
        { y: 2025, m: 10, d: 23, h: 22, min:  5 }
      ];

      return localPoints.map(p => {
        const utcMs = brusselsLocalToUtcMs(p.y, p.m, p.d, p.h, p.min);
        const openTimeMs = floorToTfOpenUtc(utcMs, TF_MS);
        return {
          openTimeMs,
          label: formatBrusselsLabel(openTimeMs)
        };
      });
    }

    const points = generateSpecificPoints();

    // DOM refs
    const theadRow = document.getElementById("thead-row");
    const tbody = document.getElementById("tbody");
    const progress = document.getElementById("progress");
    const bearishCryptosEl = document.getElementById("bearish-cryptos");
    const bearishHoursEl = document.getElementById("bearish-hours");

    // Colonnes d'en-t√™te pour chaque bougie 5m
    for (const p of points) {
      const th = document.createElement("th");
      th.textContent = p.label;
      theadRow.appendChild(th);
    }

    // =============================================
    // 3) SYMBOLS PERP USDT TRADING
    // =============================================
    async function getAllPerpUsdtSymbols(){
      const r = await fetch(`${BASE}/fapi/v1/exchangeInfo`);
      if(!r.ok) throw new Error("exchangeInfo error");
      const info = await r.json();
      return info.symbols
        .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
        .map(s => s.symbol)
        .sort();
    }

    // =============================================
    // 4) FETCH KLINE 5m EXACTE
    // =============================================
    async function fetchKlinePct(symbol, openTimeMs){
      const url = `${BASE}/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&startTime=${openTimeMs}&limit=1`;
      const r = await fetch(url);
      if(!r.ok) return null;
      const data = await r.json();
      if(!Array.isArray(data) || data.length === 0) return null;

      const k = data[0];
      if(+k[0] !== openTimeMs) return null;

      const open = parseFloat(k[1]), close = parseFloat(k[4]);
      if(!isFinite(open) || !isFinite(close) || open === 0) return null;

      return (close - open) / open * 100;
    }

    function fmtPct(v){
      if(v == null) return `<span class="na">‚Äî</span>`;
      const cls = v >= 0 ? "pos" : "neg";
      return `<span class="${cls}">${v.toFixed(2)}%</span>`;
    }

    // =============================================
    // 5) ANALYSE DES DONN√âES
    // =============================================
    function analyzeData(cryptoData) {
      const bearishCryptos = [];
      
      // ---- 5.1 Filtre "1√®re + / 3 suivantes -" pour la liste des cryptos ----
      for (const [symbol, data] of Object.entries(cryptoData)) {
        // On travaille sur les 4 points d√©finis
        if (data.length < points.length) continue;

        const vals = data.slice(0, points.length);
        // si une valeur est null (kline manquante), on zappe
        if (vals.some(v => v == null)) continue;

        const [v0, v1, v2, v3] = vals;

        // Condition demand√©e :
        //  - v0 > 0   => 1√®re bougie haussi√®re
        //  - v1, v2, v3 < 0 => 3 bougies suivantes baissi√®res
        if (v0 > 0 && v1 < 0 && v2 < 0 && v3 < 0) {
          const negativeCount = [v0, v1, v2, v3].filter(v => v < 0).length;
          const totalPeriods = vals.length;
          const bearishRatio = (negativeCount / totalPeriods) * 100;

          bearishCryptos.push({
            symbol,
            bearishRatio: bearishRatio.toFixed(1),
            negativeCount,
            totalPeriods
          });
        }
      }
      
      // Trie par % de baisses (ce sera souvent 75% avec 3/4, mais on garde la logique)
      bearishCryptos.sort((a, b) => b.bearishRatio - a.bearishRatio);
      
      // ---- 5.2 Analyse des heures baissi√®res (‚â•80% du march√© en baisse) ----
      const timeSlotAnalysis = [];
      
      for (let i = 0; i < points.length; i++) {
        let negativeCount = 0;
        let totalCount = 0;
        
        for (const [, data] of Object.entries(cryptoData)) {
          const v = data[i];
          if (v !== null) {
            totalCount++;
            if (v < 0) negativeCount++;
          }
        }
        
        if (totalCount > 0) {
          const negativeRatio = negativeCount / totalCount;
          timeSlotAnalysis.push({
            time: points[i].label,
            negativeRatio: (negativeRatio * 100).toFixed(1),
            negativeCount,
            totalCount
          });
        }
      }
      
      const veryBearishHours = timeSlotAnalysis.filter(hour => 
        (hour.negativeCount / hour.totalCount) >= BEARISH_THRESHOLD
      );
      
      return { bearishCryptos, veryBearishHours, timeSlotAnalysis };
    }

    // =============================================
    // 6) AFFICHAGE DES R√âSULTATS
    // =============================================
    function displayResults(analysis) {
      // Liste des cryptos (pattern +---)
      if (analysis.bearishCryptos.length > 0) {
        let html = '<table style="width:100%;font-size:11px;">';
        html += '<tr><th>Cryptos</th><th>P√©riodes<br>n√©gatives</th><th>Total</th><th>% Baisses</th></tr>';
        
        analysis.bearishCryptos.forEach(crypto => {
          html += `<tr>
            <td><strong>${crypto.symbol}</strong></td>
            <td>${crypto.negativeCount}</td>
            <td>${crypto.totalPeriods}</td>
            <td class="neg"><strong>${crypto.bearishRatio}%</strong></td>
          </tr>`;
        });
        
        html += '</table>';
        bearishCryptosEl.innerHTML = html;
      } else {
        bearishCryptosEl.innerHTML = '<p class="na">Aucune crypto ne pr√©sente le pattern 1√®re bougie haussi√®re + 3 suivantes baissi√®res</p>';
      }
      
      // Heures avec ‚â•80% du march√© en baisse
      if (analysis.veryBearishHours.length > 0) {
        let html = '<table style="width:100%;font-size:11px;">';
        html += '<tr><th>Heure</th><th>Cryptos<br>n√©gatives</th><th>Total</th><th>% March√©<br>baissier</th></tr>';
        
        analysis.veryBearishHours.forEach(hour => {
          html += `<tr class="highlight">
            <td><strong>${hour.time}</strong></td>
            <td>${hour.negativeCount}</td>
            <td>${hour.totalCount}</td>
            <td class="neg"><strong>${hour.negativeRatio}%</strong></td>
          </tr>`;
        });
        
        html += '</table>';
        bearishHoursEl.innerHTML = html;
      } else {
        bearishHoursEl.innerHTML = '<p class="na">Aucune p√©riode n\'a atteint le seuil de 80% du march√© en baisse</p>';
      }
    }

    // =============================================
    // 7) LIMITER CONCURRENCE
    // =============================================
    async function mapWithConcurrency(items, fn, concurrency){
      const results = new Array(items.length);
      let i = 0, active = 0, done = 0;
      return new Promise(resolve => {
        const next = () => {
          while(active < concurrency && i < items.length){
            const idx = i++, item = items[idx]; active++;
            Promise.resolve(fn(item, idx))
              .then(res => results[idx] = res)
              .catch(() => results[idx] = null)
              .finally(() => {
                active--; done++;
                if(done % 10 === 0) progress.textContent = `Progression : ${done}/${items.length}`;
                if(done === items.length) resolve(results);
                else next();
              });
          }
        };
        next();
      });
    }

    // =============================================
    // 8) MAIN
    // =============================================
    async function main(){
      progress.textContent = "R√©cup√©ration des symboles PERP USDT‚Ä¶";
      const symbols = await getAllPerpUsdtSymbols();

      const cryptoData = {};
      const rows = new Map();

      // lignes du tableau
      for(const s of symbols){
        const tr = document.createElement("tr");
        const tdSym = document.createElement("td");
        tdSym.textContent = s;
        tr.appendChild(tdSym);

        for(let i=0;i<points.length;i++){
          const td = document.createElement("td");
          td.innerHTML = `<span class="warn">‚Ä¶</span>`;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
        rows.set(s, tr);
        cryptoData[s] = new Array(points.length).fill(null);
      }

      // remplissage des variations
      await mapWithConcurrency(symbols, async (symbol) => {
        const tr = rows.get(symbol);

        for(let i=0;i<points.length;i++){
          try{
            const pct = await fetchKlinePct(symbol, points[i].openTimeMs);
            tr.children[i+1].innerHTML = fmtPct(pct);
            cryptoData[symbol][i] = pct;
          }catch{
            tr.children[i+1].innerHTML = `<span class="na">‚Äî</span>`;
          }
          await new Promise(r=>setTimeout(r,25));
        }
      }, MAX_CONCURRENCY);

      const analysis = analyzeData(cryptoData);
      displayResults(analysis);

      progress.textContent = `Termin√© ‚úÖ (${symbols.length} symboles analys√©s)`;
    }

    main().catch(e=>{
      console.error(e);
      progress.textContent = "Erreur : " + e.message;
    });
  </script>
</body>
</html>
