<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Radar Futures Binance avec d√©tection m√®ches</title>
  <style>
    body {
      background-color: #121212;
      color: #f0f0f0;
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    th, td {
      padding: 8px;
      text-align: center;
      border: 1px solid #333;
    }
    th {
      background-color: #1e1e1e;
    }
    tr.bearish { background-color: #3f1111; }
    tr.bullish { background-color: #113f2f; }
    tr.neutral { background-color: #2a2a2a; }
  </style>
</head>
<body>
  <h1>üìä Radar Liquidations Binance Futures avec d√©tection m√®ches</h1>
  <table id="cryptoTable">
    <thead>
      <tr>
        <th>Symbole</th>
        <th>Ratio L/S</th>
        <th>% Long</th>
        <th>% Short</th>
        <th>Funding Rate</th>
        <th>Open Interest (M$)</th>
        <th>Fourchette 24h (%)</th>
        <th>Signal</th>
      </tr>
    </thead>
    <tbody id="cryptoBody"></tbody>
  </table>

  <script>
    async function fetchAllData() {
      const tableBody = document.getElementById("cryptoBody");
      tableBody.innerHTML = "";

      try {
        // R√©cup√©rer la liste des symboles perp√©tuels USDT
        const exchangeInfo = await fetch("https://fapi.binance.com/fapi/v1/exchangeInfo").then(r => r.json());
        const symbols = exchangeInfo.symbols
          .filter(s => s.contractType === "PERPETUAL" && s.symbol.endsWith("USDT"))
          .map(s => s.symbol);

        // Cr√©er toutes les requ√™tes pour chaque symbole
        const requests = symbols.map(async symbol => {
          try {
            // R√©cup√©rer simultan√©ment : ratio L/S, funding rate, ticker 24h
            const [ratioData, fundingData, tickerData] = await Promise.all([
              fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${symbol}&period=5m&limit=1`).then(r => r.json()),
              fetch(`https://fapi.binance.com/fapi/v1/fundingRate?symbol=${symbol}&limit=1`).then(r => r.json()),
              fetch(`https://fapi.binance.com/fapi/v1/ticker/24hr?symbol=${symbol}`).then(r => r.json())
            ]);

            // Parsing des donn√©es
            const longRate = parseFloat(ratioData[0].longAccount) * 100;
            const shortRate = parseFloat(ratioData[0].shortAccount) * 100;
            const ratio = (longRate / shortRate).toFixed(2);

            const funding = parseFloat(fundingData[0].fundingRate) * 100;

            const openInterest = parseFloat(tickerData.openInterest);
            const lastPrice = parseFloat(tickerData.lastPrice);
            const oiUSD = ((openInterest * lastPrice) / 1e6).toFixed(2);

            const highPrice = parseFloat(tickerData.highPrice);
            const lowPrice = parseFloat(tickerData.lowPrice);

            // Calculer la fourchette % (volatilit√© approximative sur 24h)
            const rangePercent = ((highPrice - lowPrice) / ((highPrice + lowPrice)/2)) * 100;

            // Logique pour signal + d√©tection grosse m√®che
            let signal = "Neutre";
            let rowClass = "neutral";

            // Conditions funding extr√™me
            const fundingLongRisk = funding > 0.08 && longRate > 60 && oiUSD > 30;
            const fundingShortRisk = funding < -0.08 && shortRate > 60 && oiUSD > 30;

            // Condition grosse m√®che suspect√©e (>5% range sur 24h)
            const bigWick = rangePercent > 5;

            if (fundingLongRisk && bigWick) {
              signal = "üî¥ LONGs √† risque + grosse m√®che";
              rowClass = "bearish";
            } else if (fundingShortRisk && bigWick) {
              signal = "üü¢ SHORTs √† risque + grosse m√®che";
              rowClass = "bullish";
            } else if (fundingLongRisk) {
              signal = "üî¥ LONGs √† risque";
              rowClass = "bearish";
            } else if (fundingShortRisk) {
              signal = "üü¢ SHORTs √† risque";
              rowClass = "bullish";
            } else if (bigWick) {
              signal = "‚ö†Ô∏è Grosse m√®che d√©tect√©e";
              rowClass = "neutral";
            }

            return `
              <tr class="${rowClass}">
                <td>${symbol}</td>
                <td>${ratio}</td>
                <td>${longRate.toFixed(2)}%</td>
                <td>${shortRate.toFixed(2)}%</td>
                <td>${funding.toFixed(4)}%</td>
                <td>${oiUSD}</td>
                <td>${rangePercent.toFixed(2)}%</td>
                <td>${signal}</td>
              </tr>
            `;
          } catch {
            return "";
          }
        });

        const rows = await Promise.all(requests);
        tableBody.innerHTML = rows.join("");

      } catch (error) {
        console.error("Erreur lors du chargement des donn√©es :", error);
      }
    }

    fetchAllData();
    setInterval(fetchAllData, 300000000000000000); // rafra√Æchit toutes les 30s
  </script>
</body>
</html>


