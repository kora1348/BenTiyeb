<!DOCTYPE html> 
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Multi-dates — 4h</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#94a3b8;
      --up:#16a34a; --down:#dc2626; --zero:#64748b; --border:#1f2937; --header:#0b1220; --accent:#2563eb;
      --total:#facc15;
    }
    *{box-sizing:border-box}
    body{margin:0;background:#0b1020;color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;padding:24px}
    header{max-width:1200px;margin:0 auto 16px;display:flex;gap:12px;align-items:baseline;flex-wrap:wrap}
    header h1{margin:0;font-size:20px;font-weight:700}
    .meta{color:var(--muted);font-size:14px}
    .controls{margin-left:auto;display:flex;gap:12px}
    .controls button{background:var(--accent);border:0;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer;font-family:inherit;font-size:14px}
    .controls button a{color:#fff;text-decoration:none}
    .summary-cards{max-width:1200px;margin:0 auto 16px;display:flex;flex-direction:column;gap:12px}
    .summary-card{
      padding:12px 16px;border-radius:12px;font-size:14px;
      border:1px solid var(--border);
    }
    #variation_negative{
      background:linear-gradient(180deg,rgba(220,38,38,.1),rgba(220,38,38,.04)), var(--card);
      border-color:rgba(220,38,38,.35);
      color:#fecaca;
    }
    #spike_max{
      background:linear-gradient(180deg,rgba(34,197,94,.1),rgba(34,197,94,.04)), var(--card);
      border-color:rgba(34,197,94,.35);
      color:#dcfce7;
    }
    #spike_min{
      background:linear-gradient(180deg,rgba(59,130,246,.1),rgba(59,130,246,.04)), var(--card);
      border-color:rgba(59,130,246,.35);
      color:#dbeafe;
    }
    .summary-card .title{font-weight:700;margin-bottom:8px}
    #variation_negative .title{color:#fca5a5}
    #spike_max .title{color:#86efac}
    #spike_min .title{color:#93c5fd}
    .total-badges{display:flex;gap:10px;flex-wrap:wrap}
    .total-badges .badge{
      background:#1f2937;border:1px solid var(--border);border-radius:999px;
      padding:4px 10px;color:#fff;font-weight:700
    }
    .total-badges .badge.positive{color:#22c55e}
    .total-badges .badge.negative{color:#ef4444}
    .total-badges .badge.zero{color:#94a3b8}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(520px,1fr));gap:16px;max-width:1200px;margin:0 auto}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),transparent),var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden}
    .card header{background:var(--header);border-bottom:1px solid var(--border);padding:10px 12px;display:flex;gap:10px;align-items:center}
    .symbol{font-weight:700;letter-spacing:.3px}
    .status{margin-left:auto;font-size:12px;color:var(--muted)}
    .table-wrap{max-height:70vh;overflow:auto}
    table{width:100%;border-collapse:separate;border-spacing:0;font-variant-numeric:tabular-nums}
    thead th{position:sticky;top:0;background:var(--header);border-bottom:1px solid var(--border);padding:6px 8px;font-size:12px;color:var(--muted);text-align:left}
    thead th.num, tbody td.pct{text-align:right}
    tbody td, tbody th{border-bottom:1px solid rgba(255,255,255,.06);padding:6px 8px;font-size:12px}
    tbody td.time{color:var(--muted)}
    .pct{font-weight:600}
    .up{color:var(--up)} .down{color:var(--down)} .zero{color:var(--zero)}
    .loading,.error{padding:10px 12px;border-top:1px solid var(--border);font-size:13px;color:var(--muted)}
    .error{color:#fca5a5}
    .chip{font-size:11px;font-weight:700;padding:2px 6px;border-radius:6px;border:1px solid var(--border);color:#94a3b8;margin-left:8px}
    .slots strong{font-weight:700}
    .info-banner{max-width:1200px;margin:0 auto 16px;padding:12px;background:rgba(59,130,246,0.1);border:1px solid rgba(59,130,246,0.3);border-radius:8px;color:#93c5fd;font-size:14px;}
  </style>
</head>
<body>
  <header>
    <h1>Variation 4h — Europe/Brussels <span class="chip">Multi-dates + Spike max / min</span></h1>
    <div class="meta" id="metaLine">
      <!-- Injecté en JS : Période • Liste des dates • Timeframe -->
    </div>
    <div class="controls"><button id="reload"><a href="/index.html">Accueil</a></button></div>
  </header>

  <div class="info-banner">
    ⚠️ Les données "n/a" indiquent que le trading n'était pas actif à ces dates ou heures spécifiques
  </div>

  <div class="summary-cards">
    <div id="spike_max" class="summary-card">
      <span class="title">TOTAL Spike max (mèche ↑) par date &amp; heure :</span>
      <div id="total_spike_max" class="total-badges"></div>
    </div>
    
    <div id="spike_min" class="summary-card">
      <span class="title">TOTAL Spike min (mèche ↓) par date &amp; heure :</span>
      <div id="total_spike_min" class="total-badges"></div>
    </div>
    
    <div id="variation_negative" class="summary-card">
      <span class="title">TOTAL (somme des variations de tous les symboles) par date &amp; heure :</span>
      <div id="total_variation" class="total-badges"></div>
    </div>
  </div>

  <div id="grid" class="grid"></div>

<script>
(async () => {
  // --- Utils ---
  function fmtPct(p){ return (p >= 0 ? '+' : '') + p.toFixed(3) + '%'; }
  function clsPct(p){ return 'pct ' + (p > 0 ? 'up' : (p < 0 ? 'down' : 'zero')); }
  function pad(n){ return String(n).padStart(2,'0'); }

  function tzOffsetMsAt(date, tz) {
    const dtf = new Intl.DateTimeFormat('en-GB', {
      timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
    });
    const parts = dtf.formatToParts(date);
    const map = {};
    for (const p of parts) map[p.type] = p.value;
    const asUTC = Date.UTC(+map.year, +map.month-1, +map.day, +map.hour, +map.minute, +map.second);
    return asUTC - date.getTime();
  }

  function localToUtcMs(y, m, d, hh, mm, ss, ms, tz) {
    const approxUtc = Date.UTC(y, m-1, d, hh, mm, ss, ms);
    const offset = tzOffsetMsAt(new Date(approxUtc), tz);
    return approxUtc - offset;
  }

  // --- Paramètres globaux ---
  const timeZone = "Europe/Brussels";
  const windowMinutes = 240; // timeframe 4h (4 × 60)

  // Liste des symboles (à adapter si tu veux)
  const symbols = [
    "1000CHEEMSUSDT", "API3USDT", "BULLAUSDT", "SCRTUSDT", "WLDUSDT", "XVGUSDT"
  ];

  // --- Nouvelles dates & heures 4h (Europe/Brussels, octobre & novembre 2025) ---
  // 15/10/2025 17:00
  // 25/10/2025 17:00
  // 31/10/2025 05:00
  // 07/11/2025 21:00
  // 18/11/2025 13:00
  // 25/11/2025 17:00
  const rawTargets = [
    { y:2025, m:10, d:15, h:17, min:0 }, // 15/10/25 17:00
    { y:2025, m:10, d:25, h:17, min:0 }, // 25/10/25 17:00
    { y:2025, m:10, d:31, h: 5, min:0 }, // 31/10/25 05:00
    { y:2025, m:11, d: 7, h:21, min:0 }, // 07/11/25 21:00
    { y:2025, m:11, d:18, h:13, min:0 }, // 18/11/25 13:00
    { y:2025, m:11, d:25, h:17, min:0 }  // 25/11/25 17:00
  ];

  const targets = rawTargets.map(t => ({
    ...t,
    key: `${t.y}-${pad(t.m)}-${pad(t.d)}_${pad(t.h)}-${pad(t.min)}`,
    label: `${pad(t.d)}/${pad(t.m)}/${t.y} ${pad(t.h)}:${pad(t.min)}`
  }));

  const targetsWithUtc = targets.map(t => {
    const startUtc = localToUtcMs(t.y, t.m, t.d, t.h, t.min, 0, 0, timeZone);
    const endUtc = startUtc + windowMinutes * 60 * 1000 - 1; // fenêtre 4h (en 1m)
    return { ...t, startUtc, endUtc };
  });

  // --- Header dynamique ---
  (function renderHeaderMeta(){
    const meta = document.getElementById('metaLine');
    const df = new Intl.DateTimeFormat('fr-BE', {
      timeZone,
      day:'2-digit', month:'2-digit', year:'numeric'
    });

    const sorted = [...targetsWithUtc].sort((a,b) => a.startUtc - b.startUtc);
    const startLabel = df.format(new Date(sorted[0].startUtc));
    const endLabel   = df.format(new Date(sorted[sorted.length-1].startUtc));

    const list = targetsWithUtc
      .map(t => `<strong>${t.label}</strong>`)
      .join(', ');

    meta.innerHTML = `Période : <strong>${startLabel}</strong> → <strong>${endLabel}</strong> • Dates &amp; heures suivies : ${list} • Timeframe interne : <strong>1m → fenêtre ${windowMinutes} min (4h)</strong>`;
  })();

  // --- DOM ---
  const grid = document.getElementById('grid');
  const totalsBar = document.getElementById('total_variation');
  const totalsSpikeMaxBar = document.getElementById('total_spike_max');
  const totalsSpikeMinBar = document.getElementById('total_spike_min');

  function buildCard(symbol) {
    const card = document.createElement('div'); 
    card.className = 'card';

    const head = document.createElement('header');
    const symEl = document.createElement('div'); 
    symEl.className = 'symbol'; 
    symEl.textContent = symbol;

    const status = document.createElement('div'); 
    status.className = 'status'; 
    status.textContent = 'Chargement…';

    head.appendChild(symEl); 
    head.appendChild(status);

    const wrap = document.createElement('div'); 
    wrap.className = 'table-wrap';

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    thead.innerHTML = `
      <tr>
        <th>Date &amp; heure (Brussels)</th>
        <th class="num">Variation (4h)</th>
        <th class="num">Spike max (mèche ↑)</th>
        <th class="num">Spike min (mèche ↓)</th>
      </tr>`;
    const tbody = document.createElement('tbody');

    // Lignes pour chaque date/heure
    for (const t of targetsWithUtc) {
      const tr = document.createElement('tr');

      const tdTime = document.createElement('td');
      tdTime.className = 'time';
      tdTime.textContent = t.label;

      const tdVar = document.createElement('td');
      tdVar.className = 'pct zero';
      tdVar.textContent = '—';
      tdVar.dataset.target = `${t.key}:var`;

      const tdSpikeUp = document.createElement('td');
      tdSpikeUp.className = 'pct zero';
      tdSpikeUp.textContent = '—';
      tdSpikeUp.dataset.target = `${t.key}:su`;

      const tdSpikeDn = document.createElement('td');
      tdSpikeDn.className = 'pct zero';
      tdSpikeDn.textContent = '—';
      tdSpikeDn.dataset.target = `${t.key}:sd`;

      tr.appendChild(tdTime);
      tr.appendChild(tdVar);
      tr.appendChild(tdSpikeUp);
      tr.appendChild(tdSpikeDn);
      tbody.appendChild(tr);
    }

    table.appendChild(thead); 
    table.appendChild(tbody);
    wrap.appendChild(table);

    const loading = document.createElement('div'); 
    loading.className = 'loading'; 
    loading.textContent = 'Requêtes klines 1m…';

    card.appendChild(head); 
    card.appendChild(wrap); 
    card.appendChild(loading);
    grid.appendChild(card);

    return { card, statusEl: status, loadingEl: loading, tbody };
  }

  function pctChange(open, close) {
    const o = Number(open), c = Number(close);
    if (!isFinite(o) || o === 0 || !isFinite(c)) return null;
    return ((c - o) / o) * 100;
  }

  function spikeMaxPct(open, highs) {
    const o = Number(open);
    if (!isFinite(o) || o === 0 || highs.length === 0) return null;
    let maxH = -Infinity;
    for (const h of highs) {
      const v = Number(h);
      if (isFinite(v) && v > maxH) maxH = v;
    }
    if (!isFinite(maxH)) return null;
    return ((maxH - o) / o) * 100;
  }

  function spikeMinPct(open, lows) {
    const o = Number(open);
    if (!isFinite(o) || o === 0 || lows.length === 0) return null;
    let minL = Infinity;
    for (const l of lows) {
      const v = Number(l);
      if (isFinite(v) && v < minL) minL = v;
    }
    if (!isFinite(minL)) return null;
    return ((minL - o) / o) * 100;
  }

  async function fetchKlines1m(symbol, startUtc, endUtc) {
    console.log(`Fetching ${symbol} from ${new Date(startUtc).toISOString()} to ${new Date(endUtc).toISOString()}`);
    
    // Essayer d'abord l'API Futures
    try {
      const futuresUrl = new URL('https://fapi.binance.com/fapi/v1/klines');
      futuresUrl.searchParams.set('symbol', symbol);
      futuresUrl.searchParams.set('interval', '1m'); // 1m interne
      futuresUrl.searchParams.set('startTime', String(startUtc));
      futuresUrl.searchParams.set('endTime', String(endUtc));
      futuresUrl.searchParams.set('limit', '300'); // couvre largement 4h (240 bougies 1m)
      
      const res = await fetch(futuresUrl.toString());
      if (!res.ok) {
        throw new Error(`Futures API returned ${res.status}`);
      }
      const data = await res.json();
      console.log(`Futures API for ${symbol}:`, data.length, 'candles found');
      
      if (!Array.isArray(data)) throw new Error('Réponse inattendue de Binance Futures.');
      return data;
    } catch (futuresError) {
      console.warn(`Futures API failed for ${symbol}:`, futuresError.message);
      
      // Fallback sur l'API spot
      try {
        const spotUrl = new URL('https://api.binance.com/api/v3/klines');
        spotUrl.searchParams.set('symbol', symbol);
        spotUrl.searchParams.set('interval', '1m');
        spotUrl.searchParams.set('startTime', String(startUtc));
        spotUrl.searchParams.set('endTime', String(endUtc));
        spotUrl.searchParams.set('limit', '300');
        
        const res = await fetch(spotUrl.toString());
        if (!res.ok) {
          throw new Error(`Spot API returned ${res.status}`);
        }
        const data = await res.json();
        console.log(`Spot API for ${symbol}:`, data.length, 'candles found');
        
        if (!Array.isArray(data)) throw new Error('Réponse inattendue de Binance Spot.');
        return data;
      } catch (spotError) {
        console.error(`Both APIs failed for ${symbol}:`, spotError.message);
        throw new Error(`Both Futures and Spot APIs failed: ${spotError.message}`);
      }
    }
  }

  // Préparation cartes
  const cards = symbols.map(s => {
    const built = buildCard(s);
    const rowCells = {};
    for (const t of targetsWithUtc) {
      rowCells[`${t.key}:var`] = built.tbody.querySelector(`td[data-target="${t.key}:var"]`);
      rowCells[`${t.key}:su`]  = built.tbody.querySelector(`td[data-target="${t.key}:su"]`);
      rowCells[`${t.key}:sd`]  = built.tbody.querySelector(`td[data-target="${t.key}:sd"]`);
    }
    return { symbol: s, ...built, rowCells };
  });

  // Suivi des totaux par target
  const totalsVar = new Map();       
  const totalsSpikeMax = new Map();
  const totalsSpikeMin = new Map();
  
  for (const t of targetsWithUtc) {
    totalsVar.set(t.key, {sum:0, count:0});
    totalsSpikeMax.set(t.key, {sum:0, count:0});
    totalsSpikeMin.set(t.key, {sum:0, count:0});
  }

  // Récupération / calculs
  await Promise.allSettled(cards.map(async (c) => {
    c.statusEl.textContent = 'Chargement…';
    c.loadingEl.textContent = 'Requêtes klines 1m…';
    
    try {
      for (const t of targetsWithUtc) {
        const { startUtc, endUtc, key } = t;
        let kl;
        
        try {
          kl = await fetchKlines1m(c.symbol, startUtc, endUtc);
        } catch (fetchError) {
          console.warn(`Impossible de récupérer les données pour ${c.symbol} à ${t.label}:`, fetchError.message);
          kl = [];
        }

        let pVar = null, pSu = null, pSd = null;

        if (kl.length > 0) {
          const first = kl[0];
          const last  = kl[kl.length-1];
          
          // s'assurer que la première bougie correspond bien au début de la fenêtre
          if (Number(first[0]) === startUtc) {
            const open0 = first[1];
            const closeLast = last[4];

            const highs = kl.map(k => k[2]);
            const lows  = kl.map(k => k[3]);

            pVar = pctChange(open0, closeLast);
            pSu  = spikeMaxPct(open0, highs);
            pSd  = spikeMinPct(open0, lows);
          } else {
            console.log(`Données incomplètes pour ${c.symbol} à ${t.label}: première bougie ne correspond pas`);
          }
        } else {
          console.log(`Aucune donnée pour ${c.symbol} à ${t.label}`);
        }

        // Rendu cellules
        const cVar = c.rowCells[`${key}:var`];
        const cSu  = c.rowCells[`${key}:su`];
        const cSd  = c.rowCells[`${key}:sd`];

        if (pVar === null) { 
          cVar.textContent = 'n/a'; 
          cVar.className = 'pct zero'; 
        } else { 
          cVar.textContent = fmtPct(pVar); 
          cVar.className = clsPct(pVar); 
          const tv = totalsVar.get(key); 
          tv.sum += pVar; 
          tv.count += 1; 
        }

        if (pSu === null) { 
          cSu.textContent = 'n/a'; 
          cSu.className = 'pct zero'; 
        } else { 
          cSu.textContent = fmtPct(pSu); 
          cSu.className = clsPct(pSu); 
          const tsu = totalsSpikeMax.get(key); 
          tsu.sum += pSu; 
          tsu.count += 1; 
        }

        if (pSd === null) { 
          cSd.textContent = 'n/a'; 
          cSd.className = 'pct zero'; 
        } else { 
          cSd.textContent = fmtPct(pSd); 
          cSd.className = clsPct(pSd); 
          const tsd = totalsSpikeMin.get(key); 
          tsd.sum += pSd; 
          tsd.count += 1; 
        }
      }
      c.statusEl.textContent = 'OK';
      c.loadingEl.textContent = 'Terminé.';
    } catch (e) {
      c.statusEl.textContent = 'Erreur';
      c.loadingEl.className = 'error';
      c.loadingEl.textContent = 'Échec: ' + (e?.message || e);
    }
  }));

  // Affichage des totaux
  function renderTotals(totalsMap, container) {
    container.innerHTML = '';
    for (const t of targetsWithUtc) {
      const { key, label } = t;
      const { sum, count } = totalsMap.get(key);
      const badge = document.createElement('span');
      badge.className = 'badge ' + (count === 0 ? 'zero' : (sum >= 0 ? 'positive' : 'negative'));
      const txt = count === 0 ? 'n/a' : ((sum>=0?'+':'') + sum.toFixed(3) + '%');
      badge.textContent = `${label} → ${txt}`;
      container.appendChild(badge);
    }
  }

  renderTotals(totalsVar, totalsBar);
  renderTotals(totalsSpikeMax, totalsSpikeMaxBar);
  renderTotals(totalsSpikeMin, totalsSpikeMinBar);

  document.getElementById('reload').addEventListener('click', () => location.reload());
})();
</script>
</body>
</html>
