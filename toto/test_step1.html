<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Variations 1d (bougies daily) â€” Binance Futures USDT-M (PERP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg:#0f172a;
      --card:#111827;
      --muted:#94a3b8;
      --ok:#10b981;
      --bad:#ef4444;
      --text:#e5e7eb;
      --border:#1f2937;
      --warn:#f59e0b;
    }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif
    }
    header{
      padding:18px;
      border-bottom:1px solid var(--border)
    }
    h1{
      margin:0;
      font-size:18px
    }
    .sub{
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
      margin-top:6px
    }
    .wrap{
      padding:16px
    }
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px
    }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:13px
    }
    th,td{
      border-bottom:1px solid var(--border);
      padding:8px 10px;
      white-space:nowrap
    }
    th{
      position:sticky;
      top:0;
      background:var(--card);
      text-align:left
    }
    tfoot td{
      font-weight:700;
      border-top:1px solid var(--border)
    }
    .pos{
      color:var(--ok);
      font-variant-numeric:tabular-nums
    }
    .neg{
      color:var(--bad);
      font-variant-numeric:tabular-nums
    }
    .na{
      color:var(--muted)
    }
    .warn{
      color:var(--warn)
    }
    .controls{
      margin-top:8px
    }
    .btn{
      display:inline-block;
      background:#2563eb;
      color:#fff;
      text-decoration:none;
      border:0;
      border-radius:10px;
      padding:8px 12px;
      font-size:13px;
      cursor:pointer
    }
  </style>
</head>
<body>
  <header>
    <h1>Variations 1d (bougies daily) â€” PERP USDT (Binance Futures)</h1>
    <div class="sub">
      Timeframe : <strong>1d</strong> (bougies journaliÃ¨res Binance Futures USDT-M)<br>
      Dates analysÃ©es (Europe/Brussels) :
      <strong>29/09/2025</strong>,
      <strong>02/10/2025</strong>,
      <strong>10/10/2025</strong>,
      <strong>07/11/2025</strong>,
      <strong>27/11/2025</strong>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <p style="color:var(--muted);font-size:13px;margin-bottom:8px">
        Calcul = (Close<sub>1d</sub> âˆ’ Open<sub>1d</sub>) / Open<sub>1d</sub> Ã— 100<br>
        Chaque colonne correspond Ã  la variation de la bougie <strong>1d</strong> pour la date indiquÃ©e (rÃ©fÃ©rence Europe/Brussels).<br>
        La ligne Â« Total (âˆ‘) Â» additionne les variations (%) des symboles disponibles pour chaque date (valeurs manquantes ignorÃ©es).
      </p>

      <div class="controls">
        <a class="btn" href="/index.html">Accueil</a>
        <button id="reload" class="btn" type="button">Recharger</button>
      </div>

      <table id="table">
        <thead>
          <tr id="thead-row">
            <th>Symbole</th>
            <!-- colonnes de dates injectÃ©es ici -->
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
        <tfoot>
          <tr id="total-row">
            <td>Total (âˆ‘)</td>
            <!-- totaux par date injectÃ©s ici -->
          </tr>
        </tfoot>
      </table>

      <p id="progress" class="warn">PrÃ©parationâ€¦</p>
    </div>
  </div>

  <script>
    const BASE = "https://fapi.binance.com";
    const INTERVAL = "1d";          // â— timeframe daily
    const MAX_CONCURRENCY = 8;

    // â— Uniquement ces dates (Europe/Brussels), en daily
    const points = [
      { label:"29/09/2025", y:2025, m:9,  d:29, h:0,  min:0 },
      { label:"02/10/2025", y:2025, m:10, d:2,  h:0,  min:0 },
      { label:"10/10/2025", y:2025, m:10, d:10, h:0,  min:0 },
      { label:"07/11/2025", y:2025, m:11, d:7,  h:0,  min:0 },
      { label:"27/11/2025", y:2025, m:11, d:27, h:0,  min:0 }
    ];

    const theadRow = document.getElementById("thead-row");
    const tbody = document.getElementById("tbody");
    const totalRow = document.getElementById("total-row");
    const progress = document.getElementById("progress");

    // CrÃ©ation des colonnes (une par date)
    for (const p of points) {
      const th = document.createElement("th");
      th.textContent = p.label + " (1d)";
      theadRow.appendChild(th);
    }

    // Gestion DST Europe/Brussels (comme dans ton ancien code)
    function tzOffsetMsAt(date, tz) {
      const fmt = new Intl.DateTimeFormat('en-GB', {
        timeZone: tz,
        year:'numeric', month:'2-digit', day:'2-digit',
        hour:'2-digit', minute:'2-digit', second:'2-digit',
        hour12:false
      });
      const parts = Object.fromEntries(fmt.formatToParts(date).map(p => [p.type, p.value]));
      const asUTC = Date.UTC(+parts.year, +parts.month - 1, +parts.day, +parts.hour, +parts.minute, +parts.second);
      return asUTC - date.getTime();
    }

    function brusselsLocalToUtcMs(y, m, d, h, min) {
      const approxUtc = Date.UTC(y, m - 1, d, h, min, 0, 0);
      const offset = tzOffsetMsAt(new Date(approxUtc), 'Europe/Brussels');
      return approxUtc - offset;
    }

    // Chaque point = journÃ©e (minuit â†’ +24h - 1ms) en heure locale Bruxelles
    const dayTimes = points.map(p => {
      const openTimeMs = brusselsLocalToUtcMs(p.y, p.m, p.d, p.h, p.min);
      const endTimeMs = openTimeMs + 24 * 60 * 60 * 1000 - 1; // 24h - 1ms
      return {
        label: p.label,
        openTimeMs,
        endTimeMs
      };
    });

    async function getAllPerpUsdtSymbols(){
      const r = await fetch(`${BASE}/fapi/v1/exchangeInfo`);
      if(!r.ok) throw new Error("exchangeInfo error");
      const info = await r.json();
      return info.symbols
        .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
        .map(s => s.symbol)
        .sort();
    }

    // ðŸ”¥ Variation daily : open et close de la bougie 1d comprise dans la fenÃªtre
    async function fetchKlineDailyPct(symbol, day){
      const url = `${BASE}/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}` +
                  `&startTime=${day.openTimeMs}&endTime=${day.endTimeMs}&limit=500`;
      const r = await fetch(url);
      if(!r.ok) return null;
      const data = await r.json();
      if(!Array.isArray(data) || data.length === 0) return null;

      // En daily, on s'attend Ã  une seule bougie dans cette fenÃªtre
      const first = data[0];
      const open = parseFloat(first[1]);
      const close = parseFloat(first[4]);

      if(!isFinite(open) || !isFinite(close) || open === 0) return null;
      return (close - open) / open * 100;
    }

    function fmtPct(v){
      if(v == null) return `<span class="na">â€”</span>`;
      const cls = v >= 0 ? "pos" : "neg";
      return `<span class="${cls}">${v.toFixed(2)}%</span>`;
    }
    function fmtTotal(v){
      if(v == null) return `<span class="na">â€”</span>`;
      const cls = v >= 0 ? "pos" : "neg";
      return `<span class="${cls}">${v.toFixed(2)}%</span>`;
    }

    async function mapWithConcurrency(items, fn, concurrency){
      const results = new Array(items.length);
      let i = 0, active = 0, done = 0;
      return new Promise(resolve => {
        const next = () => {
          while(active < concurrency && i < items.length){
            const idx = i++, item = items[idx]; active++;
            Promise.resolve(fn(item, idx))
              .then(res => results[idx] = res)
              .catch(() => results[idx] = null)
              .finally(() => {
                active--; done++;
                if(done % 10 === 0) progress.textContent = `Progression : ${done}/${items.length}`;
                if(done === items.length) resolve(results);
                else next();
              });
          }
        };
        next();
      });
    }

    async function main(){
      progress.textContent = "RÃ©cupÃ©ration des symboles PERP USDTâ€¦";
      const symbols = await getAllPerpUsdtSymbols();

      // Une cellule de total par date
      const totalCells = [];
      for (let i=0;i<dayTimes.length;i++){
        const td = document.createElement("td");
        td.innerHTML = `<span class="na">â€”</span>`;
        totalRow.appendChild(td);
        totalCells.push(td);
      }
      const sums = new Array(dayTimes.length).fill(0);
      const counts = new Array(dayTimes.length).fill(0);

      const rows = new Map();
      for(const s of symbols){
        const tr = document.createElement("tr");
        const tdSym = document.createElement("td");
        tdSym.textContent = s;
        tr.appendChild(tdSym);
        for(let i=0;i<dayTimes.length;i++){
          const td = document.createElement("td");
          td.innerHTML = `<span class="warn">â€¦</span>`;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
        rows.set(s, tr);
      }

      await mapWithConcurrency(symbols, async (symbol) => {
        const tr = rows.get(symbol);
        for(let i=0;i<dayTimes.length;i++){
          try{
            const pct = await fetchKlineDailyPct(symbol, dayTimes[i]);
            tr.children[i+1].innerHTML = fmtPct(pct);
            if(pct != null){
              sums[i] += pct;
              counts[i]++;
            }
          }catch{
            tr.children[i+1].innerHTML = `<span class="na">â€”</span>`;
          }
          // petit throttle pour Ã©viter de spam l'API
          await new Promise(r=>setTimeout(r,35));
        }
      }, MAX_CONCURRENCY);

      for(let i=0;i<dayTimes.length;i++){
        totalCells[i].innerHTML = counts[i] > 0 ? fmtTotal(sums[i]) : `<span class="na">â€”</span>`;
      }
      progress.textContent = `TerminÃ© âœ… (${symbols.length} symboles)`;
    }

    document.getElementById('reload').addEventListener('click', () => location.reload());

    main().catch(e=>{
      console.error(e);
      progress.textContent = "Erreur : " + e.message;
    });
  </script>
</body>
</html>
