<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbitrage RÃ©el Binance/MEXC</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #0f1923; color: #eaeaea; }
        #container { max-width: 1000px; margin: 0 auto; background: #1a2a3a; padding: 20px; border-radius: 10px; }
        .platform { background: #253546; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .green-candle { color: #4caf50; font-weight: bold; }
        .red-candle { color: #f44336; }
        #arbitrage-signal { 
            background: linear-gradient(90deg, #1e3c72, #2a5298);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid #4fc3f7;
        }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: center; border: 1px solid #2d3e50; }
        th { background-color: #2d3e50; }
        .blink { animation: blink 1s step-start infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>
    <div id="container">
        <h1>ðŸš€ Arbitrage RÃ©el IDEX (Binance vs MEXC)</h1>
        <p>DÃ©tection temps rÃ©el du dÃ©calage entre plateformes (15m)</p>

        <div class="platform">
            <h2>Binance Futures (API RÃ©elle)</h2>
            <div id="binance-chart-container">
                <canvas id="binance-chart"></canvas>
            </div>
            <div id="binance-signal">Connexion Ã  l'API Binance...</div>
        </div>

        <div class="platform">
            <h2>MEXC Futures (API RÃ©elle)</h2>
            <div id="mexc-chart-container">
                <canvas id="mexc-chart"></canvas>
            </div>
            <div id="mexc-signal">Connexion Ã  l'API MEXC...</div>
        </div>

        <div id="arbitrage-signal">
            <h3>ðŸ“Š Signal d'Arbitrage Temps RÃ©el</h3>
            <div id="arbitrage-opportunity" class="blink">Analyse en cours...</div>
            <table>
                <tr>
                    <th>Dernier Ã‰cart</th>
                    <th>DÃ©lai ConstatÃ©</th>
                    <th>Action RecommandÃ©e</th>
                </tr>
                <tr>
                    <td id="last-spread">-</td>
                    <td id="last-delay">-</td>
                    <td id="recommendation">-</td>
                </tr>
            </table>
        </div>
    </div>

    <script>
        // Configuration
        const SYMBOL = "IDEX_USDT"; // Format MEXC
        const BINANCE_SYMBOL = "IDEXUSDT"; // Format Binance
        const INTERVAL = "15m";
        const PROFIT_THRESHOLD = 0.003; // 0.3%

        // Ã‰lÃ©ments DOM
        const binanceCtx = document.getElementById('binance-chart').getContext('2d');
        const mexcCtx = document.getElementById('mexc-chart').getContext('2d');
        const binanceSignal = document.getElementById('binance-signal');
        const mexcSignal = document.getElementById('mexc-signal');
        const arbSignal = document.getElementById('arbitrage-opportunity');
        const lastSpread = document.getElementById('last-spread');
        const lastDelay = document.getElementById('last-delay');
        const recommendation = document.getElementById('recommendation');

        // DonnÃ©es
        let binanceData = [];
        let mexcData = [];
        let binanceChart, mexcChart;
        let lastBinanceUpdate = null;
        let lastMEXCUpdate = null;

        // 1. API Binance (Futures)
        async function fetchBinanceData() {
            try {
                const response = await axios.get(`https://fapi.binance.com/fapi/v1/klines?symbol=${BINANCE_SYMBOL}&interval=${INTERVAL}&limit=10`);
                binanceData = response.data.map(c => ({
                    time: new Date(c[0]),
                    open: parseFloat(c[1]),
                    high: parseFloat(c[2]),
                    low: parseFloat(c[3]),
                    close: parseFloat(c[4]),
                    volume: parseFloat(c[5]),
                    isGreen: parseFloat(c[4]) > parseFloat(c[1])
                }));
                lastBinanceUpdate = new Date();
                
                updateBinanceChart();
                checkArbitrage();
                binanceSignal.innerHTML = `<span>DerniÃ¨re bougie: <span class="${binanceData[binanceData.length-1].isGreen ? 'green-candle' : 'red-candle'}">${binanceData[binanceData.length-1].close.toFixed(6)}</span> (${lastBinanceUpdate.toLocaleTimeString()})</span>`;
            } catch (error) {
                console.error("Erreur API Binance:", error);
                binanceSignal.innerHTML = `<span class="red-candle">Erreur API Binance</span>`;
            }
        }

        // 2. API MEXC (Futures)
        async function fetchMEXCData() {
            try {
                const response = await axios.get(`https://api.mexc.com/api/v3/klines?symbol=${SYMBOL}&interval=15m&limit=10`);
                mexcData = response.data.map(c => ({
                    time: new Date(c[0]),
                    open: parseFloat(c[1]),
                    high: parseFloat(c[2]),
                    low: parseFloat(c[3]),
                    close: parseFloat(c[4]),
                    volume: parseFloat(c[5]),
                    isGreen: parseFloat(c[4]) > parseFloat(c[1])
                }));
                lastMEXCUpdate = new Date();
                
                updateMEXCChart();
                checkArbitrage();
                mexcSignal.innerHTML = `<span>DerniÃ¨re bougie: <span class="${mexcData[mexcData.length-1].isGreen ? 'green-candle' : 'red-candle'}">${mexcData[mexcData.length-1].close.toFixed(6)}</span> (${lastMEXCUpdate.toLocaleTimeString()})</span>`;
            } catch (error) {
                console.error("Erreur API MEXC:", error);
                mexcSignal.innerHTML = `<span class="red-candle">Erreur API MEXC</span>`;
            }
        }

        // 3. DÃ©tection d'arbitrage
        function checkArbitrage() {
            if (!binanceData.length || !mexcData.length) return;

            const binanceLast = binanceData[binanceData.length - 1];
            const mexcLast = mexcData[mexcData.length - 1];
            
            // Calcul du dÃ©calage
            const priceDiff = binanceLast.close - mexcLast.close;
            const percentDiff = (priceDiff / mexcLast.close) * 100;
            const timeDiff = lastMEXCUpdate - lastBinanceUpdate;
            
            // Mise Ã  jour des stats
            lastSpread.textContent = `${percentDiff.toFixed(2)}%`;
            lastDelay.textContent = `${timeDiff/1000}s`;
            
            // Signal d'arbitrage
            if (binanceLast.isGreen && !mexcLast.isGreen && percentDiff > PROFIT_THRESHOLD * 100) {
                arbSignal.innerHTML = `
                    <span style="color: #4caf50; font-weight: bold;">
                    ðŸš€ LONG MEXC IMMÃ‰DIAT!<br>
                    Binance: ${binanceLast.close.toFixed(6)} (VERT)<br>
                    MEXC: ${mexcLast.close.toFixed(6)} (ROUGE)<br>
                    Ã‰cart: ${percentDiff.toFixed(2)}%
                    </span>
                `;
                recommendation.textContent = `ACHETER sur MEXC â†’ Vendre Ã  ${(mexcLast.close * 1.003).toFixed(6)}`;
            } else {
                arbSignal.innerHTML = `<span>Pas d'opportunitÃ© (Ã©cart: ${percentDiff.toFixed(2)}%)</span>`;
                recommendation.textContent = "Attendre";
            }
        }

        // 4. Graphiques
        function updateBinanceChart() {
            const labels = binanceData.map(d => d.time.toLocaleTimeString());
            const closes = binanceData.map(d => d.close);
            
            if (binanceChart) binanceChart.destroy();
            
            binanceChart = new Chart(binanceCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Binance',
                        data: closes,
                        borderColor: '#4caf50',
                        borderWidth: 2,
                        tension: 0.1
                    }]
                },
                options: getChartOptions()
            });
        }

        function updateMEXCChart() {
            const labels = mexcData.map(d => d.time.toLocaleTimeString());
            const closes = mexcData.map(d => d.close);
            
            if (mexcChart) mexcChart.destroy();
            
            mexcChart = new Chart(mexcCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'MEXC',
                        data: closes,
                        borderColor: '#f44336',
                        borderWidth: 2,
                        tension: 0.1
                    }]
                },
                options: getChartOptions()
            });
        }

        function getChartOptions() {
            return {
                responsive: true,
                scales: {
                    x: { display: true, grid: { color: '#2d3e50' } },
                    y: { 
                        display: true, 
                        grid: { color: '#2d3e50' },
                        ticks: { callback: v => parseFloat(v).toFixed(6) }
                    }
                },
                plugins: {
                    legend: { labels: { color: '#eaeaea' } }
                }
            };
        }

        // Initialisation
        fetchBinanceData();
        fetchMEXCData();
        setInterval(fetchBinanceData, 10000); // Toutes les 10s
        setInterval(fetchMEXCData, 10000);    // Toutes les 10s
    </script>
</body>
</html>